---
title: "DNA Methylation in the DO"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

The purpose of this workflow is to impute DNA methylation states
in DO mice and map local gene expression.

```{r load_libraries}
library(here)
is.interactive = FALSE
#is.interactive = TRUE
```

```{r source_code}
all.code.dir <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.code.dir)){
	all.fun <- list.files(all.code.dir[i], full.names = TRUE)
	for(j in 1:length(all.fun)){source(all.fun[j])}
}
```


```{r load_other_lib}
needed.packages <- c("qtl2", "abind", "pheatmap", "parallel", "doParallel")
load_libraries(needed.packages)
```


```{r read_data}
gene.info <- readRDS(here("Data", "RNASeq", "RNASeq_gene_info.RData"))
strain.table <- as.matrix(read.delim(here("Data", "support_files", "strain.color.table.txt"),
comment.char = "!", header = FALSE))

vars <- load(here("Data", "DOQTL", "Svenson_DO850_for_eQTL_viewer_v9.RData"))
expr <- dataset.mrna$data$rz
covar <- dataset.mrna$covar.matrix

col.table <- as.matrix(read.table(here("Data", "support_files", "strain.color.table.txt"), 
sep = "\t", comment.char = "%", stringsAsFactors = FALSE))
strains <- col.table[,6]
```

Read in the gene methylation data from 3.1.1_RRBS_Analysis.Rmd

```{r gene_methyl}
methyl.mat.file <- here("Results", "RRBS", "Aligned.Methyl.Mats.RDS")
methyl.mats <- readRDS(methyl.mat.file)

#transcripts that are shared between RRBS and DO expression data
methyl.id <- gene.info[match(names(methyl.mats), gene.info[,"external_gene_name"]),"ensembl_gene_id"]
methyl.id <- methyl.id[which(!is.na(methyl.id))]
ordered.transcript.info <- gene.info[match(methyl.id, gene.info[,"ensembl_gene_id"]),]
```

```{r fun}
get_nearest_marker <- function(chr, start.pos){
    if(is.na(chr)){return(NA)}
    if(chr == "MT"){return(NA)}
    chr.locale <- which(names(map) == chr)
    nearest.marker <- get.nearest.pt(map[[chr.locale]], start.pos/1e6)
    marker.geno <- genoprobs[[chr.locale]][,,nearest.marker]
    return(marker.geno)
}

rrbs_geno <- function(gene.rrbs.array, haplotype.matrix, gene.chr, perm.order = NULL){
    if(length(gene.rrbs.array) == 1){return(NA)}
    if(length(haplotype.matrix) <= 1){return(NA)}
    #filter out NAs
    has.all <- which(apply(gene.rrbs.array, 2, function(x) all(!is.na(x))))
    if(length(has.all) <= 1){return(NA)}
    #plot.methyl.mat(gene.rrbs.array[,has.all])
    #boxplot(gene.rrbs.array[,has.all])
    #pheatmap(cor(gene.rrbs.array[,has.all]), cluster_rows = FALSE, cluster_cols = FALSE)

    #bin the methylation into 0, 50, and 100
    #this prevents transferring haplotypes directly
    #onto very small variations in methylation
    binned.rrbs <- t(apply(gene.rrbs.array[,has.all,drop=FALSE], 1, function(x) bin.vector(x, c(0, 50, 100))))
        
    #do the imputation, with a shuffled haplotype order if requested
    if(is.null(perm.order)){
      all.rrbs <- haplotype.matrix %*% binned.rrbs
    }else{
      perm.rrbs <- binned.rrbs[perm.order,]
      rownames(perm.rrbs) <- rownames(binned.rrbs)
      all.rrbs <- haplotype.matrix %*% perm.rrbs
    }
    #pheatmap(all.rrbs, cluster_cols = FALSE)
    #boxplot(all.rrbs) 
    #pheatmap(haplotype.matrix)
    #hap.cor <- matrix(NA, nrow = ncol(haplotype.matrix), ncol = ncol(all.rrbs))
    #rownames(hap.cor) <- colnames(haplotype.matrix)
    #colnames(hap.cor) <- colnames(all.rrbs)
    #for(i in 1:ncol(haplotype.matrix)){    
    #  hap.cor[i,] <- apply(all.rrbs, 2, function(x) cor(x, haplotype.matrix[,i]))
    #}
    #pheatmap(hap.cor, cluster_rows = FALSE, cluster_cols = FALSE)
    #which(hap.cor[1,] == 1)
    #gene.rrbs.array[,"67245515"]
    
    all.rrbs.mat <- abind(all.rrbs, round(100-all.rrbs), along = 3)
    dimnames(all.rrbs.mat)[[3]] <- c("A", "B")
    all.rrbs.array <- aperm(all.rrbs.mat, c(1,3,2))
    one.geno <- list(all.rrbs.array)

    #add attributes
    names(one.geno) <- gene.chr
    if(gene.chr == "X"){
      attr(one.geno, "is_x_chr") <- TRUE
    }else{
      attr(one.geno, "is_x_chr") <- FALSE
    }
    attr(one.geno, "crosstype") <- "do"
    attr(one.geno, "alleles") <- dimnames(all.rrbs.array)[[3]]
    attr(one.geno, "alleleprobs") <- TRUE
    attr(one.geno, "class") <- c("calc_genoprob", "list")
    return(one.geno)
}

```


## Get Genotypes for Nearest Markers

For every gene in our list, pull out the genotype matrix for the marker
nearest the TSS.

```{r set_gene}
gene.marker <- vector(mode = "list", length = length(methyl.id))
names(gene.marker) <- methyl.id
for(i in 1:length(methyl.id)){
  if(is.interactive){report.progress(i, length(methyl.id))}
  gene.chr <- ordered.transcript.info[i,"chromosome_name"]
  gene.pos <- ordered.transcript.info[i, "start_position"]
  if(gene.chr != "Y" && gene.chr != "MT"){
    gene.marker[[i]] <- get_nearest_marker(gene.chr,gene.pos) 
  }
}
```

## Impute DO methylation percent and map

Derive DNA methylation percentages for each mouse given 
the genoprobs and the methylation data compiled from 3.1.1_RRBS_Analysis.Rmd. 
This array will have DNA methylation percentage estimates for each 
individual by position.

To generate this array we multiply each DNA methylation matrix along 
the genome by the haplotype matrix for the gene.

```{r scan_rrbs_geno}
#convert to RRBS arrays and scan.
#The arrays are too big to store, so we
#scan them right away and only keep the 
#LOD scores.
strain.order <- order.strains(dimnames(genoprobs[[1]])[[2]], rownames(methyl.mats[[1]]), col.table)
common.ind <- intersect(rownames(expr), rownames(genoprobs[[1]]))
common.expr.locale <- match(common.ind, rownames(expr))
common.genoprob.locale <- match(common.ind, rownames(genoprobs[[1]]))
rrbs.lod.file <- here("Results", "RRBS", "RRBS.LOD.scores.RDS")
rrbs.r2.file <- here("Results", "RRBS", "RRBS.R2.RDS")
if(!file.exists(rrbs.lod.file)){
    all.rrbs.lod <- all.rrbs.r2 <- vector(mode = "list", length = length(methyl.id))
    names(all.rrbs.lod) <- names(all.rrbs.r2) <- methyl.id
    for(i in 1:length(all.rrbs.lod)){
        if(is.interactive){report.progress(i, length(all.rrbs.lod))}
        methyl.mat.locale <- which(names(methyl.mats) == ordered.transcript.info[i,"external_gene_name"])
        if(length(methyl.mats[[methyl.mat.locale]]) > 1 && nrow(methyl.mats[[methyl.mat.locale]]) <= 5000){
          transcript.chr <- ordered.transcript.info[i,"chromosome_name"]
          if(!is.na(transcript.chr) && transcript.chr != "X" && transcript.chr != "MT"){
              rrbs.mat <- methyl.mats[[methyl.mat.locale]][strain.order,,drop=FALSE]
              hap.mat <- gene.marker[[i]]
              rrbs.array <- rrbs_geno(gene.rrbs.array = rrbs.mat, 
                haplotype.matrix = hap.mat, 
                gene.chr = ordered.transcript.info[i,"chromosome_name"])
              if(!is.na(rrbs.array)){
                gene.expr <- expr[,which(colnames(expr) == methyl.id[i]),drop=FALSE]
                if(length(gene.expr) > 0){
                  adj.expr <- adjust(gene.expr, covar)
                  all.rrbs.lod[[i]] <- scan1(rrbs.array, adj.expr)
                  #quartz();plot(as.numeric(rownames(all.rrbs.lod[[i]])), all.rrbs.lod[[i]][,1], type  = "h",xlab = "Genomic Position", ylab = "DNA Methylation LOD score")
                  regression.models <- apply(rrbs.array[[1]][common.genoprob.locale,1,], 2, function(x) if(var(x) > 0){lm(adj.expr[common.expr.locale,]~x)}else{NA})
                  all.rrbs.r2[[i]] <- sapply(regression.models, function(x) if(length(x) > 1){summary(x)$adj.r.squared}else{NA})
                  #quartz();barplot(all.rrbs.r2[[i]])
                }
              }
          }
        }
    }
    saveRDS(all.rrbs.lod, rrbs.lod.file)
    saveRDS(all.rrbs.r2, rrbs.r2.file)
}else{
  all.rrbs.lod <- readRDS(rrbs.lod.file)
  all.rrbs.r2 <- readRDS(rrbs.r2.file)
}
```


## Permute RRBS

We permuted the DNA methylation as we did for chromatin 
states. We permute the haplotype that is assigned to 
each DNA methylation vector, re-do the imputation, 
and recalculate the LOD scores and R2 values.


```{r perm_fun}
#This function and the perm data will be exported to the
#clusters
scan_one_rrbs <- function(perm.data, p){
    
  perm.order <- order.mat[p,]

  imp.geno <- rrbs_geno(gene.rrbs.array = perm.data$rrbs.mat, 
            haplotype.matrix = perm.data$hap.mat, 
            gene.chr = perm.data$chr, perm.order)
          
  if(is.na(imp.geno)){return(NA)}

  one.lod <- scan1(imp.geno, perm.data$gene.expr)
  #quartz();plot(as.numeric(rownames(all.rrbs.lod[[i]])), all.rrbs.lod[[i]][,1], type  = "h",xlab = "Genomic Position", ylab = "DNA Methylation LOD score")
  regression.models <- apply(imp.geno[[1]][common.genoprob.locale,1,], 2, 
      function(x) if(var(x) > 0){lm(perm.data$gene.expr[common.expr.locale,]~x)}else{NA})
  one.rrbs.r2 <- sapply(regression.models, function(x) if(length(x) > 1){summary(x)$adj.r.squared}else{NA})

  results <- list("one.lod" = one.lod, 
    "one.r2" = one.rrbs.r2)

  return(results)
}
```

```{r select_nperm}
nperm = 1000
```


```{r set_perm}
#select a set of permutations for which none of 
#the haplotypes remain in their original position.
#these are called derrangements
perm.mat <- derrangements(8)
#sample a random set of derraangements to use
#for all transcripts
perm.rows <- sample(1:nrow(perm.mat), nperm)
order.mat <- perm.mat[perm.rows,]
```



```{r perm_files}

perm.lod.rrbs.file <- here("Results", "RRBS", "Perm.RRBS.LOD.RDS")
perm.r2.rrbs.file <- here("Results", "RRBS", "Perm.RRBS.R2.RDS")

if(file.exists(perm.lod.rrbs.file)){
  perm.rrbs.lod <- readRDS(perm.lod.rrbs.file)
  perm.rrbs.r2 <- readRDS(perm.r2.rrbs.file)

  #figure out where we left off.
  not.na <- which(!is.na(perm.rrbs.lod[,1]))  
  left.off <- max(not.na)
  start.at <- left.off + 1
}else{
  start.at <- 1
  #if we are at the beginning, intialize all the objects for holding
  #results. 
  perm.rrbs.lod <- perm.rrbs.r2 <- matrix(NA, nrow = length(methyl.id), ncol = nperm)
  rownames(perm.rrbs.lod) <- rownames(perm.rrbs.r2) <- methyl.id
}
```


```{r set_cl, warning = FALSE}
save.every = 100
if(start.at < length(methyl.id)){
  #set up the clusters if we need to run perutations
  n.cores <- detectCores() - 1
  to.export <- c("scan1", "scan1coef", "scan_one_rrbs", "rrbs_geno", 
    "order.mat", "bin.vector", "abind", "common.genoprob.locale", 
    "common.expr.locale")

  #create and register multiple cores for parallele permutations
  cl <- makeCluster(n.cores)
  registerDoParallel(cl)
  #export everything we need to the cluster
  #this takes time upfront, but the parallelization
  #saves a huge amount of time overall
  clusterExport(cl, to.export) 
}
```


```{r perm_rrbs}

if(start.at < length(methyl.id)){
  sink(here("Results", "RRBS", "progress.txt"))
  for(tr in 6097:length(perm.rrbs.lod)){
      if(tr == 3794){next()}
      print(tr)
      methyl.mat.locale <- which(names(methyl.mats) == ordered.transcript.info[tr,"external_gene_name"])

      #checks for methylation matrix
      if(length(methyl.mats[[methyl.mat.locale]]) <= 1){next()} #it exists
      if(ncol(methyl.mats[[methyl.mat.locale]]) > 2000){next()} #is is of a reasonable size

      transcript.chr <- ordered.transcript.info[i,"chromosome_name"]

      #checks for chromosome
      if(is.na(transcript.chr) || transcript.chr == "X" || transcript.chr == "MT"){next()}
      
      rrbs.mat <- methyl.mats[[methyl.mat.locale]][strain.order,,drop=FALSE]
      hap.mat <- gene.marker[[tr]]
      rrbs.array <- rrbs_geno(gene.rrbs.array = rrbs.mat, 
        haplotype.matrix = hap.mat, 
        gene.chr = ordered.transcript.info[i,"chromosome_name"])

      #check for rrbs.array
      if(is.na(rrbs.array)){next()}

      gene.expr <- expr[,which(colnames(expr) == methyl.id[tr]),drop=FALSE]

      #check for gene expr
      if(length(gene.expr) == 0){next()}
      adj.expr <- adjust(gene.expr, covar)

      perm.data <- list("gene.expr" = gene.expr, 
        "rrbs.mat" = rrbs.mat, "hap.mat" = hap.mat,
        "chr" = ordered.transcript.info[tr,"chromosome_name"])

      #send the new gene ID to the clusters
      clusterExport(cl, "perm.data")

      #do the permutations in parallel
      perm.rrbs.results <- parLapply(cl, 1:nperm, 
          function(p) scan_one_rrbs(perm.data, 
          p = p))

      #check for data returned from permutations
      if(!all(sapply(perm.rrbs.results, length) > 1)){next()}
      
      perm.tr.lod <- lapply(perm.rrbs.results, function(x) x$one.lod)
      perm.tr.r2 <- lapply(perm.rrbs.results, function(x) x$one.r2)

      #keep the maximum r2 and LOD values from each permutation.
      perm.rrbs.lod[tr,] <- t(sapply(perm.tr.lod, function(x) max(x[,1])))
      perm.rrbs.r2[tr,] <- t(sapply(perm.tr.r2, function(x) max(x, na.rm = TRUE)))

      if(tr %% save.every == 0){
          saveRDS(perm.rrbs.lod, perm.lod.rrbs.file)
          saveRDS(perm.rrbs.r2, perm.r2.rrbs.file)
      }
  } #end looping over transcripts
  #save again at the very end
  saveRDS(perm.rrbs.lod, perm.lod.rrbs.file)
  saveRDS(perm.rrbs.r2, perm.r2.rrbs.file)

  sink()

  #close the clusters at the end and save the final objects
  stopCluster(cl)

} #end case for needing to do more permutations.
```

## Assess permutations

To assess the permutations, we look at the distribution
of empirical p values. If this distribution is uniform,
then it is the imputation itself that is explaining the
LOD scores we see. If the distribution is skewed toward
0, then the DNA methylation is adding something beyond
the imputation itself.

The plots below show the distributions of p values for both 
the R2 statistic and the LOD score statistic. Both are
skewed toward 0. The dot plot shows that the p values for 
these two statistics are highly correlated, but not identical.

```{r assess_lod_perm, fig.width = 8, fig.height = 8}
geno.lod <- readRDS(here("Results", "ChromHMM", "14_states_C", "eQTL.lod.RDS"))
low.lod <- which(geno.lod[,"Additive"] <= 6)
low.lod.idx <- match(rownames(geno.lod)[low.lod], names(all.rrbs.lod))

max.rrbs.lod <- sapply(all.rrbs.lod, function(x) if(length(x) > 1){max(x[,1], na.rm = TRUE)}else{NA})
lod.p <- sapply(1:length(all.rrbs.lod), 
  function(x) if(!all(is.na(perm.rrbs.lod[x,]))){emp.p(max.rrbs.lod[x], perm.rrbs.lod[x,])}else{NA})
names(lod.p) <- names(all.rrbs.lod)

max.rrbs.r2 <- sapply(all.rrbs.r2, function(x) if(!all(is.na(x))){max(x, na.rm = TRUE)}else{NA})
r2.p <- sapply(1:length(all.rrbs.r2), 
  function(x) if(!all(is.na(perm.rrbs.r2[x,]))){emp.p(max.rrbs.r2[x], perm.rrbs.r2[x,])}else{NA})
names(r2.p) <- names(all.rrbs.r2)

par(mfrow = c(2,2))
lod.p[low.lod.idx] <- NA
hist(lod.p, breaks = 100, main = "LOD score p",
  xlab = "p value")

r2.p[low.lod.idx] <- NA
hist(r2.p, breaks = 100, main = "R2 p",
  xlab = "p value")

plot(-log10(lod.p+1e-3), -log10(r2.p+1e-3), xlab = "-log10(LOD p)",
  ylab = "-log10(R2 p)", main = "LOD p vs. R2 p")
```

The following plots show each test statistic vs. its
p values. In general higher test statistics have lower
p values, but this is not strictly true. 


```{r stat_v_p, fig.width = 8, fig.height = 4}
par(mfrow = c(1,2))
plot(max.rrbs.lod, -log10(lod.p+1e-3), xlab = "LOD", ylab = "-log10(p)", 
  main = "LOD vs. LOD -log10(p)")

plot(max.rrbs.r2, -log10(r2.p+1e-3), xlab = "Variance Explained", 
  ylab = "-log10(p)", main = "R2 vs. R2-log10(p)")
```

```{r example, eval = FALSE}
examples <- which(lod.p == 0)
i <- examples[4]
gene.name = gene.info[which(gene.info[,"ensembl_gene_id"] == names(lod.p)[i]),"external_gene_name"][1]
xlim <- c(min(c(perm.rrbs.lod[i,], max.rrbs.lod[i])), max(c(perm.rrbs.lod[i,], max.rrbs.lod[i])))
hist_with_points(c(perm.rrbs.lod[i,], max.rrbs.lod[i]), 
  col = c(rep("gray", ncol(perm.rrbs.lod)), "red"), xlab = "LOD", main = gene.name)
abline(v = max.rrbs.lod[i], col = "red")
```
