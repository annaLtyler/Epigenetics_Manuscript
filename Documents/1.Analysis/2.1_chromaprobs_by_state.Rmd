---
title: "Map chromatin to genotype"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---


The purpose of this workflow is to impute chromatin states onto the DO mice
for each transcript using their genotypes at the marker nearest the TSS
of the transcript.

We then scan these chromatin probabilities in qtl2 to infer the effects of 
chromatin state on each transcript.

The basic pipeline for mapping chromatin to genotype is as follows: 

1. For each transcript identify the DO haplotypes at the marker nearest the TSS.
2. Use the haplotypes to calculate the chromatin states for each DO individual.
3. Calculate chromatin effects on transcript abundance using qtl2.

```{r source_code}
library("here")
all.code.dir <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.code.dir)){
	all.fun <- list.files(all.code.dir[i], full.names = TRUE)
	for(j in 1:length(all.fun)){source(all.fun[j])}
}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
args <- commandArgs(trailingOnly=T)
num.states <- as.numeric(args[1])
delete.previous <- as.logical(args[2])

if(is.na(num.states)){num.states = 14; delete.previous = FALSE}

needed.packages <- c("qtl2", "gtools", "parallel", "doParallel", "abind",
  "Matrix")
load_libraries(needed.packages, personal.library = TRUE)

results.dir <- here("Results", "ChromHMM", paste0(num.states, "_states_C"))
#barplot(1:length(chrom.colors), col = chrom.colors)
is.interactive = FALSE
#is.interactive = TRUE
n.cores = detectCores() - 1
#n.cores = 19

data(CCcolors)
chrom.colors <- colors.from.values(1:num.states, use.pheatmap.colors = TRUE)
```


Load data.

```{r load_do_data}
transcript.info <- readRDS(here("Data", "RNASeq", "RNASeq_gene_info.RData"))
transcript.haplotypes <- readRDS(here("Data", "DOQTL", "transcript.haplotypes.RDS"))

#rankZ normalized expression from Svenson_DO850_for_eQTL_viewer_v9.RData
#generated by 2.0_chromaprobs_setup.Rmd
expr.data <- readRDS(here("Data", "DOQTL", "DO_Expression.RDS")) 
expr <- expr.data$expr
covar <- expr.data$covar
#pull out diet as an interactive covariate
int.covar <- covar[,2,drop=FALSE]
chrom.state.file <- file.path(results.dir, "Expanded_Chromatin.RDS") #generated by 2.0_chromaprobs_setup.Rmd
chrom.states <- readRDS(chrom.state.file)
chrom.mats <- readRDS(file.path(results.dir, paste0("Chromatin_States_", num.states, "_full_gene_1000.RData")))

common.transcripts <- intersect(colnames(expr), names(chrom.states)) #transcripts that are shared between chromatin and DO expression data
hf.locale <- which(covar[,"diethf"] == 1)
chow.locale <- which(covar[,"diethf"] == 0)
```

Load the strain key. This helps us keep track of the different ways strains are named.

```{r strain.key}
strain.key <- read.table(here("Data", "support_files", "strain.color.table.txt"), 
sep = "\t", stringsAsFactors = FALSE, comment.char = "*")
```

For transcripts we perform the following steps. 

1. Impute local chromatin state in DO from inbred chromatin state matrices.
2. For each chromatin state, calculate the variance explained
    at each position in the gene. Retain the maximum coefficient
    for each state across all positions.
3. For each chromatin state, calculate beta coefficient each position 
    in the gene. Retain all coefficients to align with the inbred data.
4. For haplotypes, calculated variance explained for each individual
    state (not the full haplotype).
    This makes sure we have one degree of freedom across all our 
    models so we can directly compare them. This also allows a 
    chromatin state to potentially explain more variance in gene
    expression than an individual haplotype. If both A/J and B6 have
    a repressor in a given position, and that causes reduced expression,
    the repressor (chromatin state) will explain more variance in 
    gene expression than either individual haplotype.
    Retain the maximum variance explained for each state across all positions
5. For haplotypes calculate the beta coefficient for each haplotype.

We do not calculate LOD scores here. We used to, but we are not 
using them, and we will save time by not calculating them.

```{r scan_chQTL_and_eQTL}
chrom.coef.file <- file.path(results.dir, "chQTL.state.coef.RDS")
chrom.r2.file <- file.path(results.dir, "chQTL.state.R2.RDS")

geno.coef.file <- file.path(results.dir, "eQTL.hap.coef.RDS")
geno.r2.file <- file.path(results.dir, "eQTL.hap.R2.RDS")

if(delete.previous){
  unlink(chrom.coef.file)
  unlink(chrom.r2.file)
  unlink(geno.coef.file)
  unlink(geno.r2.file)
}

save.every = 100

if(file.exists(chrom.coef.file)){
  chrom.coef <- readRDS(chrom.coef.file)
  chrom.r2 <- readRDS(chrom.r2.file)
  geno.coef <- readRDS(geno.coef.file)
  geno.r2 <- readRDS(geno.r2.file)

  #figure out where we left off.
  not.na <- which(!is.na(geno.r2[,1]))  
  left.off <- max(not.na)
  start.at <- left.off + 1
}else{
    start.at <- 1
    #if we are at the beginning, intialize all the objects for holding
    #results. 
    geno.coef <- vector(mode = "list", length = length(common.transcripts))
    names(geno.coef) <- common.transcripts

    #make space for the full set of chromaprob coefficients for
    #each transcript.
    chrom.coef <- vector(mode = "list", length = length(common.transcripts))
    names(chrom.coef) <- common.transcripts
  
    #keep variance explained for each haplotype in each transcript
    geno.r2 <- matrix(NA, ncol = 8, nrow = length(common.transcripts))
    rownames(geno.r2) <- common.transcripts 
    colnames(geno.r2) <- LETTERS[1:8]

    chrom.r2 <- matrix(NA, ncol =  num.states, nrow = length(common.transcripts))
    rownames(chrom.r2) <- common.transcripts
    colnames(chrom.r2) <- paste0("State", 1:num.states)
}

```


```{r stat_fun}

#Scans effects of each state individually
scan_chrom_transcript_by_state <- function(gene.id, 
  geno.type = c("chromatin", "haplotype"), perm.order = NULL){

  geno.type = geno.type[1]

  gene.name <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == gene.id),"external_gene_name"][1]
  if(is.na(gene.name)){return(NA)}

  expr.locale <- which(colnames(expr) == gene.id)
  chrom.locale <- which(names(chrom.mats) == gene.id)

  if(length(expr.locale) == 0 || length(chrom.locale) == 0){
    return(NA)
  }

    geno <- get_one_geno(gene.name, transcript.info, transcript.haplotypes, 
        chrom.states, strain.key, geno_type = geno.type, perm.order = perm.order)

    if(is.na(geno)){return(NA)}

    #check for variation
    test.var <- round(apply(geno[[1]], 3, function(x) apply(x, 2, function(y) var(y))), 2)
    
    if(geno.type == "chromatin"){
      no.var <- length(which(apply(test.var, 1, function(x) length(unique(x))) > 1)) <= 1
    }else{
      no.var <- all(test.var[,1] == 0)
    }
    
    if(no.var){return(NA)}
   
    #calculate R2
    #adjust expression for covariates first, so we don't include 
    #the covariates in the variance explained
    adj.expr <- adjust(expr[,expr.locale,drop=FALSE], covar)

    all.models <- apply(geno[[1]], 3, function(x) apply(x, 2, function(y) lm(adj.expr~y)))
    all.r2 <- sapply(all.models, function(x) sapply(x, function(y) summary(y)$adj.r.squared))
    #r2.max <- apply(all.r2, 2, max) #maximum R2 by position
    r2.max <- apply(all.r2, 1, max) #maximum R2 by state

    all.coef <- sapply(all.models, function(x) sapply(x, function(y) coef(y)[2]))

    if(geno.type == "chromatin"){
      #pheatmap(all.r2, cluster_rows = FALSE, cluster_cols = FALSE)
      #pheatmap(all.coef, cluster_rows = FALSE, cluster_cols = FALSE)
      non.zero.idx <- which(all.coef != 0, arr.ind = TRUE)
      non.zero.val <- all.coef[which(all.coef != 0)]
      #Make a sparse matrix to save space. Don't add dimnames. 
      #these take up a lot of space, we can use dimnames from 
      #chrom.mats later.
      sparse.coef <- sparseMatrix(non.zero.idx[,1], non.zero.idx[,2], x = non.zero.val,
        dims = c(nrow(all.coef), ncol(all.coef))) 
    }else{
      sparse.coef <- all.coef
    }  
  results <- list("coef" = sparse.coef, "r2" = r2.max)
  return(results)
}

```

```{r run_remaining}
#new tests to constrain degrees of freedom
#tests each state individually

if(start.at < length(common.transcripts)){ #if we haven't scanned all the transcripts yet
  sink(file.path(results.dir, "progress.txt"))
  #for each remaining transcript
  for(i in start.at:length(common.transcripts)){
    print(i)

    if(is.interactive){report.progress(i, length(common.transcripts))}
    
    chrom.results <- scan_chrom_transcript_by_state(gene.id = common.transcripts[i], 
      geno.type = "chromatin")

    if(length(chrom.results) > 1){
      chrom.coef[[i]] <- chrom.results$coef
      chrom.r2[i,] <- chrom.results$r2
    }else{
      chrom.coef[[i]] <- NA
    }

    gene.results <- scan_chrom_transcript_by_state(gene.id = common.transcripts[i], 
      geno.type = "haplotype")

    if(length(gene.results) > 1){
      geno.coef[[i]] <- gene.results$coef
      geno.r2[i,] <- gene.results$r2
    }else{
      geno.coef[[i]] <- NA
    }
    if(is.interactive){
      ylim <- c(0, max(c(gene.results$r2, chrom.results$r2)))
      plot(chrom.results$r2, ylim = ylim)
      abline(h = gene.results$r2, col = CCcolors)
    }

    #save every once in a while
    if(i %% save.every == 0){
      #saveRDS(chrom.lod, chrom.lod.file)
      saveRDS(chrom.coef, chrom.coef.file)
      saveRDS(chrom.r2, chrom.r2.file)
      saveRDS(geno.coef, geno.coef.file)
      saveRDS(geno.r2, geno.r2.file)
    }
  }
  #also save at the end of everything.
  #saveRDS(chrom.lod, chrom.lod.file)
  saveRDS(chrom.coef, chrom.coef.file)
  saveRDS(chrom.r2, chrom.r2.file)
  saveRDS(geno.coef, geno.coef.file)
  saveRDS(geno.r2, geno.r2.file)
  sink()
}
```

## Assess variance explained

Compare the variance explained by individual chromatin states
to the variance explained by individual haplotypes.


The following boxplot shows the distribution of variance
explained by each state. 

```{r var_exp_state}
boxplot(chrom.r2, las = 2)
```

The following boxplot shows the variance explained
by each haplotype.

```{r var_exp_hap}
boxplot(geno.r2)
```

The plot below shows the variance explained by individual
haplotypes vs. the variance explained by individual chromatin
states.

There are many cases in which an individual chromatin state
explains more variance than an individual haplotype. This 
suggests that multiple haplotypes share a chromatin state
that is influencing gene expression.

There are also some cases in which an individual haplotype 
explains more variance than any individual chromatin state.


```{r var_exp}
max.chrom.r2 <- apply(chrom.r2, 1, function(x) if(!all(is.na(x))){max(x, na.rm = TRUE)}else{NA})
max.geno.r2 <- apply(geno.r2, 1, function(x) if(!all(is.na(x))){max(x, na.rm = TRUE)}else{NA})

plot(max.geno.r2, max.chrom.r2, xlab = "R2 Haplotype",
    ylab = "R2 Chromatin State")
abline(0,1)
```

```{r examples, eval = FALSE}
#example of haplotype explaining more than chromatin
test <- which(apply(cbind(max.geno.r2, max.chrom.r2), 1, function(x) x[1] > x[2]))

#example of chromatin explaining more than haplotype
test <- which(apply(cbind(max.geno.r2, max.chrom.r2), 1, function(x) x[1] > x[2]))

gene.id <- names(test)[3]
gene.name <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == gene.id)[1], "external_gene_name"]

plot.chrom.effects(gene.name, expr, covar, chrom.mats, 
    transcript.info, transcript.haplotypes, chrom.states, strain.key)

```

```{r select_nperm}
nperm = 1000
```

```{r perm_fun}
get_data_for_perm <- function(gene.id){

    info.locale <- which(transcript.info[,"ensembl_gene_id"] == gene.id)[1]
    gene.name <- transcript.info[info.locale,"external_gene_name"]
    if(is.na(gene.name)){return(NA)}

    expr.locale <- which(colnames(expr) == gene.id)
    chrom.locale <- which(names(chrom.mats) == gene.id)

    if(length(expr.locale) == 0 || length(chrom.locale) == 0){
        return(NA)
    }

    one.chrom <- chrom.states[[chrom.locale]]
    one.expr <- expr[,expr.locale,drop=FALSE]
    gene.idx <- which(names(transcript.haplotypes) == gene.id)
    haps <- transcript.haplotypes[[gene.idx]]
    gene.chr <- transcript.info[info.locale,"chromosome_name"]

    data.for.perm <- list("name" = gene.name, "chrom" = one.chrom, 
        "expr" = one.expr, "haps" = haps, "chr" = gene.chr)
    return(data.for.perm)
}

imp_chrom <- function(perm.data, perm.order){
 
  chrom.order <- match.order(colnames(perm.data$haps),
    rownames(perm.data$chrom), strain.key)

    ref.chroms <- perm.data$chrom
    if(!is.null(perm.order)){
        ref.chroms <- ref.chroms[perm.order,,]
        rownames(ref.chroms) <- colnames(perm.data$haps)
    }

    haps <- perm.data$haps
    chrom.array <- array(NA, dim = c(nrow(haps), ncol(ref.chroms), dim(ref.chroms)[3]))
    rownames(chrom.array) <- rownames(haps)
    colnames(chrom.array) <- paste0("State", colnames(ref.chroms))
    dimnames(chrom.array)[[3]] <- dimnames(ref.chroms)[[3]]
  
    for(p in 1:dim(ref.chroms)[3]){ #for each position
        chrom.mat <- ref.chroms[,,p]
        chrom.array[,,p] <- haps[,,1] %*% chrom.mat
        }

    #add attributes
    gene.chr <- perm.data$chr
    one.geno <- list(chrom.array)
    names(one.geno) <- gene.chr
    if(gene.chr == "X"){
      attr(one.geno, "is_x_chr") <- TRUE
    }else{
      attr(one.geno, "is_x_chr") <- FALSE
    }
    attr(one.geno, "crosstype") <- "do"
    attr(one.geno, "alleles") <- LETTERS[1:8]
    attr(one.geno, "alleleprobs") <- TRUE
    attr(one.geno, "class") <- c("calc_genoprob", "list")
 
    return(one.geno)
}


#This function and the perm data will be exported to the
#clusters
perm_one_transcript <- function(perm.data, p, 
  geno_type = c("chromatin", "genotype")){
  
  if(length(perm.data) == 1){return(NA)}
  
  perm.order <- order.mat[p,]

  imp.geno <- imp_chrom(perm.data, perm.order)

  if(is.na(imp.geno)){return(NA)}

  #check for variation
  test.var <- round(apply(imp.geno[[1]], 3, function(x) apply(x, 2, function(y) var(y))), 2)
  no.var <- length(which(apply(test.var, 1, function(x) length(unique(x))) > 1)) <= 1
    
  if(no.var){return(NA)}
       
  #calculate chromatin LOD scores
  chrom.lod.table <- scan1(imp.geno, perm.data$expr, addcovar = covar)
  colnames(chrom.lod.table) <- "Additive"

  #calculate chromatin state coefficients
  chrom.add.coef <- scan1coef(genoprobs = imp.geno, pheno = perm.data$expr, 
    addcovar = covar)
  chrom.coef.list <- list(chrom.add.coef[,1:num.states])
  names(chrom.coef.list) <- "Additive"

    #calculate chromatin R2
    #adjust expression for covariates first, so we don't include 
    #the covariates in the variance explained
    adj.expr <- adjust(perm.data$expr, covar)
    chrom.models.add <- apply(imp.geno[[1]], 3, function(x) lm(adj.expr~x))
    ch.add.r2 <- sapply(chrom.models.add, function(x) summary(x)$adj.r.squared)
    chrom.r2.results <- matrix(ch.add.r2, ncol = 1)
    colnames(chrom.r2.results) <- "Additive"

  results <- list("chrom.lod.table" = chrom.lod.table, 
    "chrom.coef.list" = chrom.coef.list, "chrom.r2.results" = chrom.r2.results)

  return(results)
}
```

```{r perm_files}
perm.lod.file <- file.path(results.dir, "Perm.LOD.RDS")
perm.r2.file <- file.path(results.dir, "Perm.R2.RDS")

if(file.exists(perm.lod.file)){
  perm.lod <- readRDS(perm.lod.file)
  perm.r2 <- readRDS(perm.r2.file)

  #figure out where we left off.
  not.na <- which(!is.na(perm.lod[,1]))  
  left.off <- max(not.na)
  start.at <- left.off + 1
}else{
  start.at <- 1
  #if we are at the beginning, intialize all the objects for holding
  #results. 
  perm.lod <- perm.r2 <- matrix(NA, nrow = length(common.transcripts), ncol = nperm)
  rownames(perm.lod) <- rownames(perm.r2) <- common.transcripts
}

```

```{r set_perm}
#select a set of permutations for which none of the chromatin
#states get assigned to their original haplotype.
#these are called derrangements
perm.mat <- derrangements(8)
#sample a random set of derraangements to use
#for all transcripts
perm.rows <- sample(1:nrow(perm.mat), nperm)
order.mat <- perm.mat[perm.rows,]

```

```{r set_cl, warning = FALSE, eval = FALSE}

if(start.at < length(common.transcripts)){
  #set up the clusters if we need to run perutations

  to.export <- c("scan1", "scan1coef", "covar", "perm_one_transcript",
    "num.states", "adjust", "order.mat", "imp_chrom", "match.order", "strain.key")

  #create and register multiple cores for parallele permutations
  cl <- makeCluster(n.cores)
  registerDoParallel(cl)
  #export everything we need to the cluster
  #this takes time upfront, but the parallelization
  #saves a huge amount of time overall
  clusterExport(cl, to.export) 
}
```


```{r do_perm, eval = FALSE}

lod.thresh = 6
to.perm <- which(geno.lod[,"Additive"] > lod.thresh)
do.perm <- rep(FALSE, length(common.transcripts))
do.perm[to.perm] <- TRUE

if(start.at < max(to.perm)){
  sink(file.path(results.dir, "progress.txt"))

  for(tr in start.at:length(common.transcripts)){
  #for(tr in 1:10){
    cat(paste0(tr, ":\n"))

    if(!do.perm[tr]){cat(" LOD score < 6\n");next()}

    #gene.name = "Pkd2"
    #gene.id <- transcript.info[which(transcript.info[,"external_gene_name"] == gene.name)[1],"ensembl_gene_id"]
    #tr = which(common.transcripts == gene.id)

    gene.id <- common.transcripts[tr]
    #gene.name <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == gene.id)[1],"external_gene_name"]

    perm.data <- get_data_for_perm(gene.id)

    if(is.na(perm.data)){cat(" No data returned for permutations\n");next()}
    if(dim(perm.data$chrom)[[3]] > 2000){cat(" Chromatin matrix too large\n"); next()}

    #send the new gene ID to the clusters
    clusterExport(cl, "perm.data")

    #do the permutations in parallel
    perm.chrom.results <- parLapply(cl, 1:nperm, 
        function(p) perm_one_transcript(perm.data, 
        p = p))

      #check for NAs
      if(!all(sapply(perm.chrom.results, length) > 1)){cat(" No data returned from permutations\n"); next()}

      perm.chrom.coef <- lapply(perm.chrom.results, function(x) x$chrom.coef.list)
      perm.chrom.lod <- lapply(perm.chrom.results, function(x) x$chrom.lod.table)
      perm.chrom.r2 <- lapply(perm.chrom.results, function(x) x$chrom.r2.results)

      #keep the maximum r2 and LOD values from each permutation.
      #also keep the permuted coefficients for each state
      perm.lod[tr,] <- t(sapply(perm.chrom.lod, function(x) max(x[,"Additive"])))
      perm.r2[tr,] <- t(sapply(perm.chrom.r2, function(x) max(x[,"Additive"])))

    if(tr %% save.every == 0){
      saveRDS(perm.lod, perm.lod.file)
      saveRDS(perm.r2, perm.r2.file)
    }
    cat(" Finished permutations\n")
  } #end looping through transcripts

  #close the clusters at the end and save the final objects
  stopCluster(cl)

  saveRDS(perm.lod, perm.lod.file)
  saveRDS(perm.r2, perm.r2.file)
  sink()
}
```

## Assess permutations

To assess the permutations, we look at the distribution
of empirical p values. If this distribution is uniform,
then it is the imputation itself that is explaining the
LOD scores we see. If the distribution is skewed toward
0, then the chromatin states are adding something beyond
the imputation itself.


```{r alpha}
alpha = 1/nperm
```

The plots below show the distributions of p values for both 
the R2 statistic and the LOD score statistic. Both are
skewed toward 0. The dot plot shows that the p values for 
these two statistics are highly correlated, but not identical.

```{r perm_plots, fig.width = 8, fig.height = 8}
max.chrom.r2 <- sapply(chrom.r2, function(x) if(length(x) > 1){max(x[,"Additive"], na.rm = TRUE)}else{NA})
max.chrom.lod <- sapply(chrom.lod, function(x) if(length(x) > 1){max(x[,"Additive"], na.rm = TRUE)}else{NA})
lod.p <- sapply(1:length(chrom.lod), 
  function(x) if(!all(is.na(perm.lod[[x]]))){emp.p(max.chrom.lod[x], perm.lod[x,])}else{NA})
r2.p <- sapply(1:length(chrom.lod), 
  function(x) if(!all(is.na(perm.r2[[x]]))){emp.p(max.chrom.r2[x], perm.r2[x,])}else{NA})
results.table <- cbind(max.chrom.lod, lod.p, max.chrom.r2, r2.p)

saveRDS(results.table, file.path(results.dir, "Perm_Results.RDS"))

par(mfrow = c(2,2))
hist(lod.p, breaks = 100, main = "LOD score p values",
  xlab = "p value")
hist(r2.p, breaks = 100, main = "R2 p values",
  xlab = "p value")
plot(-log10(lod.p+1e-3), -log10(r2.p+1e-3), main = "LOD vs. R2",
  xlab = "-log10(LOD p values)", ylab = "-log10(R2 p values")
```


The following plots show each test statistic vs. its
p values. In general higher test statistics have lower
p values, but this is not strictly true. 


```{r, fig.width = 8, fig.height = 4}
par(mfrow = c(1,2))
plot(max.chrom.lod, -log10(lod.p+1e-3), xlab = "LOD", ylab = "-log10(p)", 
  main = "LOD vs. LOD -log10(p)")

plot(max.chrom.r2, -log10(r2.p+1e-3), xlab = "Variance Explained", 
  ylab = "-log10(p)", main = "R2 vs. R2-log10(p)")

#sig.col <- colors.from.values(-log10(lod.p+1e-3), grad.dir = "high",
#  col.scale = "blue", light.dark = "f")
#plot.order <- rev(order(sig.col))
#plot(max.chrom.lod[plot.order], max.chrom.r2[plot.order], 
#  ylab = "Variance Explained", xlab = "LOD",
#  col = sig.col[plot.order], pch = 16, 
#  main = "LOD vs. R2\nDarker ",
# )
```


```{r example, eval = FALSE}
sig.chrom <- which(lod.p <= alpha)
library(gprofiler2)
enrich <- gost(common.transcripts[sig.chrom], organism = "mmusculus")
plot.enrichment(enrich, max.term.size = 2000, num.terms = 30)

example.gene <- sig.chrom[6]
gene.name <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == rownames(geno.lod)[example.gene])[1], "external_gene_name"]
hap.lod <- geno.lod[example.gene,"Additive"]
obs.lod <- max(chrom.lod[[example.gene]][,"Additive"])
null.lod <- perm.lod[example.gene,]
xmin <- min(c(null.lod, obs.lod, hap.lod))
xmax <- max(c(null.lod, obs.lod, hap.lod))
hist(perm.lod[example.gene,], breaks = 50, xlim = c(xmin, xmax), main = gene.name,
  xlab = "LOD")
abline(v = c(obs.lod, hap.lod), col = c("red", "blue"))
legend("topleft", legend = c("observed", "haplotype"), col = c("red", "blue"), lty = 1)

```

