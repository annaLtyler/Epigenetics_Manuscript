---
title: "Compare ChromHMM Models"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---


The purpose of this workflow is to compare different numbers of states specified 
for ChromHMM. We do this in several ways. First, we look for the maximum correlation
between chromatin state and gene expression. Second, we look for state overlaps 
with genomic features.

This workflow can be run after 1.3_Chromatin_States_and_Expression.Rmd has been run for 
multiple state numbers. It uses the "Prop\_Expression\_Cor" files to find the maximum 
and minimum associations between proportion of each state and the expression of each 
transcript. It plots these maxima and minima across the states analyzed.

## Source code

```{r source_code}
library("here")
library("pheatmap")
all.code.dir <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.code.dir)){
	all.fun <- list.files(all.code.dir[i], full.names = TRUE, pattern = ".R")
	for(j in 1:length(all.fun)){source(all.fun[j])}
}
is.interactive = FALSE
#is.interactive = TRUE
```


## Collect results
Collect gene expression as well as the proportion of each gene assigned to 
each state for all runs of ChromHMM


```{r collect_results}
state.num <- get.files(here("Results", "ChromHMM"), want = "states", full.names = TRUE)
state.names <- basename(state.num)
state.as.num <- as.numeric(sapply(strsplit(state.names, "_"), function(x) x[1]))
state_order <- order(state.as.num)
all.prop <- vector(mode = "list", length = length(state.num))
names(all.prop) <- basename(state.num)[state_order]
for(i in 1:length(state.num)){
	prop.file <- list.files(path = state.num[state_order[i]], pattern = "Prop_full_gene_1000.RData", full.names = TRUE)
	if(length(prop.file) > 0){all.prop[[i]] <- readRDS(prop.file)}
}

param <- read.delim(here("Data", "support_files", "param.txt"), header = FALSE, 
    stringsAsFactors = FALSE, row.names = 1)
ordered.marks <- strsplit(param["ordered_marks",], ",")[[1]]
```

```{r collect_expression}
gene.info <- readRDS(here("Data", "RNASeq", "RNASeq_gene_info.RData"))
expr <- readRDS(here("Data", "RNASeq", "Strain_Mean_C_Expression.RData"))
scaled.expr <- readRDS(here("Data", "RNASeq", "Strain_Scaled_C_Expression.RData"))
key.file <- here("Data", "support_files", "strain.color.table.txt")
col.table <- as.matrix(read.table(key.file, sep = "\t", comment.char = "%", 
stringsAsFactors = FALSE))
```

## Model Fit {.tabset .tabset-fade .tabset-pills}

Fit a linear model that explains gene expression within strain with propotion
chromain state.

For each run of chromHMM we end up with a fitted model for each state and for
each strain. We parse these together to find the best overall number of states.

```{r model_fit}
expr.mat <- t(sapply(expr, function(x) if(length(x) > 1){x}else{rep(NA, 9)}))
rownames(expr.mat) <- names(expr)
#identical(names(expr), names(all.prop[[1]]))

strain.order <- order.strains(names(expr[[1]]), colnames(all.prop[[1]][[1]]), col.table)
#colnames(all.prop[[1]][[1]])[strain.order]
ordered.states <- state.as.num[state_order]

model.fits <- vector(mode = "list", length = length(ordered.states))
names(model.fits) <- ordered.states

for(i in 1:length(ordered.states)){
    states <- 1:ordered.states[i]
    state.fits <- vector(mode = "list", length = length(states))
    names(state.fits) <- states
    for(state in states){
        all.gene.state <- t(sapply(all.prop[[i]], function(x) if(length(x) > 1){x[state,strain.order]}else{rep(NA, 9)}))
        state.fits[[state]] <- sapply(1:ncol(all.gene.state), function(x)
            plot.with.model(rankZ(all.gene.state[,x]), rankZ(expr.mat[,x]), confidence = 0.95, 
            plot.results = FALSE))
    }
    model.fits[[i]] <- state.fits
}

saveRDS(model.fits, here("Results", "ChromHMM", "within.strain.models.RDS"))
```

Plot the fit for each state in each model with the mean 95% confidence intervals across 
all strains. The fits are very similar across the strains, so we average the 
fits across strains.

```{r parse_fit, results = "asis", fig.width = 7, fig.height = 5}
avg_effect <- lapply(model.fits, function(x) sapply(x, rowMeans))
min.fit <- -0.6
max.fit <- 0.6

for(i in 1:length(ordered.states)){
    cat("###", ordered.states[i], "state model\n")
    state_avg <- avg_effect[[i]]
    fit.range <- max.fit - min.fit
    state.col <- darken(colors.from.values(1:ordered.states[i], use.pheatmap.colors = TRUE), 1.1)
    state.y <- ordered.states[i]:1

    if(is.interactive){quartz(width = 5, height = 4.2)}
    plot.new()
    plot.window(ylim = c(0.5, (ordered.states[i]+0.5)), xlim = c(min.fit, max.fit))
    abline(v = seq(min.fit, max.fit, 0.2), col = "gray80")
    abline(h = state.y, col = "gray80")
    #points(y = state.y, x = state_avg[3,], col = state.col, cex = 1.5, pch = 16) #fit
    segments(y0 = state.y, x0 = state_avg[4,], x1 = state_avg[5,], 
        col = state.col, lwd = 4) #fit bar
    segments(y0 = state.y-0.2, x0 = state_avg[4,], y1 = state.y+0.2, 
        col = state.col, lwd = 4) #lower bound
    segments(y0 = state.y-0.2, x0 = state_avg[5,], y1 = state.y+0.2, 
        col = state.col, lwd = 4) #upper bound
    axis(1)
    abline(v = 0)
    par(xpd = TRUE)
    text(y = state.y, x = (min.fit-(fit.range*0.05)), labels = 1:ordered.states[i])
    par(xpd = FALSE)
    cat("\n\n")
}
```

## All state effects together

Show all states on a single plot.

```{r single_plot}
all.min <- min(sapply(avg_effect, function(x) min(x[4,])))
all.max <- max(sapply(avg_effect, function(x) max(x[5,])))
all.range <- all.max - all.min

plot.new()
plot.window(xlim = c(0, length(avg_effect)+1), ylim = c(all.min, all.max))
for(i in 1:length(avg_effect)){
    effect.col <- colors.from.values(avg_effect[[i]][3,], use.pheatmap.colors = TRUE, 
        global.color.scale = TRUE, global.min = all.min, global.max = all.max)
    x.coord <- jitter(rep(i, ncol(avg_effect[[i]])))
    points(x = x.coord, y = avg_effect[[i]][3,], pch = 16,
        col = effect.col)
    segments(x0 = x.coord, y0 = avg_effect[[i]][5,], y1 = avg_effect[[i]][4,], col = effect.col, lwd = 4)
}
abline(h = 0)
axis(2)
par(xpd = TRUE)
text(x = 1:length(ordered.states), y = (all.min - (all.range*0.05)), labels = ordered.states)
par(xpd = FALSE)


```

## Across-strain effects {.tabset .tabset-fade .tabset-pills}

Now we do the same thing for state effects across strains.

```{r across_strain}
scaled.expr.mat <- t(sapply(scaled.expr, function(x) if(length(x) > 1){x[,1]}else{rep(NA, 9)}))
rownames(scaled.expr.mat) <- names(scaled.expr)
#identical(rownames(scaled.expr.mat), names(all.prop[[1]]))
model.across <- vector(mode = "list", length = length(ordered.states))
names(model.across) <- ordered.states

for(i in 1:length(ordered.states)){
    states <- 1:ordered.states[i]
    state.fits <- matrix(NA, nrow = ordered.states[i], ncol = 5)
    rownames(state.fits) <- 1:ordered.states[i]
    colnames(state.fits) <- c("r", "p.value", "slope.fit", "slope.lwr", "slope.upr")
    for(state in states){
        all.gene.state <- t(sapply(all.prop[[i]], function(x) if(length(x) > 1){x[state,strain.order]}else{rep(NA, 9)}))
        scaled.gene.state <- t(apply(all.gene.state, 1, scale))
        state.fits[state,] <- plot.with.model(rankZ(as.vector(scaled.gene.state)), 
            rankZ(as.vector(scaled.expr.mat)), confidence = 0.95, plot.results = FALSE)
    }
    model.across[[i]] <- state.fits
}
saveRDS(model.across, here("Results", "ChromHMM", "across.strain.models.RDS"))
```

Plot these together.

```{r across_strain_plots, results = "asis", fig.height = 5, fig.width = 6}
min.fit <- -0.2
max.fit <- 0.3

for(i in 1:length(ordered.states)){
    cat("###", ordered.states[i], "state model\n")
    state_fit <- model.across[[i]]
    fit.range <- max.fit - min.fit
    state.col <- darken(colors.from.values(1:ordered.states[i], use.pheatmap.colors = TRUE), 1.1)
    state.y <- ordered.states[i]:1
    if(is.interactive){quartz(width = 5, height = 4.2)}
    plot.new()
    plot.window(ylim = c(0.5, (ordered.states[i]+0.5)), xlim = c(min.fit, max.fit))
    abline(v = seq(min.fit, max.fit, 0.1), col = "gray80")
    abline(h = state.y, col = "gray80")
    abline(v = 0)
    #points(y = state.y, x = state_fit[,3], col = state.col, cex = 1.5, pch = 16) #fit
    segments(y0 = state.y, x0 = state_fit[,4], x1 = state_fit[,5], 
        col = state.col, lwd = 4) #fit bar
    segments(y0 = state.y-0.2, x0 = state_fit[,4], y1 = state.y+0.2, 
        col = state.col, lwd = 4) #lower bound
    segments(y0 = state.y-0.2, x0 = state_fit[,5], y1 = state.y+0.2, 
        col = state.col, lwd = 4) #upper bound
    axis(1)
    par(xpd = TRUE)
    text(y = state.y, x = (min.fit-(fit.range*0.05)), labels = 1:ordered.states[i])
    par(xpd = FALSE)
    cat("\n\n")
}
```

## All across-strain effects together

Plot across-strain effects all on one plot.

```{r single_plot_across}
all.min <- min(sapply(model.across, function(x) min(x[,4])))
all.max <- max(sapply(model.across, function(x) max(x[,5])))
all.range <- all.max - all.min

plot.new()
plot.window(xlim = c(0, length(model.across)+1), ylim = c(all.min, all.max))
for(i in 1:length(model.across)){
    effect.col <- colors.from.values(model.across[[i]][,3], use.pheatmap.colors = TRUE, 
        global.color.scale = TRUE, global.min = all.min, global.max = all.max)
    x.coord <- jitter(rep(i, nrow(model.across[[i]])))
    points(x = x.coord, y = model.across[[i]][,3], pch = 16,
        col = effect.col)
    segments(x0 = x.coord, y0 = model.across[[i]][,5], y1 = model.across[[i]][,4], col = effect.col, lwd = 4)
}
abline(h = 0)
axis(2)
par(xpd = TRUE)
text(x = 1:length(ordered.states), y = (all.min - (all.range*0.05)), labels = ordered.states)
par(xpd = FALSE)
```


## Emissions and State Effects {.tabset .tabset-fade .tabset-pills}

Which states across the different models have high and low effects on
expression?

```{r emissions, results = "asis"}
emissions.dir <- list.files(here("Data", "ChromHMM"), full.names = TRUE)
emissions.files <- lapply(emissions.dir, 
function(x) get.files(x, want = c("emissions", ".txt"), full.names = TRUE))[state_order]
emission.mats <- lapply(emissions.files, function(x) read.table(x[1], 
row.names = 1, header = TRUE, sep = "\t"))
all.state.effect <- vector(mode = "list", length = length(ordered.states))
names(all.state.effect) <- ordered.states
ordered.marks <- colnames(emission.mats[[1]])

for(i in 1:length(emission.mats)){
    cat("###", ordered.states[i], "\n")
    state.effects <- colMeans(sapply(model.fits[[i]], function(x) x[3,]))
    effect.order <- order(state.effects, decreasing = FALSE)
    mark.order <- match(ordered.marks, colnames(emission.mats[[i]]))
    effect.df <- data.frame(state.effects)
    ordered.emissions <- emission.mats[[i]][effect.order,mark.order]
    rownames(ordered.emissions) <- effect.order
    pheatmap(ordered.emissions, annotation_row = effect.df, 
    cluster_rows = FALSE, cluster_cols = FALSE)
    all.state.effect[[i]] <- cbind(emission.mats[[i]][,mark.order], effect.df)
    cat("\n\n")
}
```

## Emissions and State Effects For All Models

```{r all_aligned}
state.mat <- t(sapply(0:15, function(x) number2binary(x, noBits = 4)))
colnames(state.mat) <- ordered.marks

fill.probs <- function(bin.mat, emissions.mat, threshold = 0.3){
    #order the emissions mat to match the binary mat
    col.order <- match(colnames(bin.mat), colnames(emissions.mat))
    emissions.mat <- emissions.mat[,col.order]

    #binarize the emissions mat
    binarized.emissions <- emissions.mat
    binarized.emissions[which(emissions.mat >= threshold)] <- 1
    binarized.emissions[which(emissions.mat < threshold)] <- 0

    matched.states <- apply(binarized.emissions, 1, function(x) apply(bin.mat, 1, function(y) all(x == y)))
    state.idx <- apply(matched.states, 2, function(x) which(x))

    aligned.emissions <- matrix(NA, nrow = nrow(bin.mat), ncol = ncol(bin.mat))
    colnames(aligned.emissions) <- colnames(bin.mat)
    rownames(aligned.emissions) <- 1:nrow(aligned.emissions)

    aligned.emissions[state.idx,] <- emissions.mat[1:nrow(emissions.mat),]  
    return(aligned.emissions)

} 

all.aligned.emissions <- lapply(all.state.effect, 
    function(x) fill.probs(state.mat, as.matrix(x[,1:4]), 0.3))


state.comparison <- lapply(1:nrow(state.mat), function(x) sapply(all.aligned.emissions, function(y) y[x,]))

all.together <- Reduce("cbind", lapply(state.comparison, function(x) cbind(t(x), rep(NA, ncol(x)))))

layout.mat <- matrix(c(1,2), nrow = 2)
ref.states <- matrix(unlist(lapply(1:nrow(state.mat), function(x) c(state.mat[x,], NA))), nrow = 1)

png(here("Documents", "3.Manuscript", "Figures", "Supplemental", 
    "Supp_Fig3_all_state_emissions.png"), width = 15, height = 8, units = "in", 
    res = 300)
layout(layout.mat, heights = c(1, 0.2))

par(mar = c(0,2,5,1))
imageWithText(all.together, show.text = FALSE, use.pheatmap.colors = TRUE,
    col.text.rotation = 90, row.text.shift = -88, col.text.shift = -13.8, 
    row.text.cex = 1.5, row.text.adj = 0, col.text.adj = 0)
text(y = 13:1, x = -0.5, rownames(all.together), cex = 1.5, adj = 1)
segments(x0 = rep(0, 13), x1 = rep(ncol(all.together), 13), y0 = 13:1-0.5, col = "white", 
    lwd = 2)
draw.rectangle(min.x = 0.5, min.y = 2.5, max.x = ncol(all.together)+0.5, max.y = 3.5, 
    lwd = 3)

par(mar = c(5,2,0.5,1))
imageWithText(ref.states, show.text = FALSE, use.pheatmap.colors = TRUE)
par(xpd = NA)
text(x = -1, y = 1, "Ref.", srt = 0, adj = 0.5, cex = 1.5)
text(x = 1:ncol(all.together), y = 0.4, colnames(all.together), srt = 90, adj = 1)
par(xpd = TRUE)

dev.off()


```

```{r all_states_all_models, fig.height = 16, fig.width = 5.5}

all.effect.mat <- Reduce("rbind", all.state.effect)
all.state.names <- unlist(lapply(1:length(all.state.effect), 
    function(x) paste0(ordered.states[x], "_states_", rownames(all.state.effect[[x]]))))
rownames(all.effect.mat) <- all.state.names
all.emissions <- all.effect.mat[,1:4]
all.effect <- data.frame(all.effect.mat[,5])
colnames(all.effect) <- "state.effect"
rownames(all.effect) <- all.state.names
effect.order <- order(all.effect[,1], decreasing = TRUE)
#pdf("~/Desktop/all.states.pdf", height = 16, width = 4)
#pheatmap(all.emissions[effect.order,], cluster_rows = FALSE)
#pheatmap(all.emissions[effect.order,], annotation_row = all.effect, cluster_rows = FALSE)

layout.mat <- matrix(c(1,1,1,2,2,2,3,0,0), nrow = 3)
layout(layout.mat, widths = c(1, 0.1, 0.1))
par(mar = c(2,6,4,1))
imageWithText(as.matrix(all.emissions[effect.order,]), use.pheatmap.colors = TRUE, show.text = FALSE,
row.text.shift = 0.25, main = "Histone Mark Representation", main.cex = 1.5, main.shift = 0.05,
col.text.shift = -10, col.text.rotation = 0, col.text.adj = 0.5, col.text.cex = 1.5)
test.mat <- cbind(as.matrix(all.effect[effect.order,,drop=FALSE]), as.matrix(all.effect[effect.order,,drop=FALSE]))
par(mar = c(2,0.5,4,2))
imageWithText(test.mat, use.pheatmap.colors = TRUE, show.text = FALSE, row.names = NULL, col.names = NULL,
main = "Effect", main.shift = 0.05, main.cex = 1.5)
par(mar = c(2,2,6,0))
imageWithTextColorbar(test.mat, use.pheatmap.colors = TRUE, cex = 1.5, axis.line = -1.5)

#dev.off()
```

## Genomic Overlaps {.tabset .tabset-fade .tabset-pills}

We next look at each set of states and how the state positions in the B6 animals
overlap with B6 genomic coordinates. We used the genomic coordinate files 
included in ChromHMM, which includes coordinates for exons, TSS, TES, genes,
and CpG islands. We downloaded additional files from the UCSC genome
browser. To do that we went to [http://genome.ucsc.edu/cgi-bin/hgTables]
and downloaded a few bed files by hand for different tracks. 

We can use these enrichments to annotate the states we identified in ChromHMM.

```{r enrich, results = "asis"}
enrichment.files <- list.files(here("Results", "Enrichments"), 
pattern = ".txt", full.names = TRUE)[state_order]

for(i in 1:length(enrichment.files)){
    cat("###", state.names[state_order[i]], "\n")
    if(is.interactive){quartz(width = 8, height = 4)}
    enrichment.map <- t(as.matrix(read.delim(enrichment.files[i], row.names = 1))[1:(i+3),])
    pheatmap(enrichment.map, cluster_cols = FALSE, main = "enrichment")

    pheatmap(log10(enrichment.map), cluster_cols = FALSE, main = "log10 enrichment")
    #pheatmap(log10(sqrt(enrichment.map)), cluster_cols = FALSE)

    scaled.cols <- apply(enrichment.map, 2, scale)
    rownames(scaled.cols) <- rownames(enrichment.map)
    pheatmap(scaled.cols, cluster_cols = FALSE, main = "columns scaled")

    scaled.rows <- t(apply(enrichment.map, 1, scale))
    colnames(scaled.rows) <- colnames(enrichment.map)    
    pheatmap(scaled.rows, cluster_cols = FALSE, main = "rows scaled")
    cat("\n\n")
}
```

```{r enrich_fig, eval = FALSE}
ordered.features <- c("Genome..", "CpGIsland.mm10.bed.gz", "RefSeqTSS.mm10.bed.gz", 
    "promoters.bed.gz", "RefSeqTSS2kb.mm10.bed.gz", "RefSeqExon.mm10.bed.gz", 
    "Encode_cCRE.bed.gz","TFbs.bed.gz", "enhancers.bed.gz", "RefSeqGene.mm10.bed.gz", 
    "RefSeqTES.mm10.bed.gz", "CTCF.bed.gz")

pdf(here("Documents", "3.Manuscript", "Figures", "enrichment.pdf"), width = 5, height = 3.5)
    for(i in 1:length(enrichment.files)){
        enrichment.map <- t(as.matrix(read.delim(enrichment.files[i], row.names = 1))[1:(i+3),])
        feature.order <- match(ordered.features, rownames(enrichment.map))
        ordered.map <- enrichment.map[feature.order,]
        scaled.map <- t(apply(ordered.map, 1, scale)) #scale rows
        colnames(scaled.map) <- colnames(ordered.map)
        pheatmap(scaled.map, cluster_cols = FALSE, cluster_rows = FALSE)
    }
dev.off()
```

We have selected the 9-state model for this analysis, so I will limit my 
discussion to that state here. 

State 7, which has the highest positive correlation with expression localizes
primarily to promoters, and transcription start sites (TSS), as well as to exons. 

State 5, which is also positively correlated with expression localizes to
enhancers.

State 3, which is negatively correlated with expression has similar
localization to state 7, but is primarily enriched at transcription 
factor binding sites. It is also enriched at promoters.

State 1 is the absence of all measured marks, and is negatively correlated
with expression. It is primarily associated with intergenic regions. 

State 2 is also negatively correlated with expression. It is the presence
of just H3K27me3. It does not strongly localize to any of the features
represented here, but may be slightly more present in introns or up/downstream
regulatory regions.

## Conclusions

We used the data presented here to select the 9-state model for further analysis.

