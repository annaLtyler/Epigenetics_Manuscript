---
title: "Map chromatin to genotype"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---


The purpose of this workflow is to impute chromatin states onto the DO mice
for each transcript using their genotypes at the marker nearest the TSS
of the transcript.

We then scan these chromatin probabilities in qtl2 to infer the effects of 
chromatin state on each transcript.

The basic pipeline for mapping chromatin to genotype is as follows: 

1. For each transcript identify the DO haplotypes at the marker nearest the TSS.
2. Use the haplotypes to calculate the chromatin states for each DO individual.
3. Calculate chromatin effects on transcript abundance using qtl2.

  
```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
num.states = 8
needed.packages <- c("here", "qtl2")
for(i in 1:length(needed.packages)){library(needed.packages[i], character.only = TRUE)}
#barplot(1:length(chrom.colors), col = chrom.colors)
is.interactive = FALSE
#is.interactive = TRUE
```

```{r source_code}
all.code.dir <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.code.dir)){
	all.fun <- list.files(all.code.dir[i], full.names = TRUE)
	for(j in 1:length(all.fun)){source(all.fun[j])}
}
data(CCcolors)
chrom.colors <- colors.from.values(1:8, use.pheatmap.colors = TRUE)
```


Load data.

```{r load_do_data}
transcript.info <- readRDS(here("Data", "RNASeq", "RNASeq_gene_info.RData"))
transcript.haplotypes <- readRDS(here("Data", "DOQTL", "transcript.haplotypes.RDS"))
expr.data <- readRDS(here("Data", "DOQTL", "DO_Expression.RDS")) #pulled from dataset.expr.petr by 2.0_chromaprobs_setup.Rmd
expr <- expr.data$expr
covar <- expr.data$covar
chrom.state.file <- here("Data", "chQTL", "Expanded_Chromatin.RDS") #generated by 2.0_chromaprobs_setup.Rmd
chrom.states <- readRDS(chrom.state.file)
chrom.mats <- readRDS(here("Results", "ChromHMM", "008_states_C", "Chromatin_States_8_full_gene_1000.RData"))
common.transcripts <- intersect(colnames(expr), names(chrom.states)) #transcripts that are shared between chromatin and DO expression data
```

Load the strain key. This helps us keep track of the different ways strains are named.

```{r strain.key}
strain.key <- read.table(here("Data", "support_files", "strain.color.table.txt"), 
sep = "\t", stringsAsFactors = FALSE, comment.char = "*")
```

For transcript we perform the following steps. To reduce memory
requirements, we do all steps for each transcript and keep only the
LOD score and coefficient scores for each transcript.

1. Impute local chromatin state in DO from inbred chromatin state matrices.

2. Use qtl2 to calculate LOD scores and state coefficients for all states
and transcripts.


```{r calc_chrom}
#this function imputes chromatin states in the DO from the 
#inbred states for one transcript given by the index.
#The transcript.haplotypes and chrom.states objects are 
#in the same order.

chrom.order <- match.order(colnames(transcript.haplotypes[[1]]), 
rownames(chrom.states[[1]]), strain.key)

#colnames(transcript.haplotypes[[1]])
#rownames(chrom.states[[1]])[chrom.order]

calc.chrom <- function(gene.id){
  gene.idx <- which(names(transcript.haplotypes) == gene.id)
  haps <- transcript.haplotypes[[gene.idx]]
  if(length(haps) == 1){return(NA)}
  ref.chroms <- chrom.states[[gene.idx]][chrom.order,,]

  chrom.array <- array(NA, dim = c(nrow(haps), ncol(haps), dim(ref.chroms)[3]))
  rownames(chrom.array) <- rownames(haps)
  colnames(chrom.array) <- paste0("State", colnames(ref.chroms))
  dimnames(chrom.array)[[3]] <- dimnames(ref.chroms)[[3]]
  
  for(p in 1:dim(ref.chroms)[3]){ #for each position
    chrom.mat <- ref.chroms[,,p]

    for(i in 1:dim(chrom.array)[1]){ #for each individual
      ind.hap <- haps[i,,1]
      #barplot(ind.hap)
      mult.mat <- apply(chrom.mat, 2, function(x) x*ind.hap)
      #pheatmap(mult.mat, cluster_rows = FALSE, cluster_cols = FALSE)
      ind.state <- colSums(mult.mat)
      #barplot(ind.state)
      #print(signif(ind.state, 2))
      chrom.array[i,,p] <- ind.state
    }
  }
  
  return(chrom.array)
}
```

```{r mapping_fun}
#The following are some functions used to hack together objeccts
#for mapping in qtl2.

#This function returns a "genoprobs" object used for mapping in qtl2
#if geno_type is chromatin, it will return the chromatin probabilities
#for the cis location of the transcript named.
#Otherwise, it returns the true genoprobs for the marker
#nearest the gene.
get_one_geno  <- function(gene.id, geno_type = c("chromatin", "genotype")){
  geno_type <- geno_type[1]
  info.locale <- which(transcript.info[,"ensembl_gene_id"] == gene.id)[1]

  if(is.na(info.locale)){return(NA)}

  gene.chr <- transcript.info[info.locale,"chromosome_name"]
  gene.start <- transcript.info[info.locale,"start_position"]

  if(geno_type == "chromatin"){
    one.geno <- list(calc.chrom(gene.id))
  }else{
    gene.locale <- which(names(transcript.haplotypes) == gene.id)
    one.geno <- list(transcript.haplotypes[[gene.locale]])
  }

  #add attributes
    names(one.geno) <- gene.chr
    if(gene.chr == "X"){
      attr(one.geno, "is_x_chr") <- TRUE
    }else{
      attr(one.geno, "is_x_chr") <- FALSE
    }
    attr(one.geno, "crosstype") <- "do"
    attr(one.geno, "alleles") <- LETTERS[1:8]
    attr(one.geno, "alleleprobs") <- TRUE
    attr(one.geno, "class") <- c("calc_genoprob", "list")
    return(one.geno)
}

get_map <- function(gene.id, map_type = c("chromatin", "genotype")){
  map_type <- map_type[1]  
  if(map_type == "chromatin"){
    gene.locale <- which(names(chrom.states) == gene.id)
    one.map <-  list(1:dim(chrom.states[[gene.locale]])[[3]])
    names(one.map[[1]]) <- dimnames(chrom.states[[gene.locale]])[[3]]
    names(one.map)[1] <- gene.chr
  }else{
    gene.chr <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == gene.id),"chromosome_name"][1]
    chr.locale <- which(names(map) == gene.chr)
    one.map <-  map[[chr.locale]]
  }
  return(one.map)
}


```

Run R/qtl2 on the chromatin probabilities for each transcript.

Also scan all the transcripts with the actual genoprobs at the 
cis location to calculate eQTL LOD scores and coefficients.


```{r scan_chQTL_and_eQTL}
chrom.coef.file <- here("Results", "chQTL", "chQTL.coef.RDS")
chrom.lod.file <- here("Results", "chQTL", "chQTL.lod.RDS")
chrom.r2.file <- here("Results", "chQTL", "chQTL.R2.RDS")
geno.coef.file <- here("Results", "eQTL", "eQTL.coef.RDS")
geno.lod.file <- here("Results", "eQTL", "eQTL.lod.RDS")
geno.r2.file <- here("Results", "eQTL", "eQTL.R2.RDS")

save.every = 100

if(file.exists(chrom.coef.file)){
  chrom.lod <- readRDS(chrom.lod.file)
  chrom.coef <- readRDS(chrom.coef.file)
  chrom.r2 <- readRDS(chrom.r2.file)
  geno.lod <- readRDS(geno.lod.file)
  geno.coef <- readRDS(geno.coef.file)
  geno.r2 <- readRDS(geno.r2.file)

  #figure out where we left off.
  not.na <- which(!is.na(geno.lod))  
  left.off <- max(not.na)
  start.at <- left.off + 1
}else{
  start.at <- 1

  #if we are at the beginning, intialize all the objects for holding
  #results. Make space for one set of genoprob coefficients for each 
  #transcript
  geno.coef <- matrix(NA, ncol = 8, nrow = length(common.transcripts))
  rownames(geno.coef) <- common.transcripts
  colnames(geno.coef) <- LETTERS[1:8]

  #make space for the full set of chromaprob coefficients for
  #each transcript.
  chrom.coef <- chrom.lod <- chrom.r2 <- vector(mode = "list", length = length(common.transcripts))
  names(chrom.coef) <- names(chrom.coef) <- names(chrom.r2) <- common.transcripts
  
  #there is only one lod score per transcript for the haplotypes
  geno.lod <- geno.r2 <- matrix(NA, ncol = 1, nrow = length(common.transcripts))
  rownames(geno.lod) <- rownames(geno.r2) <- common.transcripts 
  colnames(geno.lod) <- "Genotype_LOD"
  colnames(geno.r2) <- "Genotype_R2"
}

if(start.at < length(common.transcripts)){ #if we haven't scanned all the transcripts yet
  sink(here("progress.txt"))

  #for each remaining transcript
  #for(i in 1:100){
  for(i in start.at:length(common.transcripts)){
    print(i)
    if(is.interactive){report.progress(i, length(common.transcripts))}
    #gene.id <- transcript.info[which(transcript.info[,"external_gene_name"] == "Dynlt1c"),"ensembl_gene_id"][1]
    #i <- which(common.transcripts == gene.id)
    gene.id <- common.transcripts[i]
    expr.locale <- which(colnames(expr) == gene.id)
    chrom.locale <- which(names(chrom.mats) == gene.id)

    #chromatin scan
    chrom.geno <- get_one_geno(gene.id, "chromatin")
    
    if(is.na(chrom.geno)){next()}

    #check for variation
    test.var <- apply(chrom.geno[[1]], 3, function(x) apply(x, 2, function(y) var(y)))
    no.var <- all(apply(test.var, 1, function(x) length(unique(x))) == 1)

    if(no.var){next()}

    chrom.lod[[i]] <- scan1(chrom.geno, expr[,expr.locale], addcovar = covar)  
    chrom.coef[[i]] <- scan1coef(genoprobs = chrom.geno, pheno = expr[,expr.locale], 
    addcovar = covar)
    chrom.models <- apply(chrom.geno[[1]], 3, function(x) lm(expr[,expr.locale]~x+covar))
    ch.r2 <- sapply(chrom.models, function(x) summary(x)$adj.r.squared)
    chrom.r2[[i]] <- ch.r2

    #scan eQTL
    geno.geno <- get_one_geno(gene.id, "genotypes")
    geno.lod.results <- scan1(geno.geno, expr[,expr.locale], addcovar = covar)
    geno.r2[i] <- summary(lm(expr[,expr.locale]~geno.geno[[1]][,,1]+covar))$adj.r.squared
    geno.lod[i] <- geno.lod.results[1,1]
    geno.coef.results <- scan1coef(genoprobs = geno.geno, pheno = expr[,expr.locale], 
    addcovar = covar)
    geno.coef[i,] <- geno.coef.results[,LETTERS[1:8]]

    #test.state = 7
    #state.mat <- chrom.geno[[1]][,test.state,]
    #state.total <- rowSums(state.mat)
    #plot.with.model(state.total, expr[,expr.locale], xlab = "state total", ylab = "expression")
    #expr.df <- data.frame(expr[,expr.locale])
    #pheatmap(state.mat, annotation_row = expr.df, show_rownames = FALSE, cluster_cols = FALSE)

    if(is.interactive){
      quartz(width = 10, height = 6.5)
      layout.mat <- matrix(c(1,0, 2,3,4,6,5,0), ncol = 2, byrow = TRUE)
      layout(layout.mat, widths = c(1,0.4), heights = c(0.3, 1,1,1))
      par(mar = c(0,4,0,4))
      plot.new()
      plot.window(xlim = c(0,1), ylim = c(0,1))
      legend(0,0.5, fill = chrom.colors, legend = paste("State", 1:num.states), 
      horiz = TRUE, cex = 0.7, adj = 0)
      par(mar = c(2,4,2,4))
      plot.coef(chrom.coef[[i]], gene.id, transcript.info, "chromatin")
      ordered.coef <- sort(geno.coef[i,])
      ordered.coef.names <- strain.key[match.order(names(ordered.coef), 
      strain.key[,1], strain.key),1]
      barplot(ordered.coef, col = CCcolors[order(geno.coef[i,])], 
      ylab = "Haplotype Coefficient", names = ordered.coef.names, las = 2)
      par(mar = c(0,4,2,4))
      ymax <- max(c(chrom.lod[[i]][,1], geno.lod[i]), na.rm = TRUE)
      plot(chrom.lod[[i]][,1], type = "l", ylab = "LOD score", axes = FALSE,
      xlab = "", ylim = c(0, ymax))
      abline(h = geno.lod[i], col = "gray", lwd = 3, lty = 2)
      axis(2)
      par(mar = c(0,4,0,4))
      state.order <- match.order(names(ordered.coef), 
      colnames(chrom.mats[[chrom.locale]]), strain.key)
      #names(ordered.coef); colnames(chrom.mats[[chrom.locale]])[state.order]
      plot.chrom.mat(t(chrom.mats[[chrom.locale]][,state.order]))
      plot.new()
      plot.window(xlim = c(0,1), ylim = c(0,1))
      par(mar = c(0,4,2,4))
      segments(x0 = 0, x1 = 0.2, y0 = 0.5, lty = 2, 
      col = "gray", lwd = 3)
      text(x = 0.25, y = 0.5, "eQTL LOD Score", adj = 0)
    }

    #save every once in a while
    if(i %% save.every == 0){
      saveRDS(chrom.lod, chrom.lod.file)
      saveRDS(chrom.coef, chrom.coef.file)
      saveRDS(chrom.r2, chrom.r2.file)
      saveRDS(geno.lod, geno.lod.file)
      saveRDS(geno.coef, geno.coef.file)
      saveRDS(geno.r2, geno.r2.file)
    }
  }
  #also save at the end of everything.
  saveRDS(chrom.lod, chrom.lod.file)
  saveRDS(chrom.coef, chrom.coef.file)
  saveRDS(chrom.r2, chrom.r2.file)
  saveRDS(geno.lod, geno.lod.file)
  saveRDS(geno.coef, geno.coef.file)
  saveRDS(geno.r2, geno.r2.file)
}

sink(NULL)
```

