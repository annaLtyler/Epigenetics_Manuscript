---
title: "Map chromatin to genotype"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---


The purpose of this workflow is to impute chromatin states onto the DO mice
for each transcript using their genotypes at the marker nearest the TSS
of the transcript.

We then scan these chromatin probabilities in qtl2 to infer the effects of 
chromatin state on each transcript.

The basic pipeline for mapping chromatin to genotype is as follows: 

1. For each transcript identify the DO haplotypes at the marker nearest the TSS.
2. Use the haplotypes to calculate the chromatin states for each DO individual.
3. Calculate chromatin effects on transcript abundance using qtl2.

```{r source_code}
library("here")
all.code.dir <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.code.dir)){
	all.fun <- list.files(all.code.dir[i], full.names = TRUE)
	for(j in 1:length(all.fun)){source(all.fun[j])}
}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
args <- commandArgs(trailingOnly=T)
num.states <- as.numeric(args[1])
delete.previous <- as.logical(args[2])

if(is.na(num.states)){num.states = 14; delete.previous = FALSE}

needed.packages <- c("qtl2", "gtools", "parallel", "doParallel")
load_libraries(needed.packages, personal.library = TRUE)

results.dir <- here("Results", "ChromHMM", paste0(num.states, "_states_C"))
#barplot(1:length(chrom.colors), col = chrom.colors)
is.interactive = FALSE
#is.interactive = TRUE
n.cores = detectCores() - 1
#n.cores = 19

data(CCcolors)
chrom.colors <- colors.from.values(1:num.states, use.pheatmap.colors = TRUE)
```


Load data.

```{r load_do_data}
transcript.info <- readRDS(here("Data", "RNASeq", "RNASeq_gene_info.RData"))
transcript.haplotypes <- readRDS(here("Data", "DOQTL", "transcript.haplotypes.RDS"))

#rankZ normalized expression from Svenson_DO850_for_eQTL_viewer_v9.RData
#generated by 2.0_chromaprobs_setup.Rmd
expr.data <- readRDS(here("Data", "DOQTL", "DO_Expression.RDS")) 
expr <- expr.data$expr
covar <- expr.data$covar
#pull out diet as an interactive covariate
int.covar <- covar[,2,drop=FALSE]
chrom.state.file <- file.path(results.dir, "Expanded_Chromatin.RDS") #generated by 2.0_chromaprobs_setup.Rmd
chrom.states <- readRDS(chrom.state.file)
chrom.mats <- readRDS(file.path(results.dir, paste0("Chromatin_States_", num.states, "_full_gene_1000.RData")))

common.transcripts <- intersect(colnames(expr), names(chrom.states)) #transcripts that are shared between chromatin and DO expression data
hf.locale <- which(covar[,"diethf"] == 1)
chow.locale <- which(covar[,"diethf"] == 0)
```

Load the strain key. This helps us keep track of the different ways strains are named.

```{r strain.key}
strain.key <- read.table(here("Data", "support_files", "strain.color.table.txt"), 
sep = "\t", stringsAsFactors = FALSE, comment.char = "*")
```

For transcripts we perform the following steps. To reduce memory
requirements, we do all steps for each transcript and keep only the
LOD score and coefficient scores for each transcript.

1. Impute local chromatin state in DO from inbred chromatin state matrices.

2. Use qtl2 to calculate LOD scores and state coefficients for all states
and transcripts.


Run R/qtl2 on the chromatin probabilities for each transcript.

Also scan all the transcripts with the actual genoprobs at the 
cis location to calculate eQTL LOD scores and coefficients.


```{r scan_chQTL_and_eQTL}
chrom.lod.file <- file.path(results.dir, "chQTL.lod.RDS")
chrom.coef.file <- file.path(results.dir, "chQTL.coef.RDS")
chrom.r2.file <- file.path(results.dir, "chQTL.R2.RDS")
chrom.effect.file <- file.path(results.dir, "chromatin_state_effect.RDS")

geno.lod.file <- file.path(results.dir, "eQTL.lod.RDS")
geno.coef.file <- file.path(results.dir, "eQTL.coef.RDS")
geno.r2.file <- file.path(results.dir, "eQTL.R2.RDS")

if(delete.previous){
  unlink(chrom.lod.file)
  unlink(chrom.coef.file)
  unlink(chrom.r2.file)
  unlink(chrom.effect.file)
  unlink(geno.lod.file)
  unlink(geno.coef.file)
  unlink(geno.r2.file)
}

save.every = 100

model.names <- c("Additive", "Diet-Interactive", "Chow", "HF")

if(file.exists(chrom.coef.file)){
  chrom.lod <- readRDS(chrom.lod.file)
  chrom.coef <- readRDS(chrom.coef.file)
  chrom.r2 <- readRDS(chrom.r2.file)
  geno.lod <- readRDS(geno.lod.file)
  geno.coef <- readRDS(geno.coef.file)
  geno.r2 <- readRDS(geno.r2.file)
  chrom.effect <- readRDS(chrom.effect.file)

  #figure out where we left off.
  not.na <- which(!is.na(geno.lod[,1]))  
  left.off <- max(not.na)
  start.at <- left.off + 1
}else{
  start.at <- 1
  #if we are at the beginning, intialize all the objects for holding
  #results. Make space for one set of genoprob coefficients for each 
  #transcript
  geno.coef <- vector(mode = "list", length = length(common.transcripts))
  names(geno.coef) <- common.transcripts

  #make space for the full set of chromaprob coefficients for
  #each transcript.
  chrom.coef <- chrom.lod <- chrom.r2 <- chrom.effect <- vector(mode = "list", length = length(common.transcripts))
  names(chrom.coef) <- names(chrom.coef) <- names(chrom.r2) <- names(chrom.effect) <- common.transcripts
  
  #there is only one lod score per transcript for the haplotypes
  geno.lod <- geno.r2 <- matrix(NA, ncol = length(model.names), nrow = length(common.transcripts))
  rownames(geno.lod) <- rownames(geno.r2) <- common.transcripts 
  colnames(geno.lod) <- colnames(geno.r2) <- model.names
}
```


```{r stat_fun}
#functions for imputing chromatin states in the DO and calculating
#the associations with gene expression. 
scan_chrom_transcript <- function(gene.id, perm.order = NULL){

  gene.name <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == gene.id),"external_gene_name"][1]
  if(is.na(gene.name)){return(NA)}

  expr.locale <- which(colnames(expr) == gene.id)
  chrom.locale <- which(names(chrom.mats) == gene.id)

  if(length(expr.locale) == 0 || length(chrom.locale) == 0){
    return(NA)
  }

  #impute chromatin states for DO
  #using local haplotypes
  chrom.geno <- get_one_geno(gene.name, transcript.info, transcript.haplotypes, 
      chrom.states, strain.key, geno_type = "chromatin", perm.order = perm.order)
    
    if(is.na(chrom.geno)){return(NA)}

    #check for variation
    test.var <- round(apply(chrom.geno[[1]], 3, function(x) apply(x, 2, function(y) var(y))), 2)
    no.var <- length(which(apply(test.var, 1, function(x) length(unique(x))) > 1)) <= 1
    
    if(no.var){return(NA)}
   
    #calculate proportion of each state
    #prop.state <- lapply(1:num.states, function(x) rowMeans(chrom.geno[[1]][,x,]))
    #prop.effect <- sapply(1:num.states, function(x) if(var(signif(prop.state[[x]], 4)) > 0){plot.with.model(prop.state[[x]], 
      #expr[,expr.locale], confidence = 0.95, plot.results = FALSE)}else{rep(NA, 5)})
    
    #calculate chromatin LOD scores
    chrom.lod.table <- scan1(chrom.geno, expr[,expr.locale], addcovar = covar)
    colnames(chrom.lod.table) <- "Additive"
    #chrom.lod.int <- scan1(chrom.geno, expr[,expr.locale], addcovar = covar, intcovar = covar[,2,drop=FALSE])
    #chrom.chow.lod <- scan1(chrom.geno, expr[,expr.locale], addcovar = covar[chow.locale,])
    #chrom.hf.lod <- scan1(chrom.geno, expr[,expr.locale], addcovar = covar[hf.locale,])
    #chrom.lod.table <- cbind(chrom.lod.add, chrom.lod.int, chrom.chow.lod, chrom.hf.lod)
    #colnames(chrom.lod.table) <- model.names
    #boxplot(chrom.lod.table)

    #calculate chromatin state coefficients
    chrom.add.coef <- scan1coef(genoprobs = chrom.geno, pheno = expr[,expr.locale], 
      addcovar = covar)
    #chrom.int.coef <- scan1coef(genoprobs = chrom.geno, pheno = expr[,expr.locale], 
      #addcovar = covar, intcovar = int.covar)
    #chrom.chow.coef <- scan1coef(genoprobs = chrom.geno, pheno = expr[,expr.locale], 
      #addcovar = covar[chow.locale,])
    #chrom.hf.coef <- scan1coef(genoprobs = chrom.geno, pheno = expr[,expr.locale], 
      #addcovar = covar[hf.locale,])
    #chrom.coef.list <- list(chrom.add.coef[,1:num.states], chrom.int.coef[,1:num.states], chrom.chow.coef[,1:8], chrom.hf.coef[,1:num.states])
    #names(chrom.coef.list) <- model.names
    chrom.coef.list <- list(chrom.add.coef[,1:num.states])
    names(chrom.coef.list) <- "Additive"

    #calculate chromatin R2
    #adjust expression for covariates first, so we don't include 
    #the covariates in the variance explained
    adj.expr <- adjust(expr[,expr.locale,drop=FALSE], covar)
    #chrom.models.add <- apply(chrom.geno[[1]], 3, function(x) lm(expr[,expr.locale]~covar+x))
    chrom.models.add <- apply(chrom.geno[[1]], 3, function(x) lm(adj.expr~x))
    ch.add.r2 <- sapply(chrom.models.add, function(x) summary(x)$adj.r.squared)
    #plot(ch.add.r2, ylim = c(0, max(ch.add.r2)))
    #chrom.models.int <- apply(chrom.geno[[1]], 3, function(x) lm(adj.expr~x*int.covar))
    #ch.int.r2 <- sapply(chrom.models.int, function(x) summary(x)$adj.r.squared)
    #plot(ch.int.r2, ylim = c(0, max(ch.int.r2)))
    #chrom.chow.models <- apply(chrom.geno[[1]][chow.locale,,], 3, function(x) lm(adj.expr[chow.locale,]~x))
    #ch.chow.r2 <- sapply(chrom.chow.models, function(x) summary(x)$adj.r.squared)
    #plot(ch.chow.r2)
    #chrom.hf.models <- apply(chrom.geno[[1]][hf.locale,,], 3, function(x) lm(adj.expr[hf.locale,]~x))
    #ch.hf.r2 <- sapply(chrom.hf.models, function(x) summary(x)$adj.r.squared)
    #plot(ch.hf.r2)
    #chrom.r2.results <- cbind(ch.add.r2, ch.int.r2, ch.chow.r2, ch.hf.r2)
    #colnames(chrom.r2.results) <- model.names
    chrom.r2.results <- matrix(ch.add.r2, ncol = 1)
    colnames(chrom.r2.results) <- "Additive"

  #results <- list("prop.effect" = prop.effect, "chrom.lod.table" = chrom.lod.table, 
  #  "chrom.coef.list" = chrom.coef.list, "chrom.r2.results" = chrom.r2.results)

  results <- list("chrom.lod.table" = chrom.lod.table, 
    "chrom.coef.list" = chrom.coef.list, "chrom.r2.results" = chrom.r2.results)


  return(results)
}

scan_gene_transcript <- function(gene.id){
    #Calculate the same statistics for the genetic model
    #as for the chromatin state.

  gene.name <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == gene.id),"external_gene_name"][1]

  if(is.na(gene.name)){return(NA)}

  expr.locale <- which(colnames(expr) == gene.id)
  chrom.locale <- which(names(chrom.mats) == gene.id)

  if(length(expr.locale) == 0 || length(chrom.locale) == 0){return(NA)}

  geno.geno <- get_one_geno(gene.name, transcript.info, transcript.haplotypes, 
      chrom.states, strain.key, geno_type = "genotype")

  if(length(geno.geno) == 1){return(NA)}

  #LOD scores for genetics
  geno.lod.add <- scan1(geno.geno, expr[,expr.locale], addcovar = covar)
  geno.lod.int <- scan1(geno.geno, expr[,expr.locale], addcovar = covar, intcovar = int.covar)
  geno.lod.chow <- scan1(geno.geno, expr[,expr.locale], addcovar = covar[chow.locale,])
  geno.lod.hf <- scan1(geno.geno, expr[,expr.locale], addcovar = covar[hf.locale,])
  geno.lod.results <- c(geno.lod.add, geno.lod.int, geno.lod.chow, geno.lod.hf)
  names(geno.lod.results) <- model.names
  #barplot(geno.lod.results)
  #geno.lod[i,] <- geno.lod.results

  geno.coef.add <- scan1coef(genoprobs = geno.geno, pheno = expr[,expr.locale], 
  addcovar = covar)
  geno.coef.int <- scan1coef(genoprobs = geno.geno, pheno = expr[,expr.locale], 
  addcovar = covar, intcovar = int.covar)
  #barplot(geno.coef.add[,LETTERS[1:8]])
  geno.coef.chow <- scan1coef(genoprobs = geno.geno, pheno = expr[,expr.locale], 
  addcovar = covar[chow.locale,])
  geno.coef.hf <- scan1coef(genoprobs = geno.geno, pheno = expr[,expr.locale], 
  addcovar = covar[hf.locale,])
  geno.coef.results <- rbind(geno.coef.add[,c(LETTERS[1:8], "diethf")],
                            geno.coef.int[,c(LETTERS[1:8], "diethf")],
                            c(geno.coef.chow[,LETTERS[1:8]], NA),
                            c(geno.coef.hf[,LETTERS[1:8]], NA))
  rownames(geno.coef.results) <- model.names
  #quartz();pheatmap(geno.coef.results, cluster_rows = FALSE, cluster_cols = FALSE)
  #geno.coef[[i]] <- geno.coef.results

  #haplotype coefficients for genetics
  adj.expr <- adjust(expr[,expr.locale,drop=FALSE], covar)
  geno.r2.add <- summary(lm(adj.expr~geno.geno[[1]][,,1]))$adj.r.squared
  geno.r2.int <- summary(lm(adj.expr~geno.geno[[1]][,,1]*int.covar))$adj.r.squared
  geno.r2.chow <- summary(lm(adj.expr[chow.locale,]~+geno.geno[[1]][chow.locale,,1]))$adj.r.squared
  geno.r2.hf <- summary(lm(adj.expr[hf.locale,]~geno.geno[[1]][hf.locale,,1]))$adj.r.squared
  geno.r2.results <- c(geno.r2.add, geno.r2.int, geno.r2.chow, geno.r2.hf)
  names(geno.r2.results) <- model.names
  #barplot(geno.r2.results)
    #geno.r2[i,] <- geno.r2.results

    results <- list("geno.lod.results" = geno.lod.results, 
      "geno.coef.results" = geno.coef.results, "geno.r2.results" = geno.r2.results)
    return(results)
}

```

```{r run_remaining}

if(start.at < length(common.transcripts)){ #if we haven't scanned all the transcripts yet
  sink(file.path(results.dir, "progress.txt"))
  #for each remaining transcript
  for(i in start.at:length(common.transcripts)){
    print(i)

    if(is.interactive){report.progress(i, length(common.transcripts))}
    
    chrom.results <- scan_chrom_transcript(gene.id = common.transcripts[i])
    if(length(chrom.results) > 1){
      chrom.effect[[i]] <- chrom.results$prop.effect
      chrom.lod[[i]] <- chrom.results$chrom.lod.table
      chrom.coef[[i]] <- chrom.results$chrom.coef.list
      chrom.r2[[i]] <- chrom.results$chrom.r2.results
    }else{
      chrom.effect[[i]] <- NA
      chrom.lod[[i]] <- NA
      chrom.coef[[i]] <- NA
      chrom.r2[[i]] <- NA
    }

    gene.results <- scan_gene_transcript(gene.id = common.transcripts[i])
    if(length(gene.results) > 1){
      geno.lod[i,] <- gene.results$geno.lod.results
      geno.coef[[i]] <- gene.results$geno.coef.results
      geno.r2[i,] <- gene.results$geno.r2.results
    }else{
      geno.lod[i,] <- NA
      geno.coef[[i]] <- NA
      geno.r2[i,] <- NA
    }
    if(is.interactive){
      plot.chrom.effects(gene.name, expr, covar, chrom.mats, 
      transcript.info, transcript.haplotypes, chrom.states, strain.key)
    }

    #save every once in a while
    if(i %% save.every == 0){
      saveRDS(chrom.lod, chrom.lod.file)
      saveRDS(chrom.coef, chrom.coef.file)
      saveRDS(chrom.r2, chrom.r2.file)
      saveRDS(geno.lod, geno.lod.file)
      saveRDS(geno.coef, geno.coef.file)
      saveRDS(geno.r2, geno.r2.file)
      saveRDS(chrom.effect, chrom.effect.file)
    }
  }
  #also save at the end of everything.
  saveRDS(chrom.lod, chrom.lod.file)
  saveRDS(chrom.coef, chrom.coef.file)
  saveRDS(chrom.r2, chrom.r2.file)
  saveRDS(geno.lod, geno.lod.file)
  saveRDS(geno.coef, geno.coef.file)
  saveRDS(geno.r2, geno.r2.file)
  saveRDS(chrom.effect, chrom.effect.file)
  sink()
}


```

```{r select_nperm}
nperm = 1000
```

```{r perm_fun}
get_data_for_perm <- function(gene.id){

    info.locale <- which(transcript.info[,"ensembl_gene_id"] == gene.id)[1]
    gene.name <- transcript.info[info.locale,"external_gene_name"]
    if(is.na(gene.name)){return(NA)}

    expr.locale <- which(colnames(expr) == gene.id)
    chrom.locale <- which(names(chrom.mats) == gene.id)

    if(length(expr.locale) == 0 || length(chrom.locale) == 0){
        return(NA)
    }

    one.chrom <- chrom.states[[chrom.locale]]
    one.expr <- expr[,expr.locale,drop=FALSE]
    gene.idx <- which(names(transcript.haplotypes) == gene.id)
    haps <- transcript.haplotypes[[gene.idx]]
    gene.chr <- transcript.info[info.locale,"chromosome_name"]

    data.for.perm <- list("name" = gene.name, "chrom" = one.chrom, 
        "expr" = one.expr, "haps" = haps, "chr" = gene.chr)
    return(data.for.perm)
}

imp_chrom <- function(perm.data, perm.order){
 
  chrom.order <- match.order(colnames(perm.data$haps),
    rownames(perm.data$chrom), strain.key)

    ref.chroms <- perm.data$chrom
    if(!is.null(perm.order)){
        ref.chroms <- ref.chroms[perm.order,,]
        rownames(ref.chroms) <- colnames(perm.data$haps)
    }

    haps <- perm.data$haps
    chrom.array <- array(NA, dim = c(nrow(haps), ncol(ref.chroms), dim(ref.chroms)[3]))
    rownames(chrom.array) <- rownames(haps)
    colnames(chrom.array) <- paste0("State", colnames(ref.chroms))
    dimnames(chrom.array)[[3]] <- dimnames(ref.chroms)[[3]]
  
    for(p in 1:dim(ref.chroms)[3]){ #for each position
        chrom.mat <- ref.chroms[,,p]
        chrom.array[,,p] <- haps[,,1] %*% chrom.mat
        }

    #add attributes
    gene.chr <- perm.data$chr
    one.geno <- list(chrom.array)
    names(one.geno) <- gene.chr
    if(gene.chr == "X"){
      attr(one.geno, "is_x_chr") <- TRUE
    }else{
      attr(one.geno, "is_x_chr") <- FALSE
    }
    attr(one.geno, "crosstype") <- "do"
    attr(one.geno, "alleles") <- LETTERS[1:8]
    attr(one.geno, "alleleprobs") <- TRUE
    attr(one.geno, "class") <- c("calc_genoprob", "list")
 
    return(one.geno)
}


#This function and the perm data will be exported to the
#clusters
perm_one_transcript <- function(perm.data, p, 
  geno_type = c("chromatin", "genotype")){
  
  if(length(perm.data) == 1){return(NA)}
  
  perm.order <- order.mat[p,]

  imp.geno <- imp_chrom(perm.data, perm.order)

  if(is.na(imp.geno)){return(NA)}

  #check for variation
  test.var <- round(apply(imp.geno[[1]], 3, function(x) apply(x, 2, function(y) var(y))), 2)
  no.var <- length(which(apply(test.var, 1, function(x) length(unique(x))) > 1)) <= 1
    
  if(no.var){return(NA)}
       
  #calculate chromatin LOD scores
  chrom.lod.table <- scan1(imp.geno, perm.data$expr, addcovar = covar)
  colnames(chrom.lod.table) <- "Additive"

  #calculate chromatin state coefficients
  chrom.add.coef <- scan1coef(genoprobs = imp.geno, pheno = perm.data$expr, 
    addcovar = covar)
  chrom.coef.list <- list(chrom.add.coef[,1:num.states])
  names(chrom.coef.list) <- "Additive"

    #calculate chromatin R2
    #adjust expression for covariates first, so we don't include 
    #the covariates in the variance explained
    adj.expr <- adjust(perm.data$expr, covar)
    chrom.models.add <- apply(imp.geno[[1]], 3, function(x) lm(adj.expr~x))
    ch.add.r2 <- sapply(chrom.models.add, function(x) summary(x)$adj.r.squared)
    chrom.r2.results <- matrix(ch.add.r2, ncol = 1)
    colnames(chrom.r2.results) <- "Additive"

  results <- list("chrom.lod.table" = chrom.lod.table, 
    "chrom.coef.list" = chrom.coef.list, "chrom.r2.results" = chrom.r2.results)

  return(results)
}
```

```{r perm_files}
perm.lod.file <- file.path(results.dir, "Perm.LOD.RDS")
perm.r2.file <- file.path(results.dir, "Perm.R2.RDS")
perm.coef.file <- file.path(results.dir, "Perm.Coef.RDS")

if(file.exists(perm.lod.file)){
  perm.lod <- readRDS(perm.lod.file)
  perm.r2 <- readRDS(perm.r2.file)
  perm.coef <- readRDS(perm.coef.file)

  #figure out where we left off.
  not.na <- which(!is.na(perm.lod[,1]))  
  left.off <- max(not.na)
  start.at <- left.off + 1
}else{
  start.at <- 1
  #if we are at the beginning, intialize all the objects for holding
  #results. 
  perm.lod <- perm.r2 <- matrix(NA, nrow = length(common.transcripts), ncol = nperm)
  rownames(perm.lod) <- rownames(perm.r2) <- common.transcripts
  perm.coef <- vector(mode = "list", length = length(common.transcripts))
  names(perm.coef) <- common.transcripts
}

```


```{r set_perm}
#select a set of permutations for which none of the chromatin
#states get assigned to their original haplotype.
#these are called derrangements
perm.mat <- derrangements(8)
#sample a random set of derraangements to use
#for all transcripts
perm.rows <- sample(1:nrow(perm.mat), nperm)
order.mat <- perm.mat[perm.rows,]

```


```{r set_cl, warning = FALSE}
if(start.at < length(common.transcripts)){
  #set up the clusters if we need to run perutations

  to.export <- c("scan1", "scan1coef", "covar", "perm_one_transcript",
    "num.states", "adjust", "order.mat", "imp_chrom", "match.order", "strain.key")

  #create and register multiple cores for parallele permutations
  cl <- makeCluster(n.cores)
  registerDoParallel(cl)
  #export everything we need to the cluster
  #this takes time upfront, but the parallelization
  #saves a huge amount of time overall
  clusterExport(cl, to.export) 
}
```


```{r do_perm}

if(start.at < length(common.transcripts)){
  sink(file.path(results.dir, "progress.txt"))

  for(tr in start.at:length(common.transcripts)){
  #for(tr in 1:10){
    print(tr)

    #gene.name = "Pkd2"
    #gene.id <- transcript.info[which(transcript.info[,"external_gene_name"] == gene.name)[1],"ensembl_gene_id"]
    #tr = which(common.transcripts == gene.id)

    gene.id <- common.transcripts[tr]
    #gene.name <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == gene.id)[1],"external_gene_name"]

    perm.data <- get_data_for_perm(gene.id)

    if(is.na(perm.data)){next()}

    if(dim(perm.data$chrom)[[3]] < 1000){

      #send the new gene ID to the clusters
      clusterExport(cl, "perm.data")

      #do the permutations in parallel
      perm.chrom.results <- parLapply(cl, 1:nperm, 
          function(p) perm_one_transcript(perm.data, 
          p = p))

      #check for NAs
      if(all(sapply(perm.chrom.results, length) > 1)){

        perm.chrom.coef <- lapply(perm.chrom.results, function(x) x$chrom.coef.list)
        perm.chrom.lod <- lapply(perm.chrom.results, function(x) x$chrom.lod.table)
        perm.chrom.r2 <- lapply(perm.chrom.results, function(x) x$chrom.r2.results)

        #keep the maximum r2 and LOD values from each permutation.
        #also keep the permuted coefficients for each state
        tr.perm.coef <- lapply(1:num.states, 
          function(x) sapply(perm.chrom.coef, function(y) y$Additive[,x]))
        names(tr.perm.coef) <- 1:num.states
        perm.coef[[tr]] <- tr.perm.coef
        perm.lod[tr,] <- t(sapply(perm.chrom.lod, function(x) max(x[,"Additive"])))
        perm.r2[tr,] <- t(sapply(perm.chrom.r2, function(x) max(x[,"Additive"])))
      }#end case for data actually returned from the scans
    } #end case for when chromatin matrix is too big

    if(tr %% save.every == 0){
      saveRDS(perm.lod, perm.lod.file)
      saveRDS(perm.r2, perm.r2.file)
      saveRDS(perm.coef, perm.coef.file)
    }

  } #end looping through transcripts

  #close the clusters at the end and save the final objects
  stopCluster(cl)

  saveRDS(perm.lod, perm.lod.file)
  saveRDS(perm.r2, perm.r2.file)
  saveRDS(perm.coef, perm.coef.file)
  sink()
}
```

For reasons that are still not totally clear to me,
permuting the chromatin-haplotype assignments does
not really affect the LOD score. However, it does
affect the state coefficients. So what I think we 
want to do is to focus less on the variance explained
by chromatin state, and focus more on the effect
direction and position. This might actually help 
us filter putative cis regulatory regions.

For each transcript we go through the permuted
state coefficients to see where the strength of
the coefficient is significantly different from 
the null distribution.

```{r emp_p}
#our ecdf function seems to be underestinating p values
#even if there are multiple values in the null that
#are identical to the observed value, we still get a
#p value of 0

emp.p <- function(obs.val, null.dist){
  if(is.na(obs.val)){return(NA)}
  as.or.more.extreme <- which(abs(null.dist) >= abs(obs.val))
  p <- length(as.or.more.extreme)/length(null.dist)
  return(p)
}

```


```{r perm_comp}
get_pos_coef <- function(tr, st, perm = FALSE){
  if(!perm){
    if(length(centered.pos[[tr]]) > 1 && length(chrom.coef[[tr]]) > 1){
      tr.pos <- as.numeric(names(centered.pos[[tr]]))
      tr.coef <- chrom.coef[[tr]]$Additive[,st]
      result <- cbind(tr.pos, tr.coef)
    }else{
      return(matrix(c(NA, NA), ncol = 2))
    }
  }else{
      if(length(centered.pos[[tr]]) > 1 && length(perm.coef[[tr]]) > 1){
        tr.pos <- as.numeric(names(centered.pos[[tr]]))
        perm.tr.coef <- perm.coef[[tr]][[st]]
        max.perm <- apply(perm.tr.coef, 1, function(x) if(!all(is.na(x))){max(x, na.rm = TRUE)}else{NA})
        min.perm <- apply(perm.tr.coef, 1, function(x) if(!all(is.na(x))){min(x, na.rm = TRUE)}else{NA})
        result <- cbind(tr.pos, max.perm, min.perm)
      }else{
        result <- matrix(c(NA, NA, NA), ncol = 3)
      }
    }
    return(result)
}


centered.pos <- lapply(1:length(common.transcripts), 
  function(x) if(length(chrom.coef[[x]]) > 1){center.on.feature(gene.names[x], transcript.info, 
  vals = as.numeric(rownames(chrom.coef[[x]]$Additive)), feature = "full")}else{NA})

for(st in 1:num.states){
  state.coef <- lapply(1:length(common.transcripts), 
    function(x) get_pos_coef(x, st))
  state.pos <- unlist(lapply(state.coef, function(x) if(length(x) > 1){x[,1]}else{NA}))
  pos.coef <- unlist(lapply(state.coef, function(x) if(length(x) > 1){x[,2]}else{NA}))
  not.na <- intersect(which(!is.na(state.pos)), which(!is.na(pos.coef)))
  plot(state.pos[not.na], pos.coef[not.na], xlim = c(-0.5, 1.5))

  perm.state.coef <- lapply(1:length(common.transcripts), 
    function(x) get_pos_coef(x, st, perm = TRUE))  
  state.pos <- unlist(lapply(perm.state.coef, function(x) if(length(x) > 1){x[,1]}else{NA}))
  max.coef <- unlist(lapply(perm.state.coef, function(x) if(length(x) > 1){x[,2]}else{NA}))
  min.coef <- unlist(lapply(perm.state.coef, function(x) if(length(x) > 1){x[,3]}else{NA}))
  points(state.pos, max.coef, xlim = c(-0.5, 1.5), col = "red", pch = 16, cex = 0.5)
  points(state.pos, min.coef, xlim = c(-0.5, 1.5), col = "red", pch = 16, cex = 0.5)

}

```

```{r sig_coef}

#calculate p values for the coefficients of each state at each 
#position in each transcript.
plot.results = FALSE
all.coef.p <- vector(mode = "list", length = length(common.transcripts))
names(all.coef.p) <- common.transcripts
for(tr in 1:length(chrom.coef)){
  if(length(chrom.coef[[tr]]) <= 1){next()}
  tr.chrom.coef <- chrom.coef[[tr]]$Additive
  tr.perm.coef <- perm.coef[[tr]]
  if(is.null(tr.perm.coef)){next()}

  coef.by.state <- lapply(1:num.states, function(x) tr.chrom.coef[,x])

  if(plot.results){
    #pdf("~/Desktop/perm_comp.pdf", width = 10, height = 6)
    boxplot(tr.chrom.coef, main = "overall state effects")
    abline(h = 0)
    x <- as.numeric(rownames(tr.chrom.coef))
    for(st in 1:num.states){
      has.vals <- as.logical(length(which(!is.na(tr.perm.coef[[st]]))))
      if(has.vals){
        boxplot(t(tr.perm.coef[[st]]), at = x, main = paste("State", st))
        points(x, coef.by.state[[st]], col = "red", pch = "*") 
      }
    }
    #dev.off()
  }


  tr.coef.p <- matrix(NA, nrow = nrow(tr.chrom.coef), ncol = ncol(tr.chrom.coef))
  dimnames(tr.coef.p) <- dimnames(tr.chrom.coef)
  for(st in 1:num.states){
    has.coef <- intersect(which(!is.na(coef.by.state[[st]])), which(coef.by.state[[st]] != 0))
    if(length(has.coef) > 0){
      tr.coef.p[has.coef,st] <- sapply(has.coef, 
        function(x) emp.p(tr.chrom.coef[x,st], tr.perm.coef[[st]][x,]))
    }
  }

  all.coef.p[[tr]] <- tr.coef.p
}

sig.coef <- lapply(chrom.coef, function(x) if(length(x) > 1){x$Additive}else{NA})
for(tr in 1:length(sig.coef)){
  if(length(all.coef.p[[tr]]) == 0){
    sig.coef[[tr]] <- NA
  }
  if(length(chrom.coef[[tr]]) > 1){
    non.sig.locale <- which(all.coef.p[[tr]] > 0)
    na.p <- which(is.na(all.coef.p[[tr]]))
    #pheatmap(t(-log10(all.coef.p[[tr]]+1e-2)), cluster_rows = FALSE, cluster_cols = FALSE)
    temp.mat <- sig.coef[[tr]]
    temp.mat[non.sig.locale] <- NA
    temp.mat[na.p] <- NA
    sig.coef[[tr]] <- temp.mat
    #pheatmap(t(sig.coef[[tr]]), cluster_rows = FALSE, cluster_cols = FALSE)
  }

}

#look at the overall distribution of the significant
#coefficients for each state
sig.coef.by.state <- lapply(1:num.states, 
  function(x) unlist(lapply(sig.coef, function(y) if(length(y) > 1){y[,x]}else{NA})))
#pdf("~/Desktop/sig.coef.pdf")
boxplot(sig.coef.by.state)
#stripchart(sig.coef.by.state, vertical = TRUE, method = "jitter", col = "gray", pch = 16)
abline(h = 0)
#dev.off()
```

## Significant Coefficients by Position

```{r bin_coef}
bin_coef <- function(xvals, yvals, xmin, xmax, nbins){
  bins <- segment.region(xmin, xmax, nbins, "ends")
  consec.bins <- consec.pairs(bins)
  binned.vals <- vector(mode = "list", length = nrow(consec.bins)+1)
  for(i in 1:nrow(consec.bins)){
    above.min <- which(xvals >= consec.bins[i,1])
    below.max <- which(xvals < consec.bins[i,2])
    bin.idx <- intersect(above.min, below.max)
    binned.vals[[i]] <- yvals[bin.idx]
  }
  bin.idx <- which(xvals > consec.bins[i,2])
  binned.vals[[(i+1)]] <- yvals[bin.idx]
  return(binned.vals)
}

```

```{r coef_by_pos}
#center the significant coefficients
gene.names <- transcript.info[match(common.transcripts, transcript.info[,"ensembl_gene_id"]),"external_gene_name"]
centered.sig.coef <- lapply(1:length(common.transcripts), 
  function(x) center.on.feature(gene.names[x], transcript.info, 
  vals = as.numeric(rownames(sig.coef[[x]])), feature = "full"))
centered.sig <- sig.coef
for(tr in 1:length(centered.sig)){
  if(length(centered.sig.coef[[tr]]) > 1){
    rownames(centered.sig[[tr]]) <- names(centered.sig.coef[[tr]])
  }else{
    centered.sig[[tr]] <- NA
  }
}

#pdf("~/Desktop/state.effects.pdf")
min.coord = -0.5; max.coord = 1.5; nbins = 42
bins <- segment.region(min.coord, max.coord, nbins, "ends")
for(st in 1:num.states){
  cent.state <- lapply(centered.sig, function(x) if(length(x) > 1){x[,st]})
  state.vals <- unlist(cent.state)
  state.pos <- as.numeric(unlist(lapply(cent.state, names)))
  not.na <- which(!is.na(state.vals))
  plot(state.pos[not.na], state.vals[not.na], xlab = "Relative Position",
    ylab = "Coefficient", main = paste("State", st), pch = 16, col = "darkgray")
  abline(h = 0)
  abline(v = c(0,1))

  binned.coef <- bin_coef(state.pos, state.vals, min.coord, max.coord, nbins)
  boxplot(binned.coef, main = paste("State", st), names = round(bins, 2))
  abline(v = match(c(0,1), round(bins, 1)), col = "slateblue", lwd = 3)
  abline(h = 0)
}
#dev.off()



```
