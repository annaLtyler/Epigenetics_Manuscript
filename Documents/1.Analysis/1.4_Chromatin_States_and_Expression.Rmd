---
title: "Analyzing ChromHMM Results"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction

The purpose of this workflow is to combine chromatin state data from 
a single chromHMM model and gene expression. This workflow takes a 
gene-based approach. It calculates the chromatin state composition of 
each gene and calculates correlations between the state composition and
gene expression.

This workflow generates data files that are used in downstream analyses and
performs the following specific tasks:

**Gene Expression**

1. Generate information file for RNA-Seq data.
    * produces file RNASeq\_gene\_info.RData
2. Average expression across individuals in a given strain.
    * produces file Strain\_Mean\_C\_Expression.RData
2. Filter out genes with low variance across strains.
    * no file is produced. Low-variance genes are replace with NA's.

**DO eQTL**

1. Extracts cis eQTL coefficients and writes to cis.coef.RData.

**Chromatin**

1. Create matrices of chromatin states for each transcript.
    * produces file with the pattern 
    Chromatin\_States\_num.states\_gene.type\_bp.buffer.RData
2. Create matrices of chromatin state proportions for each transcript.
    * produces a file with the pattern 
    Chromatin\_State\_num.states\_Prop\_gene.type\_bp.buffer.RData
3. Dimension reduces the proportion matrices using multi-dimensional scaling.
    * produces a file with the pattern 
    Chromatin\_State\_num.states\_MDS\_gene.type\_bp.buffer.RData
4. Exploration of states
    * Heatmap of state proportions across strains.

**Chromatin and Expression**

1. Correlate proportion of each chromatin state in each gene with gene expression.
    * produces file with the pattern
    State\_num.states\_Prop_\Expression\_Cor\_gene.type\_bp.buffer.RData
    *This file contains pearson correlation r values and p values.
2. Correlate MDS dimension-reduced chromatin proportion matrix with gene expression
    * produces file with the pattern
    State\_num.states\_MDS\_Expression\_Cor\_gene.type\_bp.buffer.RData
3. Explore examples
    Plots are generated for example genes showing where specific chromatin 
    states are correlated with gene expression across the strains.

```{r set_args}
args <- commandArgs(trailingOnly=T)
num.states <- as.numeric(args[1])
delete.previous = as.logical(args[2]) #whether to delete and regenerate files 
                    #from previous a run.
is.interactive = FALSE
#is.interactive = TRUE

if(is.na(num.states)){
    num.states = 9; delete.previous = FALSE
    #num.states = 9; delete.previous = FALSE
}
```


```{r source_code}
library("here")
all.code.dir <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.code.dir)){
	all.fun <- list.files(all.code.dir[i], full.names = TRUE, pattern = ".R")
	for(j in 1:length(all.fun)){source(all.fun[j])}
}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
needed.packages <- c("VennDiagram", "ape", "gprofiler2", 
"e1071", "DESeq2", "knitr", "pheatmap", "hexbin", "RColorBrewer", "MASS", 
"gridExtra", "grid", "ggplotify", "qtl2")
load_libraries(needed.packages)
```


## Setup
Set the number of states to be analyzed, and the mark, if relevant.

```{r state_num}
selected.mark <- NULL #set to null to use all marks
#selected.mark <- "H3K4me1"
#selected.mark <- "H3K4me3"
#selected.mark <- "H3K27ac"
#selected.mark <- "H3K27me3"
```

Set up additional parameters for looking at states around gene bodies.
These are changeable, but will not change after the 

```{r set_param}
start.feature = "start_position" #feature of gene to start from. start_position means TSS, and end_position means TES
end.feature = "end_position" #feature of gene to end at. start_position means TSS, and end_position means TES
upstream.buffer = 1000 #number of bp upstream to go from start.feature
downstream.buffer = 1000 #number of bp downstream to go from end.feature
T.or.C <- "C" #whether to analyze the control (C) or treatment (T) animals.
```

```{r setup_dir}
#data and results are a little bit mixed up, since results from one
#analysis can be data for another analysis. I try to keep processed
#data in data directories and final results in results directories.
#form.states <- paste0(formatC(num.states, digits = 2, flag = 0), "_states", selected.mark, "_", T.or.C)
form.states <- paste0(num.states, "_states", selected.mark, "_", T.or.C)
data.dir <- here("Data", "ChromHMM", form.states)
results.dir <- here("Results", "ChromHMM", form.states)
if(!file.exists(results.dir)){dir.create(results.dir)}
```

```{r results_files}
if(start.feature == "start_position" && end.feature == "start_position"){
    gene.text <- "TSS"
    }
if(start.feature == "start_position" && end.feature == "end_position"){
    gene.text <- "full_gene"
    }

buffer.text <- paste(unique(c(upstream.buffer, downstream.buffer)), collapse = "_")
```

```{r clear_results}
#If evaluated, this chunk will clear out all results generated
#by this script to trigger recalculation of all results
if(delete.previous){
    delete.files <- list.files(here("Results", "ChromHMM", form.states), full.names = TRUE)
    if(length(delete.files) > 0){
        for(i in 1:length(delete.files)){
            unlink(delete.files[i])
        }
    }
}
```

Strain names between different analyses are inconsistent. We have a table for 
comparing different names as well as for defining strain colors. I made this
table by hand. Load it here:

```{r load_color_key}
key.file <- here("Data", "support_files", "strain.color.table.txt")
col.table <- as.matrix(read.table(key.file, sep = "\t", comment.char = "%", 
stringsAsFactors = FALSE))
```

## Expression Data

The expression data were processed in the Expression workflow. That workflow
performed the following. 
1. Filtered for genes with at least 5 reads in at least 20\% of animals
2. Performed vst on expression data.
All animals are female, so we do not need to do a correction for sex.

### Expression distribution across samples

```{r load_expression, fig.width = 7, fig.height = 7}
rna.seq.file <- here("Data", "RNASeq", "StrainsEffCts9_vst.RDS")
rna.seq <- readRDS(rna.seq.file)
#boxplot(rna.seq, las = 2)

col.order <- match.order(substr(colnames(rna.seq), 1, 2), col.table[,1], col.table)
if(is.interactive){quartz()}
expr.decomp <- plot.decomp(t(rna.seq), cols = col.table[col.order,3], pc = 5)
#quartz();plot.decomp(t(rna.seq), cols = col.table[col.order,3])
```

```{r gene_info}
#Get information about all expressed genes from BiomaRt:
gene.info.file <- here("Data", "RNASeq", "RNASeq_gene_info.RData")
all.var <- ls()
if(!file.exists(gene.info.file)){
    library(biomaRt) #only load this if we need to query it
    lib.loaded <- as.logical(length(which(all.var == "mus")))
    if(!lib.loaded){
        if(!file.exists(gene.info.file)){
            #mus <- useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl") #most current library
            #use this stable version because we need locations to be in mm10
            mus <- useEnsembl("ENSEMBL_MART_ENSEMBL", dataset = "mmusculus_gene_ensembl", 
            host = "may2017.archive.ensembl.org") #stable archived library
            }
        } 
    rnaseq.gene.info.comp <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", 
    "chromosome_name", "start_position", "end_position", "transcription_start_site", 
    "exon_chrom_start", "exon_chrom_end", "5_utr_start","5_utr_end","3_utr_start", 
    "3_utr_end", "strand"), 
    filters = "ensembl_gene_id", values = rownames(rna.seq), mart = mus)
    saveRDS(rnaseq.gene.info, gene.info.file)
}else{
    rnaseq.gene.info <- readRDS(gene.info.file)
}
```

Average expression across individuals in each strain.

```{r strain_expr}
#file containing strain averages for each transcript. These
#do not change from run to run. Save in data
strain.expr.file <- here("Data", "RNASeq", paste0("Strain_Mean_", T.or.C, "_Expression.RData"))
if(!file.exists(strain.expr.file)){
    #get expression for the condition (control or treatment)
    strain.mean.expr <- lapply(rownames(rna.seq), function(x) 
    get.cond.expr(rnaseq.gene.info, rna.seq, x, T.or.C = T.or.C, return.mean = TRUE))
    names(strain.mean.expr) <- rownames(rna.seq)
    #save the results
    saveRDS(strain.mean.expr, strain.expr.file)
}else{
    strain.mean.expr <- readRDS(strain.expr.file)
}

#also scale the expression for each gene.
strain.scaled.expr.file <- here("Data", "RNASeq", paste0("Strain_Scaled_", T.or.C, "_Expression.RData"))
if(!file.exists(strain.scaled.expr.file)){
    scaled.mean.expr  <- lapply(strain.mean.expr, scale)
    saveRDS(scaled.mean.expr, strain.scaled.expr.file)
}else{
    scaled.mean.expr <- readRDS(strain.scaled.expr.file)
}
```

### Expression Variation Filter

Because we are specifically interested in variance in expression across 
strains, we filtered the transcripts to include those that had a large amount
of variation across strains. We chose only those transcripts that had at least 
a minimum difference between the highest-expressing strain, and the 
lowest-expressing strain.

The plot below shows the distribution of the variance across strains 
with a vertical line indicating the threshold for selection.

```{r strain_expr_filter}
var.lim = 0.3
zero.expr <- rep(NA, 9)
names(zero.expr) <- names(strain.mean.expr[[1]])
strain.var <- sapply(strain.mean.expr, function(x) max(x) - min(x))
strain.sd <- sapply(strain.mean.expr, function(x) sd(x))
if(is.interactive){quartz()}
hist(strain.var, breaks = 100)
abline(v = var.lim, col = "red", lwd = 2)

low.var <- which(strain.var < var.lim)
if(length(low.var) > 0){
    for(i in 1:length(low.var)){
        strain.mean.expr[[low.var[i]]] <- zero.expr
    }
}

still.used <- length(which(sapply(strain.mean.expr, function(x) !all(is.na(x)))))
```

We removed `r length(low.var)` genes with across-strain variance lower than
`r var.lim`. This leaves a total of `r still.used` transcripts for analysis.


## ChromHMM Output Processing
We analyzed the chromatin states based on states output by ChromHMM. 
See analysis 1.ChromHMM.Rmd. This analysis looks at the output from the model with
`r num.states` states.


```{r load_bed}
#Load the ChromHMM bed files for all strains:
bed.files <- list.files(data.dir, pattern = "dense.bed", full.names = TRUE)
strains <- substr(colnames(rna.seq), 1,2)
strain.names <- sort(unique(strains))
strain.bed.names <- sapply(strsplit(basename(bed.files), "_"), function(x) x[1])

#Naming conventions between data sets are inconsistent.
#make a key by hand for conversion
if(T.or.C == "C"){
    strain.key <- cbind(strain.bed.names, c(strain.names[8], strain.names[-8]))
}else{
    strain.match <- match(strain.bed.names, strains)
    strain.key <- cbind(strain.bed.names, strains[strain.match])
}

all.bed <- vector(mode = "list", length = nrow(strain.key))
names(all.bed) <- strain.key[,1]
for(i in 1:nrow(strain.key)){
    bed.locale <- grep(pattern = strain.bed.names[i], bed.files)[1]
    if(!is.na(bed.locale) > 0){
        all.bed[[i]] <- read.table(bed.files[bed.locale], sep = "\t", skip = 1, 
        stringsAsFactors = FALSE)
    }
}
```

## Chromatin states by gene
The first step in this analysis is to create matrices of chromatin states for each 
transcript. In this step, we go through all transcripts in the RNA Seq data set. 
For each transcript, we get the ChromHMM states around the gene body or transcription 
start site as defined by the parameters at the top of this file. The states across 
all strains are combined into a single matrix.

```{r get_chrom_states, warning = FALSE}
#This chunk takes about 3 hours to run depending 
#on the number of genes in the filtered expression 
#table.
#file containing chromatin states in and around each transcript
chrom.state.file <- file.path(results.dir, 
paste0("Chromatin_States_", num.states, "_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(chrom.state.file)){
    #get the states around each transcript across all strains
	chrom.mats <- lapply(rownames(rna.seq), function(x) get.chrom.state(bed.info = all.bed, 
    rnaseq.gene.info, rna.seq, x, start.feature, end.feature, upstream.buffer, 
    downstream.buffer))
	names(chrom.mats) <- rownames(rna.seq)
	saveRDS(chrom.mats, chrom.state.file)
}else{
    chrom.mats <- readRDS(chrom.state.file)
}

#file containing proportions of each chromatin state in and around each transcript
chrom.prop.file <- file.path(results.dir,
paste0("Chromatin_State_", num.states, "_Prop_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(chrom.prop.file)){
	chrom.state.props <- get.chrom.state.prop(chrom.mats, num.states = num.states, verbose = FALSE)
	names(chrom.state.props) <- rownames(rna.seq)
	saveRDS(chrom.state.props, chrom.prop.file)
}else{
    chrom.state.props <- readRDS(chrom.prop.file)
}

#file containing the one-dimensional reduction of each chromatin state matrix
chrom.mds.file <- file.path(results.dir,
paste0("Chromatin_State_", num.states, "_MDS_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(chrom.mds.file)){
    chrom.mds <- get.scaled.chrom.mats(chrom.mats, 1)
    saveRDS(chrom.mds, chrom.mds.file)
}else{
    chrom.mds <- readRDS(chrom.mds.file)
}
```

## Chromatin state and expression within strain

We looked across genes within strain to see if individual states were
associated with highly expressed genes and lowly expressed genes.

The following plot shows the overall correlations between TPM and proportion
of chromatin state across the gene within each strain.

Presence of states 7 and 5 is correlated with highly expressed genes,
whereas the presence of states 1 and 2 is correlated
with lowly expressed genes.

```{r within_strain}
has.expr <- which(sapply(strain.mean.expr, length) == 9)
has.chrom <- which(sapply(chrom.state.props, length) > 1)
common.genes <- intersect(names(strain.mean.expr)[has.expr], names(chrom.state.props)[has.chrom])
common.expr.locale <- match(common.genes, names(strain.mean.expr))
common.chrom.locale <- match(common.genes, names(chrom.state.props))
chrom.order <- match.order(names(strain.mean.expr[[1]]), colnames(chrom.state.props[[1]]), col.table)

all.state.conf <- matrix(NA, nrow = num.states, ncol = 5)
colnames(all.state.conf) <- c("r", "p.value", "slope.fit", "slope.lwr", "slope.upr")
rownames(all.state.conf) <- 1:num.states

strain.expr.mat <- t(sapply(strain.mean.expr[common.expr.locale], function(x) x))

for(state in 1:num.states){    
    strain.chrom.mat <- t(sapply(chrom.state.props[common.chrom.locale], 
    function(x) x[state,chrom.order]))
    conf.by.strain <- sapply(1:ncol(strain.chrom.mat), 
        function(x) plot.with.model(rankZ(strain.chrom.mat[,x]), 
        rankZ(strain.expr.mat[,x]), confidence = 0.95, plot.result = FALSE))
    all.state.conf[state,] <- rowMeans(conf.by.strain)
}

ymin <- -0.6;ymax = 0.6
state.col <- colors.from.values(1:num.states, use.pheatmap.colors = TRUE)
state.col[3:5] <- darken(state.col[3:5], factor = 1.1) #darken the middle colors. they are very light!
#state.col <- rep("gray40", num.states)
conf.lwr <- min(all.state.conf[,"slope.lwr"])
conf.upr <- max(all.state.conf[,"slope.upr"])
if(is.interactive){quartz(width = 7, height = 5)}
plot.new()
plot.window(xlim = c(1, num.states), ylim = c(ymin, ymax))
#add grid lines
abline(v = 1:num.states, h = seq(-0.6, 0.6, 0.2), col = "gray80")
for(state in 1:num.states){
    line.col <- state.col[state]
    points(state, all.state.conf[state,"slope.fit"], pch = 16, col = line.col, cex = 1.5)
    segments(x0 = state-0.2, x1 = state+0.2, y0 = all.state.conf[state,"slope.lwr"],
        col = line.col, lwd = 4) #lower confidence interval
    segments(x0 = state-0.2, x1 = state+0.2, y0 = all.state.conf[state,"slope.upr"],
        col = line.col, lwd = 4) #upper confidence interval
    segments(x0 = state, y0 = all.state.conf[state,"slope.lwr"], 
        y1 = all.state.conf[state,"slope.upr"], col = line.col, lwd = 4) #vertical bar
}
abline(h = 0)
axis(2, at = round(seq(ymin, ymax, 0.2), 1))
par(xpd = TRUE)
text(x = 1:num.states, y = rep((ymin*1.1), num.states), labels = 1:num.states)
par(xpd = FALSE)
mtext(side = 2, "Effect", line = 2.5)
mtext(side = 3, "Within-Strain State Effects with 95% Confidence Intervals", line = 2.5)
```

```{r within_effect_fig}
y.coord = num.states:1
pdf("~/Desktop/within_strain_effects.pdf", width = 6, height = 4)
plot.new()
plot.window(ylim = c(1, num.states), xlim = c(ymin, ymax))
#add grid lines
abline(h = 1:num.states, v = seq(-0.6, 0.6, 0.2), col = "gray80")
for(state in 1:num.states){
    line.col <- state.col[state]
    #points(y = y.coord[state], x = all.state.conf[state,"slope.fit"], pch = 16, 
    #    col = line.col, cex = 1.5)
    segments(y0 = y.coord[state]-0.2, y1 = y.coord[state]+0.2, 
        x0 = all.state.conf[state,"slope.lwr"], col = line.col, lwd = 4) #lower confidence interval
    segments(y0 = y.coord[state]-0.2, y1 = y.coord[state]+0.2, 
        x0 = all.state.conf[state,"slope.upr"],
        col = line.col, lwd = 4) #upper confidence interval
    segments(y0 = y.coord[state], x0 = all.state.conf[state,"slope.lwr"], 
        x1 = all.state.conf[state,"slope.upr"], col = line.col, lwd = 4) #vertical bar
}
abline(v = 0)
#axis(1, at = round(seq(ymin, ymax, 0.2), 1))
dev.off()
```

## Chromatin state and inbred expression
We also wanted to see if differential expression across strains 
could be explained, at least in part, by chromatin state. 

To investigate this, we scaled the expression of all transcripts
across strains. We then correlated the proportion of each state
with expression across all transcripts. 

The figure below shows the 95\% confidence intervals around the 
effect size of each state.

```{r states_and_expression}
expr.mat <- t(sapply(strain.mean.expr, function(x) if(length(x) > 1){scale(x)}else{rep(NA, 9)}))
colnames(expr.mat) <- names(strain.mean.expr[[1]])
full.state.prop.cor <- matrix(NA, nrow = num.states, ncol = 5)
colnames(full.state.prop.cor) <- c("r", "p.value", "slope.fit", "slope.lwr", "slope.upr")
for(state in 1:num.states){
    strain.state.prop <- t(sapply(chrom.state.props, 
    function(x) if(length(x) > 1){x[state,chrom.order]}else{rep(NA, 9)}))
    full.state.prop.cor[state,] <- plot.with.model(rankZ(as.vector(strain.state.prop)), 
        rankZ(as.vector(expr.mat)), confidence = 0.95, plot.results = FALSE)
}

ymin <- -0.05; ymax = 0.06
plot.new()
plot.window(xlim = c(1,num.states), ylim = c(ymin, ymax))
for(state in 1:nrow(full.state.prop.cor)){

    line.col <- state.col[state]

    points(x = state, y = full.state.prop.cor[state,"slope.fit"],
    col = line.col, cex = 1.5, pch = 16)

    segments(x0 = state, y0 = full.state.prop.cor[state,"slope.lwr"],
    y1 = full.state.prop.cor[state, "slope.upr"], lwd = 4, 
    col = line.col) #full range

    segments(x0 = state-0.2, x1 = state + 0.2, 
    y0 = full.state.prop.cor[state,"slope.upr"], lwd = 4, 
    col = line.col) #upper bound

    segments(x0 = state-0.2, x1 = state + 0.2, 
    y0 = full.state.prop.cor[state,"slope.lwr"], lwd = 4, 
    col = line.col) #lower bound

    }
abline(h = 0)
axis(2, at = round(seq(ymin, ymax, 0.02), 2))
par(xpd = TRUE)
text(x = 1:num.states, y = rep((ymin*1.1), num.states), labels = 1:num.states)
par(xpd = FALSE)
mtext(side = 2, "Effect", line = 2.5)
mtext(side = 3, "Across-Strain State Effects with 95% Confidence Intervals", line = 2.5)
```

```{r effect_fig}
quartz(width = 7, height = 5)
plot.new()
plot.window(ylim = c(1,num.states), xlim = c(ymin, ymax))
for(state in 1:nrow(full.state.prop.cor)){

    line.col <- state.col[state]

    points(y = state, x = full.state.prop.cor[state,"slope.fit"],
    col = line.col, cex = 1.5, pch = 16)

    segments(y0 = state, x0 = full.state.prop.cor[state,"slope.lwr"],
    x1 = full.state.prop.cor[state, "slope.upr"], lwd = 4, 
    col = line.col) #full range

    segments(y0 = state-0.2, y1 = state + 0.2, 
    x0 = full.state.prop.cor[state,"slope.upr"], lwd = 4, 
    col = line.col) #upper bound

    segments(y0 = state-0.2, y1 = state + 0.2, 
    x0 = full.state.prop.cor[state,"slope.lwr"], lwd = 4, 
    col = line.col) #lower bound

    }
abline(v = 0)
axis(1, at = round(seq(-0.6, 0.6, 0.02), 2))

```

## State Annotations

The heatmap below shows the emission probabilities for each state found by ChromHMM.
This shows us which marks each of the states in the barplot has.

```{r emissions, results = "asis"}
emissions.file <- file.path(data.dir, paste0("emissions_", num.states, ".png"))
cat("![](",emissions.file,")")
```

```{r emissions_fig, eval = FALSE}
emissions.mat <- read.delim(file.path(data.dir, paste0("emissions_", num.states, ".txt")), 
row.names = 1)
pdf("~/Desktop/emissions.pdf", width = 5, height = 2)
pheatmap(t(emissions.mat), cluster_rows = FALSE, cluster_cols = FALSE)
dev.off()
```

## Relative position of chromatin state

We were interested in whether each state was particularly enriched 
at any particular position in the genes. To address this, we 

To address this, we normalized the coordinates of each gene to run from 
0 at the TSS to 1 at the TES. Upstream coordinates were less than 0 and 
upstream coordinates were greater than 1. 

We then calculated the proportion of genes at each position that contained
each state. To avoid contamination of the up and downstream regions with 
regulatory regions from other genes, we selected only genes that were at 
least 2kb from any other gene. However, the pattern was the same even if 
we looked at all genes.

```{r align_states}
#scale the coordinates on all the chromatin matrices to put the 
#TSS at 0 and the TES at 1.

cent.chrom.file <- file.path(results.dir, "Chromatin.States.Gene.Coords.RDS")
if(!file.exists(cent.chrom.file)){
    cent.mats <- chrom.mats
    for(i in 1:length(chrom.mats)){
        report.progress(i, length(chrom.mats))
        gene.id <- names(chrom.mats)[i]
        gene.name <- unique(rnaseq.gene.info[which(rnaseq.gene.info[,"ensembl_gene_id"] == gene.id), "external_gene_name"])
        if(length(gene.name) > 0 && length(chrom.mats[[i]]) > 1){
            rownames(cent.mats[[i]]) <- names(center.on.feature(gene.name, rnaseq.gene.info, chrom.mats[[i]][,1], feature = "full"))
        }
    }
    saveRDS(cent.mats, cent.chrom.file)
}else{
    cent.mats <- readRDS(cent.chrom.file)
}


min.coord <- -1; max.coord <- 2; nbins = 500
binned.chromatin.file <- file.path(results.dir, "Chromatin.Matrices.Scaled.RDS")
if(!file.exists(binned.chromatin.file)){
    binned.chromatin <- lapply_pb(cent.mats, 
    function(x) if(length(x) > 1){bin.centered.chromatin(centered.chrom.mat = x, 
    coord.min = min.coord, coord.max = max.coord, nbins = nbins, nstates = num.states,
    tally.type = "present")}else{NA})
    saveRDS(binned.chromatin, binned.chromatin.file)
}else{
    binned.chromatin <- readRDS(binned.chromatin.file)
}
```

We wanted to look at whether we could discern spatial patterns to the presence
of different states.

```{r test_gene_sets, fig.width = 3, fig.height = 10}
#get scaled expression values for each gene
#the chromatin boundaries go 1000 bp beyond the end of the gene
#here we filter only to genes for which the nearest gene is no
#closer than 2000 bp away. This is to look at whether the 
#uptick in state 8 after the TSS is due to bleeding into the 
#next gene or related to the post-transcriptional region
far.position.file <- file.path(results.dir, "Chromatin.State.Position.Far.Genes.RDS")
if(!file.exists(far.position.file)){
    far.genes <- get.distant.genes(rnaseq.gene.info, 2000) 
    gene.ids <- rnaseq.gene.info[match(unlist(far.genes), rnaseq.gene.info[,"external_gene_name"]),"ensembl_gene_id"]
    state.position <- lapply(1:num.states, function(x) state.by.position(gene.ids, 
    group.gene.expr = scaled.mean.expr, state.id = x, binned.chrom = binned.chromatin))
    saveRDS(state.position, far.position.file)
}else{
    state.position <- readRDS(far.position.file)
}

#pdf("~/Desktop/chromatin_states_individual.pdf", width = 3, height = 9)
par(mfrow = c(num.states, 1), mar = c(2,2,2,2))
for(s in 1:length(state.position)){
    if(s == num.states){x.axis = TRUE}else{x.axis = FALSE}
    plot.state.by.position(state.position[[s]], error.type = "se", 
    plot.label = paste("State", s), col = state.col[s], x.axis = x.axis,
    xlim = c(-0.5, 1.5), ylim = NULL, idx = 2:length(state.position[[s]][[1]]), lwd = 4)
    abline(h = 0, col = "gray")
}
#dev.off()

```

```{r abundance_fig}
pdf(here("Documents", "3.Manuscript", "Figures", "chromatin_state_abundance.pdf"), width = 3, height = 10)
par(mfrow = c(num.states, 1), mar = c(0.5,3,0.5,2))
for(s in 1:length(state.position)){
    state.abundance <- state.position[[s]]$state.avg
    state.pos <- state.position[[s]]$position
    
    #trim
    idx <- intersect(which(state.pos >= -0.5), which(state.pos <= 1.5))
    state.abundance <- state.abundance[idx]
    state.pos <- state.pos[idx]

    max.abundance <- max(state.abundance, na.rm = TRUE)
    min.abundance <- min(state.abundance, na.rm = TRUE)
    abundance.range <- max.abundance - min.abundance

    ymin <- (min.abundance-(abundance.range*0.08))
    ymax <- (max.abundance + (abundance.range*0.08))

    plot(state.pos, state.abundance, type = "l", ylim = c(ymin, ymax), 
        col = state.col[s], xlim = c(-0.5, 1.5), lwd = 4, axes = FALSE)
    
    draw.rectangle(-0.57, 1.57, ymin, ymax, border.col = "gray80", lwd = 2)
    #axis(2)
    abline(v = c(0,1), col = "darkgray", lty = 2, lwd = 3)
    mtext(side = 2, paste("State", s), cex = 1.5, line = 0.5)
}
dev.off()
```

```{r states_together, fig.width = 8.5, fig.height = 5}
layout(matrix(c(1,2), ncol = 2), widths = c(1, 0.3))
plot.new()
plot.window(xlim = c(-0.5, 1.5), ylim = c(0,1))
if(num.states == 9){state.order = c(4,5,6,1,7,8,3,9)}else{state.order = 1:num.states}
for(s in state.order){ #ordered for ease of visualization
    plot.state.by.position(state.position[[s]], error.type = "se", 
    plot.label = "", col = state.col[s], add = TRUE, lwd = 4,
    idx = 2:length(state.position[[s]][[1]]))
}
axis(1);axis(2)
mtext("Relative Gene Position", side = 1, line = 2.5)
mtext("Proportion Genes State Present", side = 2, line = 2.5)
plot.new()
par(mar = c(4,0,4,0))
plot.window(xlim = c(0,1), ylim = c(0,1))
par(xpd = NA)
legend(x = 0, y = 1, pch = 16, col = state.col, 
legend = paste("State", 1:num.states))
par(xpd = TRUE)
#dev.off()
```

```{r together_fig}
pdf(here("Documents", "3.Manuscript", "Figures", "chromatin_states_together.pdf"), width = 7, height = 5)
plot.new()
plot.window(xlim = c(-0.5, 1.5), ylim = c(0,0.8))
if(num.states == 9){state.order = c(4,5,6,1,7,8,3,9)}else{state.order = 1:num.states}
for(s in state.order){ #ordered for ease of visualization
    plot.state.by.position(state.position[[s]], error.type = "se", 
    plot.label = "", col = state.col[s], add = TRUE, lwd = 4,
    idx = 2:length(state.position[[s]][[1]]), x.axis = FALSE)
}
axis(2, cex.axis = 2)
dev.off()
```


## Does relative position change the effect of chromatin state on expression?

We looked at correlations between expression and state abundance in a sliding
window along the gene body. 

The figure below shows the average correlation between expression across strains
and state proporion along sliding windows around gene bodies. The TSS is at 0, and
the TES is at 1. 

My general impressions are as follows:
States 1 and 2 generally suppress expression regardless of position, but do seem
to have stronger effects at positions near the TSS. 

State 7 generally enhances expression regardless of position, but does seem to have
a stronger effect as positionas near the TSS.

The presence of states 3 and 8 suppress expression primarily when they
are present at the TSS. Big swings upstream and downstream of the gene 
for state 3 are primarily due to small numbers of genes in those groups.

States 5 and 6 are moderately positively correlated with expresion when they
are present within the gene body.

State 4 has very little effect anywhere and is generally not associated with
differential expression.

Overall there is very little effect of any state on expression near the TES 
specifically.

```{r gene_coord_expr, fig.height = 9, fig.width = 9}
common.genes <- intersect(names(cent.mats), names(scaled.mean.expr))
#generate sliding windows each containing five normalized positions, 
#and overlapping by one position.
gene.windows <- sliding.window.el(seq(-0.15, 1.15, 0.015), 5, 2, plot.results = FALSE)
#length(gene.windows)
#sapply(gene.windows, mean)
#abline(v = c(0, 1))

#fit effects with 95% confidence interval
get_chromatin_window_prop <- function(chrom.mat, window.coord){
    if(length(chrom.mat) == 1){return(NA)}
    window.idx <- intersect(which(as.numeric(rownames(chrom.mat)) >= min(window.coord)),
    which(as.numeric(rownames(chrom.mat)) <= max(window.coord)))
    if(length(window.idx) == 0){return(NA)}
    sub.mat <- chrom.mat[window.idx,,drop=FALSE]
    prop.window <- apply(sub.mat, 2, function(x) sapply(1:num.states, function(state) length(which(x == state))/length(x)))
    rownames(prop.window) <- 1:num.states
    return(prop.window)
}

mean.expr.mat <- t(sapply(strain.mean.expr, 
    function(x) if(length(x) > 1){x}else{rep(NA, ncol(cent.mats[[1]]))}))
scaled.expr.mat <- t(sapply(scaled.mean.expr, 
    function(x) if(length(x) > 1){x}else{rep(NA, ncol(cent.mats[[1]]))}))
colnames(scaled.expr.mat) <- rownames(scaled.mean.expr[[1]])

across.strain.window.state.file <- file.path(results.dir, "State.Window.Effects.Across.Strains.RDS")
within.strain.window.state.file <- file.path(results.dir, "State.Window.Effects.Within.Strains.RDS")


if(!file.exists(across.strain.window.state.file)){
    across.strain.window.results <- vector(mode = "list", length = length(gene.windows))
    within.strain.window.results <- vector(mode = "list", length = length(gene.windows))

    for(w in 1:length(gene.windows)){
        if(is.interactive){cat("window", w, "\n")}
        #calculate the proportion of each state in the window
        chrom.window.prop <- lapply(cent.mats, 
            function(x) if(length(x) > 1){get_chromatin_window_prop(x[,chrom.order], 
            gene.windows[[w]])}else{NA})

        across.strain.state.effect <- within.strain.state.effect <- matrix(NA, nrow = num.states, ncol = 5)
        rownames(across.strain.state.effect) <- rownames(within.strain.state.effect) <- 1:num.states
        colnames(across.strain.state.effect) <- colnames(within.strain.state.effect) <- c("r", "p.value", "slope.fit", "slope.lwr", "slope.upr")

        all.within.strain.state.effects <- vector(mode = "list", length = num.states)

        #look at the effect of each chromatin state in this window on 
        #gene expression across strains.
        for(state in 1:num.states){
            if(is.interactive){cat("\tState", state, "\n")}
            window.state.mat <- t(sapply(chrom.window.prop, 
            function(x) if(length(x) > 1){x[state,]}else{rep(NA, ncol(cent.mats[[1]]))}))
           
            across.strain.state.effect[state,] <- plot.with.model(rankZ(as.vector(window.state.mat)), 
                rankZ(as.vector(scaled.expr.mat)), confidence = 0.95, plot.results = FALSE)
    
            within.strain.state.effect[state,] <- rowMeans(sapply(1:ncol(window.state.mat), 
                function(x) plot.with.model(rankZ(window.state.mat[,x]), 
                rankZ(mean.expr.mat[,x]), confidence = 0.95, plot.results = FALSE)))
        }
    
        across.strain.window.results[[w]] <- across.strain.state.effect
        within.strain.window.results[[w]] <- within.strain.state.effect

    }
    saveRDS(across.strain.window.results, across.strain.window.state.file)
    saveRDS(within.strain.window.results, within.strain.window.state.file)
}else{
    across.strain.window.results <- readRDS(across.strain.window.state.file)
    within.strain.window.results  <- readRDS(within.strain.window.state.file)
}

#plot the across-strain effects
window.mids <- sapply(gene.windows, max)
if(is.interactive){quartz(width = 9, height = 9)}
par(mfrow = c(3,3))
for(state in 1:num.states){
    state.effects <- sapply(across.strain.window.results, function(x) x[state,])
    min.effect <- min(state.effects["slope.lwr",])
    max.effect <- max(state.effects["slope.upr",])
    plot.new()
    plot.window(xlim = c(-0.1, 1.1), ylim = c(-0.1, 0.1))
    points(window.mids, state.effects["slope.fit",], col = state.col[state], type = "l")
    plot.poly.xy(window.mids, state.effects["slope.lwr",],
    window.mids, state.effects["slope.upr",], col = state.col[state])
    abline(h = 0)
    axis(1);axis(2)
    mtext(side = 2, "Effect", line = 2.5)
    mtext(side = 3, paste("State", state), line = 2.5)
    abline(v = c(0,1), lty = 2, col = "darkgray")
}
```

```{r across_strain_fig}
pdf(here("Documents", "3.Manuscript", "Figures", "chromatin_effects_across_strains.pdf"), 
width = 3, height = 10)
par(mfrow = c(num.states, 1), mar = c(0.5,3,0.5,2))
xmin = -0.2;xmax = 1.2;ymin = -0.065; ymax = 0.07
window.mids <- sapply(gene.windows, max)
for(state in 1:num.states){
    state.effects <- sapply(across.strain.window.results, function(x) x[state,])
    min.effect <- min(state.effects["slope.lwr",])
    max.effect <- max(state.effects["slope.upr",])
    plot.new()
    plot.window(xlim = c(xmin, xmax), ylim = c(ymin, ymax))
    points(window.mids, state.effects["slope.fit",], col = state.col[state], type = "l")
    plot.poly.xy(window.mids, state.effects["slope.lwr",],
    window.mids, state.effects["slope.upr",], col = state.col[state])
    segments(xmin, 0, xmax, col = "gray40", lwd = 2)
    mtext(side = 2, paste("State", state), cex = 1.5)
    abline(v = c(0,1), lty = 2, col = "darkgray", lwd = 2)
    draw.rectangle(xmin, xmax, ymin, ymax, border.col = "gray80", lwd = 2)
}
dev.off()
```

### Correlation by position within-strain {.tabset .tabset-fade .tabset-pills}

We also looked at a position-based correlation of gene expression with
chromatin state across genes within each strain.

```{r plot_within_strain, fig.width = 9, fig.height = 9}

#plot the across-strain effects
window.mids <- sapply(gene.windows, max)
if(is.interactive){quartz(width = 9, height = 9)}
par(mfrow = c(3,3))
for(state in 1:num.states){
    state.effects <- sapply(within.strain.window.results, function(x) x[state,])
    min.effect <- min(state.effects["slope.lwr",which(is.finite(state.effects["slope.lwr",]))])
    max.effect <- max(state.effects["slope.upr",which(is.finite(state.effects["slope.upr",]))])
    plot.new()
    plot.window(xlim = c(-0.1, 1.1), ylim = c(-0.8, 0.8))
    points(window.mids, state.effects["slope.fit",], col = state.col[state], type = "l")
    plot.poly.xy(window.mids, state.effects["slope.lwr",],
    window.mids, state.effects["slope.upr",], col = state.col[state])
    abline(h = 0)
    axis(1);axis(2)
    mtext(side = 2, "Effect", line = 2.5)
    mtext(side = 3, paste("State", state), line = 2.5)
    abline(v = c(0,1), lty = 2, col = "darkgray")
}

```


```{r within_strain_fig}
pdf(here("Documents", "3.Manuscript", "Figures", "chromatin_effects_within_strain.pdf"), 
width = 3, height = 10)
xmin = -0.2;xmax = 1.2;ymin = -0.65; ymax = 0.65
par(mfrow = c(num.states, 1), mar = c(0.5,3,0.5,2))
#plot the across-strain effects
window.mids <- sapply(gene.windows, max)
for(state in 1:num.states){
    state.effects <- sapply(within.strain.window.results, function(x) x[state,])
    min.effect <- min(state.effects["slope.lwr",which(is.finite(state.effects["slope.lwr",]))])
    max.effect <- max(state.effects["slope.upr",which(is.finite(state.effects["slope.upr",]))])
    plot.new()
    plot.window(xlim = c(xmin, xmax), ylim = c(ymin, ymax))
    points(window.mids, state.effects["slope.fit",], col = state.col[state], type = "l")
    plot.poly.xy(window.mids, state.effects["slope.lwr",],
    window.mids, state.effects["slope.upr",], col = state.col[state])
    segments(xmin, 0, xmax, col = "gray40", lwd = 2)
    mtext(side = 2, paste("State", state), cex = 1.5)
    abline(v = c(0,1), lty = 2, col = "darkgray", lwd = 2)
    draw.rectangle(xmin, xmax, ymin, ymax, border.col = "gray80", lwd = 2)
}
dev.off()
```

## Example of one Gene

A nice example shown below is Irf5 (Interferon regulatory factor 5).
CAST and PWK have very low expression and both have state 3 at the TSS. 
The other strains have much higher expression and all have state 7 at the 
TSS. State 7 elsewhere in the gene is also correlated with expression. 

```{r state_abundance, fig.width = 7, fig.height = 8, eval = FALSE}

chrom.mats <- readRDS(here("Results", "ChromHMM", "9_states_C", 
    "Chromatin_States_9_full_gene_1000.RData"))

#state ammount by strain
state.totals <- state.sd <- matrix(NA, nrow = 9, ncol = 9)
rownames(state.totals) <- 1:9
colnames(state.totals) <- colnames(chrom.mats[[1]])
for(st in 1:9){
    print(st)
    state.counts <- t(sapply(chrom.mats, function(x) if(length(x) > 1){apply(x, 2, function(y) length(which(y == st)))}else{rep(NA, 9)}))
    state.totals[st,] <- colSums(state.counts, na.rm = TRUE)
    state.totals[st,] <- state.totals[st,]/max(state.totals[st,])
}


for(st in 1:nrow(state.totals)){
    barplot(state.totals[st,], main = paste("Relative Abundance of State", st),
    col = col.table[match(colnames(state.totals), col.table[,6]),3])
}


```
