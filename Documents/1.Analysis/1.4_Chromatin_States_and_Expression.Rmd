---
title: "Analyzing ChromHMM Results"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction

The purpose of this workflow is to combine chromatin state data from 
a single chromHMM model and gene expression. This workflow takes a 
gene-based approach. It calculates the chromatin state composition of 
each gene and calculates correlations between the state composition and
gene expression.

This workflow generates data files that are used in downstream analyses and
performs the following specific tasks:

**Gene Expression**

1. Generate information file for RNA-Seq data.
    * produces file RNASeq\_gene\_info.RData
2. Average expression across individuals in a given strain.
    * produces file Strain\_Mean\_C\_Expression.RData
2. Filter out genes with low variance across strains.
    * no file is produced. Low-variance genes are replace with NA's.

**DO eQTL**

1. Extracts cis eQTL coefficients and writes to cis.coef.RData.

**Chromatin**

1. Create matrices of chromatin states for each transcript.
    * produces file with the pattern 
    Chromatin\_States\_num.states\_gene.type\_bp.buffer.RData
2. Create matrices of chromatin state proportions for each transcript.
    * produces a file with the pattern 
    Chromatin\_State\_num.states\_Prop\_gene.type\_bp.buffer.RData
3. Dimension reduces the proportion matrices using multi-dimensional scaling.
    * produces a file with the pattern 
    Chromatin\_State\_num.states\_MDS\_gene.type\_bp.buffer.RData
4. Exploration of states
    * Heatmap of state proportions across strains.

**Chromatin and Expression**

1. Correlate proportion of each chromatin state in each gene with gene expression.
    * produces file with the pattern
    State\_num.states\_Prop_\Expression\_Cor\_gene.type\_bp.buffer.RData
    *This file contains pearson correlation r values and p values.
2. Correlate MDS dimension-reduced chromatin proportion matrix with gene expression
    * produces file with the pattern
    State\_num.states\_MDS\_Expression\_Cor\_gene.type\_bp.buffer.RData
3. Explore examples
    Plots are generated for example genes showing where specific chromatin 
    states are correlated with gene expression across the strains.

```{r set_args}
args <- commandArgs(trailingOnly=T)
num.states <- as.numeric(args[1])
delete.previous = as.logical(args[2]) #whether to delete and regenerate files 
                    #from previous a run.
is.interactive = FALSE
#is.interactive = TRUE

if(is.na(delete.previous)){num.states = 14; delete.previous = FALSE}
```

```{r set_param}
library(here)
param <- read.delim(here("Data", "support_files", "param.txt"), header = FALSE, 
    stringsAsFactors = FALSE, row.names = 1)
#num.states = as.numeric(param["num_states",])
ordered.marks <- strsplit(param["ordered_marks",], ",")[[1]]
```

This document has figures pertaining to the `r num.states`-state model.

```{r source_code}
all.code.dir <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.code.dir)){
	all.fun <- list.files(all.code.dir[i], full.names = TRUE, pattern = ".R")
	for(j in 1:length(all.fun)){source(all.fun[j])}
}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
needed.packages <- c("VennDiagram", "ape", "gprofiler2", 
"e1071", "DESeq2", "knitr", "pheatmap", "hexbin", "RColorBrewer", "MASS", 
"gridExtra", "grid", "ggplotify", "qtl2", "caTools", "stringr")
load_libraries(needed.packages)
```


## Setup
Set the number of states to be analyzed, and the mark, if relevant.

```{r state_num}
selected.mark <- NULL #set to null to use all marks
#selected.mark <- "H3K4me1"
#selected.mark <- "H3K4me3"
#selected.mark <- "H3K27ac"
#selected.mark <- "H3K27me3"
```

Set up additional parameters for looking at states around gene bodies.
These are changeable, but will not change after the 

```{r set_boundaries}
start.feature = "start_position" #feature of gene to start from. start_position means TSS, and end_position means TES
end.feature = "end_position" #feature of gene to end at. start_position means TSS, and end_position means TES
upstream.buffer = 1000 #number of bp upstream to go from start.feature
downstream.buffer = 1000 #number of bp downstream to go from end.feature
T.or.C <- "C" #whether to analyze the control (C) or treatment (T) animals.
```

```{r setup_dir}
#data and results are a little bit mixed up, since results from one
#analysis can be data for another analysis. I try to keep processed
#data in data directories and final results in results directories.
#form.states <- paste0(formatC(num.states, digits = 2, flag = 0), "_states", selected.mark, "_", T.or.C)
form.states <- paste0(num.states, "_states", selected.mark, "_", T.or.C)
data.dir <- here("Data", "ChromHMM", form.states)
results.dir <- here("Results", "ChromHMM", form.states)
if(!file.exists(results.dir)){dir.create(results.dir)}
```

```{r results_files}
if(start.feature == "start_position" && end.feature == "start_position"){
    gene.text <- "TSS"
    }
if(start.feature == "start_position" && end.feature == "end_position"){
    gene.text <- "full_gene"
    }

buffer.text <- paste(unique(c(upstream.buffer, downstream.buffer)), collapse = "_")
```


Strain names between different analyses are inconsistent. We have a table for 
comparing different names as well as for defining strain colors. I made this
table by hand. Load it here:

```{r load_color_key}
key.file <- here("Data", "support_files", "strain.color.table.txt")
col.table <- as.matrix(read.table(key.file, sep = "\t", comment.char = "%", 
stringsAsFactors = FALSE))
```

## Expression Data

The expression data were processed in the Expression workflow. That workflow
performed the following. 
1. Filtered for genes with at least 5 reads in at least 20\% of animals
2. Performed vst on expression data.
All animals are female, so we do not need to do a correction for sex.

### Expression distribution across samples

```{r load_expression, fig.width = 7, fig.height = 7}
rna.seq.file <- here("Data", "RNASeq", "StrainsEffCts9_vst.RDS")
rna.seq <- readRDS(rna.seq.file)
#boxplot(rna.seq, las = 2)

col.order <- match.order(substr(colnames(rna.seq), 1, 2), col.table[,1], col.table)
if(is.interactive){quartz()}
expr.decomp <- plot.decomp(t(rna.seq), cols = col.table[col.order,3], pc = 5)
#quartz();plot.decomp(t(rna.seq), cols = col.table[col.order,3])
```

```{r gene_info}
#Get information about all expressed genes from BiomaRt:
gene.info.file <- here("Data", "RNASeq", "RNASeq_gene_info.RData")
all.var <- ls()
if(!file.exists(gene.info.file)){
    library(biomaRt) #only load this if we need to query it
    lib.loaded <- as.logical(length(which(all.var == "mus")))
    if(!lib.loaded){
        if(!file.exists(gene.info.file)){
            #mus <- useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl") #most current library
            #use this stable version because we need locations to be in mm10
            mus <- useEnsembl("ENSEMBL_MART_ENSEMBL", dataset = "mmusculus_gene_ensembl", 
            host = "may2017.archive.ensembl.org") #stable archived library
            }
        } 
    rnaseq.gene.info.comp <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", 
    "chromosome_name", "start_position", "end_position", "transcription_start_site", 
    "exon_chrom_start", "exon_chrom_end", "5_utr_start","5_utr_end","3_utr_start", 
    "3_utr_end", "strand"), 
    filters = "ensembl_gene_id", values = rownames(rna.seq), mart = mus)
    saveRDS(rnaseq.gene.info, gene.info.file)
}else{
    rnaseq.gene.info <- readRDS(gene.info.file)
}
```

Average expression across individuals in each strain.

```{r strain_expr}
#file containing strain averages for each transcript. These
#do not change from run to run. Save in data
strain.expr.file <- here("Data", "RNASeq", paste0("Strain_Mean_", T.or.C, "_Expression.RData"))
if(!file.exists(strain.expr.file)){
    #get expression for the condition (control or treatment)
    strain.mean.expr <- lapply(rownames(rna.seq), function(x) 
    get.cond.expr(rnaseq.gene.info, rna.seq, x, T.or.C = T.or.C, return.mean = TRUE))
    names(strain.mean.expr) <- rownames(rna.seq)
    #save the results
    saveRDS(strain.mean.expr, strain.expr.file)
}else{
    strain.mean.expr <- readRDS(strain.expr.file)
}

#also scale the expression for each gene.
strain.scaled.expr.file <- here("Data", "RNASeq", paste0("Strain_Scaled_", T.or.C, "_Expression.RData"))
if(!file.exists(strain.scaled.expr.file)){
    scaled.mean.expr  <- lapply(strain.mean.expr, scale)
    saveRDS(scaled.mean.expr, strain.scaled.expr.file)
}else{
    scaled.mean.expr <- readRDS(strain.scaled.expr.file)
}
```

### Expression Variation Filter

Because we are specifically interested in variance in expression across 
strains, we filtered the transcripts to include those that had a large amount
of variation across strains. We chose only those transcripts that had at least 
a minimum difference between the highest-expressing strain, and the 
lowest-expressing strain.

The plot below shows the distribution of the variance across strains 
with a vertical line indicating the threshold for selection.

```{r strain_expr_filter}
var.lim = 0.3
zero.expr <- rep(NA, 9)
names(zero.expr) <- names(strain.mean.expr[[1]])
strain.var <- sapply(strain.mean.expr, function(x) max(x) - min(x))
strain.sd <- sapply(strain.mean.expr, function(x) sd(x))
if(is.interactive){quartz()}
hist(strain.var, breaks = 100)
abline(v = var.lim, col = "red", lwd = 2)

low.var <- which(strain.var < var.lim)
if(length(low.var) > 0){
    for(i in 1:length(low.var)){
        strain.mean.expr[[low.var[i]]] <- zero.expr
    }
}

still.used <- length(which(sapply(strain.mean.expr, function(x) !all(is.na(x)))))
```

We removed `r length(low.var)` genes with across-strain variance lower than
`r var.lim`. This leaves a total of `r still.used` transcripts for analysis.


## ChromHMM Output Processing
We analyzed the chromatin states based on states output by ChromHMM. 
See analysis 1.ChromHMM.Rmd. This analysis looks at the output from the model with
`r num.states` states.


```{r load_bed}
#Load the ChromHMM bed files for all strains:
bed.files <- list.files(data.dir, pattern = "dense.bed", full.names = TRUE)
strains <- substr(colnames(rna.seq), 1,2)
strain.names <- sort(unique(strains))
strain.bed.names <- sapply(strsplit(basename(bed.files), "_"), function(x) x[1])

#Naming conventions between data sets are inconsistent.
#make a key by hand for conversion
if(T.or.C == "C"){
    strain.key <- cbind(strain.bed.names, c(strain.names[8], strain.names[-8]))
}else{
    strain.match <- match(strain.bed.names, strains)
    strain.key <- cbind(strain.bed.names, strains[strain.match])
}

all.bed <- vector(mode = "list", length = nrow(strain.key))
names(all.bed) <- strain.key[,1]
for(i in 1:nrow(strain.key)){
    bed.locale <- grep(pattern = strain.bed.names[i], bed.files)[1]
    if(!is.na(bed.locale) > 0){
        all.bed[[i]] <- read.table(bed.files[bed.locale], sep = "\t", skip = 1, 
        stringsAsFactors = FALSE)
    }
}
```


## Genome percentage of each state

The following plot shows the percentage of the genome that each state covers.

```{r percentage_genome, fig.width = 5, fig.height = 4}
state.percent.mat <- matrix(NA, nrow = num.states, ncol = length(all.bed))
rownames(state.percent.mat) <- 1:num.states
colnames(state.percent.mat) <- names(all.bed)

calc_total <- function(bed.table){
    chr <- unique(bed.table[,1])
    chr.min <- sapply(chr, function(x) min(bed.table[which(bed.table[,1] == x),2]))
    chr.max <- sapply(chr, function(x) max(bed.table[which(bed.table[,1] == x),2]))
    chr.len <- chr.max - chr.min
    return(sum(chr.len))
}

calc_state <- function(bed.table, state){
    state.locale <- which(bed.table[,4] == state)
    state.start <- bed.table[state.locale,2]
    state.end <- bed.table[state.locale,3]    
    state.coverage <- state.end - state.start
    return(sum(state.coverage))
}

total.length <- sapply(all.bed, calc_total)
for(state in 1:num.states){
    total.count <- sapply(all.bed, function(x) calc_state(x, state))
    state.percent.mat[state,] <- (total.count/total.length)*100
}
barplot(t(state.percent.mat), beside = TRUE, col = col.table[,3], ylab = "Percent Genome",
xlab = "State")
saveRDS(state.percent.mat, file.path(results.dir, "State.Genome.Percent.RDS"))
```


## Chromatin states by gene
The first step in this analysis is to create matrices of chromatin states for each 
transcript. In this step, we go through all transcripts in the RNA Seq data set. 
For each transcript, we get the ChromHMM states around the gene body or transcription 
start site as defined by the parameters at the top of this file. The states across 
all strains are combined into a single matrix.

```{r get_chrom_states, warning = FALSE}
#This chunk takes about 3 hours to run depending 
#on the number of genes in the filtered expression 
#table.
#file containing chromatin states in and around each transcript
chrom.state.file <- file.path(results.dir, 
paste0("Chromatin_States_", num.states, "_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(chrom.state.file)){
    #get the states around each transcript across all strains
	chrom.mats <- lapply(rownames(rna.seq), function(x) get.chrom.state(bed.info = all.bed, 
    rnaseq.gene.info, rna.seq, x, start.feature, end.feature, upstream.buffer, 
    downstream.buffer))
	names(chrom.mats) <- rownames(rna.seq)
	saveRDS(chrom.mats, chrom.state.file)
}else{
    chrom.mats <- readRDS(chrom.state.file)
}

#file containing proportions of each chromatin state in and around each transcript
chrom.prop.file <- file.path(results.dir,
paste0("Chromatin_State_", num.states, "_Prop_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(chrom.prop.file)){
	chrom.state.props <- get.chrom.state.prop(chrom.mats, num.states = num.states, verbose = FALSE)
	names(chrom.state.props) <- rownames(rna.seq)
	saveRDS(chrom.state.props, chrom.prop.file)
}else{
    chrom.state.props <- readRDS(chrom.prop.file)
}

#file containing the one-dimensional reduction of each chromatin state matrix
chrom.mds.file <- file.path(results.dir,
paste0("Chromatin_State_", num.states, "_MDS_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(chrom.mds.file)){
    chrom.mds <- get.scaled.chrom.mats(chrom.mats, 1)
    saveRDS(chrom.mds, chrom.mds.file)
}else{
    chrom.mds <- readRDS(chrom.mds.file)
}
```

## Chromatin state and expression within strain

We looked across genes within strain to see if individual states were
associated with highly expressed genes and lowly expressed genes.

The following plot shows the overall correlations between TPM and proportion
of chromatin state across the gene within each strain.

Presence of states 7 and 5 is correlated with highly expressed genes,
whereas the presence of states 1 and 2 is correlated
with lowly expressed genes.

```{r within_strain}
has.expr <- which(sapply(strain.mean.expr, length) == 9)
has.chrom <- which(sapply(chrom.state.props, length) > 1)
common.genes <- intersect(names(strain.mean.expr)[has.expr], names(chrom.state.props)[has.chrom])
common.expr.locale <- match(common.genes, names(strain.mean.expr))
common.chrom.locale <- match(common.genes, names(chrom.state.props))
chrom.order <- match.order(names(strain.mean.expr[[1]]), colnames(chrom.state.props[[1]]), col.table)

all.state.conf <- matrix(NA, nrow = num.states, ncol = 5)
colnames(all.state.conf) <- c("r", "p.value", "slope.fit", "slope.lwr", "slope.upr")
rownames(all.state.conf) <- 1:num.states

strain.expr.mat <- t(sapply(strain.mean.expr[common.expr.locale], function(x) x))
```


```{r multi, eval = FALSE}
#normalize state proportions and concatenate for all strains
#use strain as a random effect and fit all state effects
#at the same time.
lin.expr <- as.vector(apply(strain.expr.mat, 2, rankZ)) #linearize the expression matrix, normalizing within each strain
lin.strain.label <- as.factor(rep(colnames(strain.expr.mat), each = nrow(strain.expr.mat))) #linearize the strain labels for random effects

multi.state.mat <- matrix(NA, ncol = num.states, nrow = length(lin.expr))
colnames(multi.state.mat) <- paste0("State", 1:ncol(multi.state.mat))
for(state in 1:num.states){    
    strain.chrom.mat <- t(sapply(chrom.state.props[common.chrom.locale], 
    function(x) x[state,chrom.order]))
    lin.strain <- as.vector(apply(strain.chrom.mat, 2, rankZ)) #linearize the state matrix, normalizing within each strain
    multi.state.mat[,state] <- lin.strain
}

library(lme4)
#library(lmerTest)
full.mat <- data.frame(lin.strain.label,lin.expr, multi.state.mat)
colnames(full.mat)[1:2] <- c("Strain", "Expression")

#fmla <- paste("Expression ~", paste(colnames(multi.state.mat), collapse = " + "), " + (1|Strain)")
#model <- lmer(as.formula(fmla), data = full.mat)
#coef.model <- as.matrix(coef(model)[[1]])
#barplot(coef.model[1,2:ncol(coef.model)], las = 2)

fmla <- paste("Expression ~", paste(colnames(multi.state.mat), collapse = " + "))
model <- lm(as.formula(fmla), data = full.mat)
model.coef <- summary(model)$coefficients
t.crit <- qt(p = 0.05/num.states, df = nrow(multi.state.mat)-1, lower.tail = FALSE)
ci.high <- model.coef[,"Estimate"] + (t.crit*model.coef[,"Std. Error"])
ci.low <- model.coef[,"Estimate"] - (t.crit*model.coef[,"Std. Error"])

ymin <- -0.2;ymax = 0.4
state.col <- read.table(here("Data", "support_files", "state_colors.txt"), comment.char = "!")[,1]
#barplot(1:length(state.col), col = state.col)
conf.lwr <- min(ci.low)
conf.upr <- max(ci.high)
if(is.interactive){quartz(width = 7, height = 5)}
plot.new()
plot.window(xlim = c(1, num.states), ylim = c(ymin, ymax))
#add grid lines
abline(v = 1:num.states, h = seq(-0.6, 0.6, 0.2), col = "gray80")
for(state in 1:num.states){
    line.col <- state.col[state]
    points(state, model.coef[state+1,"Estimate"], pch = 16, col = line.col, cex = 1.5)
    segments(x0 = state-0.2, x1 = state+0.2, y0 = ci.low[state+1],
        col = line.col, lwd = 4) #lower confidence interval
    segments(x0 = state-0.2, x1 = state+0.2, y0 = ci.high[state+1],
        col = line.col, lwd = 4) #upper confidence interval
    segments(x0 = state, y0 = ci.low[state+1], 
        y1 = ci.high[state+1], col = line.col, lwd = 4) #vertical bar
}
abline(h = 0)
axis(2, at = round(seq(ymin, ymax, 0.2), 1))
par(xpd = TRUE)
text(x = 1:num.states, y = rep((ymin*1.1), num.states), labels = 1:num.states)
par(xpd = FALSE)
mtext(side = 2, "Effect", line = 2.5)
mtext(side = 3, "Within-Strain State Effects with 95% Confidence Intervals", line = 2.5)

all.state.conf <- cbind(model.coef[2:nrow(model.coef),c(1,4, 1)], ci.low[2:length(ci.low)], ci.high[2:length(ci.low)])
colnames(all.state.conf) <- c("r", "p.value", "slope.fit", "slope.lwr", "slope.upr")
saveRDS(all.state.conf, file.path(results.dir, "State.Effects.Within.Strain.RDS"))

```

```{r simple}
#or test each state individually
#the marginal tests are almost identical to the multiple regression,
#except for the state with all marks, which reverses sign. It is a 
#rare state that is correlated with suppressing states. It's marginal 
#effect is negative, but in the multiple regression it appears to have
#a huge positive effect. We feel that this is misrepresentative of the 
#effect of the state and we are thus going to use the marginal effects
#from the simple regression.

for(state in 1:num.states){    
    strain.chrom.mat <- t(sapply(chrom.state.props[common.chrom.locale], 
    function(x) x[state,chrom.order]))
    conf.by.strain <- sapply(1:ncol(strain.chrom.mat), 
        function(x) plot.with.model(rankZ(strain.chrom.mat[,x]), 
        rankZ(strain.expr.mat[,x]), confidence = 0.95, plot.result = FALSE))
    all.state.conf[state,] <- rowMeans(conf.by.strain)
}

ymin <- -0.6;ymax = 0.6
state.col <- read.table(here("Data", "support_files", "state_colors.txt"), comment.char = "!")[,1]
#barplot(1:length(state.col), col = state.col)
conf.lwr <- min(all.state.conf[,"slope.lwr"])
conf.upr <- max(all.state.conf[,"slope.upr"])
if(is.interactive){quartz(width = 7, height = 5)}
plot.new()
plot.window(xlim = c(1, num.states), ylim = c(ymin, ymax))
#add grid lines
abline(v = 1:num.states, h = seq(-0.6, 0.6, 0.2), col = "gray80")
for(state in 1:num.states){
    line.col <- state.col[state]
    points(state, all.state.conf[state,"slope.fit"], pch = 16, col = line.col, cex = 1.5)
    segments(x0 = state-0.2, x1 = state+0.2, y0 = all.state.conf[state,"slope.lwr"],
        col = line.col, lwd = 4) #lower confidence interval
    segments(x0 = state-0.2, x1 = state+0.2, y0 = all.state.conf[state,"slope.upr"],
        col = line.col, lwd = 4) #upper confidence interval
    segments(x0 = state, y0 = all.state.conf[state,"slope.lwr"], 
        y1 = all.state.conf[state,"slope.upr"], col = line.col, lwd = 4) #vertical bar
}
abline(h = 0)
axis(2, at = round(seq(ymin, ymax, 0.2), 1))
par(xpd = TRUE)
text(x = 1:num.states, y = rep((ymin*1.1), num.states), labels = 1:num.states)
par(xpd = FALSE)
mtext(side = 2, "Effect", line = 2.5)
mtext(side = 3, "Within-Strain State Effects with 95% Confidence Intervals", line = 2.5)

saveRDS(all.state.conf, file.path(results.dir, "State.Effects.Within.Strain.RDS"))
```

## Effect of Chromatin State on Expression Across Strains
We also wanted to see if differential expression across strains 
could be explained, at least in part, by chromatin state. 

To investigate this, we scaled the expression of all transcripts
across strains. We then correlated the proportion of each state
with expression across all transcripts. 

The figure below shows the 95\% confidence intervals around the 
effect size of each state.

```{r states_and_expression}
expr.mat <- t(sapply(scaled.mean.expr, function(x) if(length(x) > 1){x[,1]}else{rep(NA, 9)}))
full.state.prop.cor <- matrix(NA, nrow = num.states, ncol = 5)
colnames(full.state.prop.cor) <- c("r", "p.value", "slope.fit", "slope.lwr", "slope.upr")
for(state in 1:num.states){
    strain.state.prop <- t(sapply(chrom.state.props, 
    function(x) if(length(x) > 1){x[state,chrom.order]}else{rep(NA, 9)}))
    scaled.state.prop <- t(apply(strain.state.prop, 1, scale))
    #identical(rownames(strain.state.prop), rownames(expr.mat))
    full.state.prop.cor[state,] <- plot.with.model(rankZ(as.vector(scaled.state.prop)), 
        rankZ(as.vector(expr.mat)), confidence = 0.95, plot.results = FALSE)
}

ylim <- get_plot_bounds(min(full.state.prop.cor[,"slope.lwr"]), 
    max(full.state.prop.cor[,"slope.lwr"]), scale.factor = 100,
    return.even = TRUE, center = TRUE)
ymin <- ylim[1]; ymax = ylim[2]
plot.new()
plot.window(xlim = c(1,num.states), ylim = c(ymin, ymax))
for(state in 1:nrow(full.state.prop.cor)){

    line.col <- state.col[state]

    points(x = state, y = full.state.prop.cor[state,"slope.fit"],
    col = line.col, cex = 1.5, pch = 16)

    segments(x0 = state, y0 = full.state.prop.cor[state,"slope.lwr"],
    y1 = full.state.prop.cor[state, "slope.upr"], lwd = 4, 
    col = line.col) #full range

    segments(x0 = state-0.2, x1 = state + 0.2, 
    y0 = full.state.prop.cor[state,"slope.upr"], lwd = 4, 
    col = line.col) #upper bound

    segments(x0 = state-0.2, x1 = state + 0.2, 
    y0 = full.state.prop.cor[state,"slope.lwr"], lwd = 4, 
    col = line.col) #lower bound

    }
abline(h = 0)
axis(2, at = round(seq(ymin, ymax, 0.02), 2))
par(xpd = TRUE)
text(x = 1:num.states, y = rep((ymin*1.1), num.states), labels = 1:num.states)
par(xpd = FALSE)
mtext(side = 2, "Effect", line = 2.5)
mtext(side = 3, "Across-Strain State Effects with 95% Confidence Intervals", line = 2.5)

saveRDS(full.state.prop.cor, file.path(results.dir, "State.Effects.Across.Strain.RDS"))
```


## State Annotations

The heatmap below shows the emission probabilities for each state found by ChromHMM.
This shows us which marks each of the states in the barplot has.

```{r emissions_fig, fig.height = 7, fig.width = 2.5}
emissions.mat <- read.delim(file.path(data.dir, paste0("emissions_", num.states, ".txt")), 
row.names = 1)
emission.order <- match(ordered.marks, colnames(emissions.mat))
#pdf("~/Desktop/emissions.pdf", width = 2.5, height = 7)
pheatmap(emissions.mat[,emission.order], cluster_rows = FALSE, cluster_cols = FALSE)
#dev.off()
```

## Relative position of chromatin state

We were interested in whether each state was particularly enriched 
at any particular position in the genes. To address this, we 

To address this, we normalized the coordinates of each gene to run from 
0 at the TSS to 1 at the TES. Upstream coordinates were less than 0 and 
upstream coordinates were greater than 1. 

We then calculated the proportion of genes at each position that contained
each state. To avoid contamination of the up and downstream regions with 
regulatory regions from other genes, we selected only genes that were at 
least 2kb from any other gene. However, the pattern was the same even if 
we looked at all genes.

```{r align_states}
#scale the coordinates on all the chromatin matrices to put the 
#TSS at 0 and the TES at 1.

cent.chrom.file <- file.path(results.dir, "Chromatin.States.Gene.Coords.RDS")
if(!file.exists(cent.chrom.file)){
    cent.mats <- chrom.mats
    for(i in 1:length(chrom.mats)){
        report.progress(i, length(chrom.mats))
        gene.id <- names(chrom.mats)[i]
        gene.name <- unique(rnaseq.gene.info[which(rnaseq.gene.info[,"ensembl_gene_id"] == gene.id), "external_gene_name"])
        if(length(gene.name) > 0 && length(chrom.mats[[i]]) > 1){
            rownames(cent.mats[[i]]) <- names(center.on.feature(gene.name, rnaseq.gene.info, chrom.mats[[i]][,1], feature = "full"))
        }
    }
    saveRDS(cent.mats, cent.chrom.file)
}else{
    cent.mats <- readRDS(cent.chrom.file)
}


min.coord <- -0.5; max.coord <- 1.5; nbins = 42
binned.chromatin.file <- file.path(results.dir, "Chromatin.Matrices.Scaled.RDS")
if(!file.exists(binned.chromatin.file) || delete.previous){
    binned.chromatin <- lapply_pb(cent.mats, 
    function(x) if(length(x) > 1){bin.centered.chromatin(centered.chrom.mat = x, 
    coord.min = min.coord, coord.max = max.coord, nbins = nbins, nstates = num.states,
    tally.type = "present")}else{NA})
    saveRDS(binned.chromatin, binned.chromatin.file)
}else{
    binned.chromatin <- readRDS(binned.chromatin.file)
}
```

We wanted to look at whether we could discern spatial patterns to the presence
of different states.

```{r test_gene_sets, fig.width = 9, fig.height = 9}
#get scaled expression values for each gene
#the chromatin boundaries go 1000 bp beyond the end of the gene
#here we filter only to genes for which the nearest gene is no
#closer than 2000 bp away. This is to look at whether the 
#uptick in state 8 after the TSS is due to bleeding into the 
#next gene or related to the post-transcriptional region
stop()
far.position.file <- file.path(results.dir, "Chromatin.State.Position.Far.Genes.RDS")
if(!file.exists(far.position.file) || delete.previous){
    far.genes <- get.distant.genes(rnaseq.gene.info, 2000) 
    gene.ids <- rnaseq.gene.info[match(unlist(far.genes), rnaseq.gene.info[,"external_gene_name"]),"ensembl_gene_id"]
    state.position <- lapply_pb(1:num.states, function(x) state.by.position(gene.ids, 
    group.gene.expr = scaled.mean.expr, state.id = x, binned.chrom = binned.chromatin))
    saveRDS(state.position, far.position.file)
}else{
    state.position <- readRDS(far.position.file)
}

#pdf("~/Desktop/chromatin_states_individual.pdf", width = 3, height = num.states*2)
#par(mfrow = c(num.states, 1), mar = c(2,2,2,2))
par(mfrow = c(3,3), mar = c(2,2,2,2))
max.abundance <- rep(NA, num.states)
for(s in 1:length(state.position)){
    if(s == num.states){x.axis = TRUE}else{x.axis = FALSE}
    plot.state.by.position(state.position[[s]], error.type = "se", 
    plot.label = paste("State", s), col = state.col[s], x.axis = x.axis,
    xlim = c(-0.5, 1.5), ylim = NULL, idx = 2:length(state.position[[s]][[1]]), lwd = 4)
    abline(h = 0, col = "gray")
    axis(2)
    max.abundance[s] <- max(state.position[[s]]$state.avg, na.rm = TRUE)
}
#dev.off()
```


## Enrichment by state and position

We also wanted to see if there were differential functional enrichments
of the genes across these areas of abundance. The following code generates
plots that show the negative log of enrichment p values as they were found
along the gene body for each state. Colors indicate the strain in which the
enrichments were found at each position. 

In some cases, the enrichments are fairly evenly split across the strains, 
and in others, there's a big skew toward one strain. For example in state
5 (in the 14-state model), most of the enrichments are associated with PWK.
Does this suggest that PWK is using state 5 differently than the other strains?
The enrichments are all related to insulin and pheromone binding. In contrast,
right around the TSS in this same state, the strains are all much more evenly
represented

```{r bin_enrich, eval = FALSE}
bin.enrich <- vector(mode = "list", length = num.states)
names(bin.enrich) <- 1:num.states
pdf(file.path(results.dir, "Enrichments.by.state.and.position.pdf"), width = 20, height = 7)
for(state in 1:num.states){
    if(is.interactive){print(state)}
    bin.enrich[[state]] <- state_peak_genes(binned.chromatin.states = binned.chromatin, 
    state.id = state, min.n = 10, 
    enrich.filename = file.path(results.dir, paste0("State.", state, ".by.Position.Enrichment.RDS")), 
    gene.filename = file.path(results.dir, paste0("State.", state, ".by.Position.Gene.RDS")),
    max.term.size = 2000, n.terms = 5, sort.by = "default")
}
dev.off()
```


The following figures show functional enrichments for groups of genes 
with each state present at each position. There are clear groupings
of enrichments at different positions.

```{r plot_bin_enrich, results = "asis", fig.height = 15, fig.width = 8, eval = FALSE}
#pdf("~/Desktop/State.enrichment.pdf", width = 8, height = 15)
for(state in 1:num.states){
    cat("State", state, "\n")
    enrich.mat <- bin.enrich[[state]]$enrichment.by.position
    pheatmap(sqrt(enrich.mat), cluster_cols = FALSE)
    cat("\n\n")
}
#dev.off()

#state = 12; use.pos = 13:16;filename="unknown.state" #unknown state with consistent, unintuitive effect, use just downstream of TSS
#state = 13; use.pos = 10:12;filename="poised.enhancer" #poised enhancer, use right around TSS
#state = 1; use.pos = 11:12;filename="bivalent.promoter" #bivalend promoter, use right around TSS
#state = 8; use.pos = 12:26;filename="intragenic.enhancer"
#state.genes <- bin.enrich[[state]]$genes.by.position
#gene.count <- bin.enrich[[state]]$gene.counts
#rownames(gene.count) <- round(as.numeric(rownames(gene.count)), 2)
#gene.prop <- t(apply(gene.count, 1, function(x) x/sum(x)))
#barplot(t(gene.prop), beside = TRUE, las = 2, col = col.table[,3], main = filename)
#test.mat <- jaccard.matrix(state.genes)
#diag(test.mat) <- NA
#pheatmap(test.mat) #look at how commonality of genes marked at different regions 
#test.genes <- state.genes[use.pos] 
#pheatmap(bin.enrich[[state]]$enrichment.by.position, cluster_cols = FALSE)
#plotVenn(test.genes)
#test.query <- Reduce("intersect", test.genes)#common genes across windows
#test.query <- unique(unlist(test.genes)) #all genes across windows
#length(test.query)
#test <- gost(test.query, organism = "mmusculus") 
#plot.enrichment(test)
#pdf(file.path("~", "Desktop", paste0("enrichment.", filename, ".pdf")));plot.enrichment.wordcloud(test, num.terms = 30);dev.off()
```

## Abundance by position

The following barplot shows the maximum abundance of each state
across all bins.

```{r total_abundance, fig.width = 8, fig.height = 5}
par(mar = c(3,3,2,3))
barplot_with_num(values = round(max.abundance, 2), col = state.col, names = 1:num.states, text.shift = 0.03)
#save for use in comparison figures
saveRDS(max.abundance, file.path(results.dir, "State_Abundance.RDS"))
```

```{r states_together, fig.width = 8.5, fig.height = 7}
layout(matrix(c(1,2), ncol = 2), widths = c(1, 0.3))
plot.new()
plot.window(xlim = c(-0.5, 1.5), ylim = c(0,0.8))
if(num.states == 9){state.order <- c(4,5,6,1,7,2,8,3,9)}else{state.order = 1:num.states}
for(s in state.order){ #ordered for ease of visualization
    plot.state.by.position(state.position[[s]], error.type = "se", 
    plot.label = "", col = state.col[s], add = TRUE, lwd = 4,
    idx = 2:length(state.position[[s]][[1]]))
}
axis(1);axis(2)
mtext("Relative Gene Position", side = 1, line = 2.5)
mtext("Proportion Genes State Present", side = 2, line = 2.5)
plot.new()
par(mar = c(4,0,4,0))
plot.window(xlim = c(0,1), ylim = c(0,1))
par(xpd = NA)
legend(x = 0, y = 1, pch = 16, col = state.col, 
legend = paste("State", 1:num.states))
par(xpd = TRUE)
#dev.off()
```

## Does relative position change the effect of chromatin state on expression?

We looked at correlations between expression and state abundance in a sliding
window along the gene body. 

The figure below shows the average correlation between expression across strains
and state proporion along sliding windows around gene bodies. The TSS is at 0, and
the TES is at 1. 

My general impressions are as follows:
States 1 and 2 generally suppress expression regardless of position, but do seem
to have stronger effects at positions near the TSS. 

State 7 generally enhances expression regardless of position, but does seem to have
a stronger effect as positionas near the TSS.

The presence of states 3 and 8 suppress expression primarily when they
are present at the TSS. Big swings upstream and downstream of the gene 
for state 3 are primarily due to small numbers of genes in those groups.

States 5 and 6 are moderately positively correlated with expresion when they
are present within the gene body.

State 4 has very little effect anywhere and is generally not associated with
differential expression.

Overall there is very little effect of any state on expression near the TES 
specifically.

```{r gene_coord_expr, fig.height = 9, fig.width = 9}

common.genes <- intersect(names(cent.mats), names(scaled.mean.expr))
#generate sliding windows each containing five normalized positions, 
#and overlapping by one position.
gene.windows <- sliding.window.el(seq(-0.15, 1.15, 0.015), 5, 2, plot.results = FALSE)
saveRDS(gene.windows, here("Data", "support_files", "gene_windows.RDS"))
#length(gene.windows)
#sapply(gene.windows, mean)
#abline(v = c(0, 1))

#fit effects with 95% confidence interval
get_chromatin_window_prop <- function(chrom.mat, window.coord){
    if(length(chrom.mat) == 1){return(NA)}
    window.idx <- intersect(which(as.numeric(rownames(chrom.mat)) >= min(window.coord)),
    which(as.numeric(rownames(chrom.mat)) <= max(window.coord)))
    if(length(window.idx) == 0){return(NA)}
    sub.mat <- chrom.mat[window.idx,,drop=FALSE]
    prop.window <- apply(sub.mat, 2, function(x) sapply(1:num.states, function(state) length(which(x == state))/length(x)))
    rownames(prop.window) <- 1:num.states
    return(prop.window)
}

mean.expr.mat <- t(sapply(strain.mean.expr, 
    function(x) if(length(x) > 1){x}else{rep(NA, ncol(cent.mats[[1]]))}))
scaled.expr.mat <- t(sapply(scaled.mean.expr, 
    function(x) if(length(x) > 1){x}else{rep(NA, ncol(cent.mats[[1]]))}))
colnames(scaled.expr.mat) <- rownames(scaled.mean.expr[[1]])

across.strain.window.state.file <- file.path(results.dir, "State.Window.Effects.Across.Strains.RDS")
within.strain.window.state.file <- file.path(results.dir, "State.Window.Effects.Within.Strains.RDS")

if(!file.exists(across.strain.window.state.file) || delete.previous){
    across.strain.window.results <- vector(mode = "list", length = length(gene.windows))
    within.strain.window.results <- vector(mode = "list", length = length(gene.windows))

    for(w in 1:length(gene.windows)){
        if(is.interactive){cat("window", w, "\n")}
        #calculate the proportion of each state in the window
        chrom.window.prop <- lapply(cent.mats, 
            function(x) if(length(x) > 1){get_chromatin_window_prop(x[,chrom.order], 
            gene.windows[[w]])}else{NA})

        across.strain.state.effect <- within.strain.state.effect <- matrix(NA, nrow = num.states, ncol = 5)
        rownames(across.strain.state.effect) <- rownames(within.strain.state.effect) <- 1:num.states
        colnames(across.strain.state.effect) <- colnames(within.strain.state.effect) <- c("r", "p.value", "slope.fit", "slope.lwr", "slope.upr")

        all.within.strain.state.effects <- vector(mode = "list", length = num.states)

        #look at the effect of each chromatin state in this window on 
        #gene expression across strains.
        for(state in 1:num.states){
            if(is.interactive){cat("\tState", state, "\n")}
            window.state.mat <- t(sapply(chrom.window.prop, 
            function(x) if(length(x) > 1){x[state,]}else{rep(NA, ncol(cent.mats[[1]]))}))
           
            across.strain.state.effect[state,] <- plot.with.model(rankZ(as.vector(window.state.mat)), 
                rankZ(as.vector(scaled.expr.mat)), confidence = 0.95, plot.results = FALSE)
                #plot.with.model(rankZ(as.vector(window.state.mat)), rankZ(as.vector(scaled.expr.mat)), confidence = 0.95)

            has.vals <- which(apply(window.state.mat, 2, function(x) length(unique(x[which(!is.na(x))]))) > 1)
            within.strain.state.effect[state,] <- rowMeans(sapply(has.vals, 
                function(x) plot.with.model(rankZ(window.state.mat[,x]), 
                rankZ(mean.expr.mat[,x]), confidence = 0.95, plot.results = FALSE)))
                #i = 3
                #plot.with.model(rankZ(window.state.mat[,i]), rankZ(mean.expr.mat[,i]), confidence = 0.95)
        }
        #barplot(rbind(within.strain.state.effect[,3], across.strain.state.effect[,3]), beside = TRUE)
        #barplot(within.strain.state.effect[,3], col = state.col)
        #barplot(across.strain.state.effect[,3], col = state.col)
    
        across.strain.window.results[[w]] <- across.strain.state.effect
        within.strain.window.results[[w]] <- within.strain.state.effect

    }
    saveRDS(across.strain.window.results, across.strain.window.state.file)
    saveRDS(within.strain.window.results, within.strain.window.state.file)
}else{
    across.strain.window.results <- readRDS(across.strain.window.state.file)
    within.strain.window.results  <- readRDS(within.strain.window.state.file)
}
```

```{r plot_window_across_strain, fig.height = 9, fig.width = 9}
#plot the across-strain effects
window.mids <- sapply(gene.windows, max)
if(is.interactive){quartz(width = 9, height = 9)}
par(mfrow = c(3,3))
for(state in 1:num.states){
    state.effects <- sapply(across.strain.window.results, function(x) x[state,])
    min.effect <- min(state.effects["slope.lwr",])
    max.effect <- max(state.effects["slope.upr",])
    plot.new()
    plot.window(xlim = c(-0.1, 1.1), ylim = c(-0.1, 0.1))
    points(window.mids, state.effects["slope.fit",], col = state.col[state], type = "l")
    plot.poly.xy(window.mids, state.effects["slope.lwr",],
    window.mids, state.effects["slope.upr",], col = state.col[state])
    abline(h = 0)
    axis(1);axis(2)
    mtext(side = 2, "Effect", line = 2.5)
    mtext(side = 3, paste("State", state), line = 2.5)
    abline(v = c(0,1), lty = 2, col = "darkgray")
}
```

### Correlation by position within-strain {.tabset .tabset-fade .tabset-pills}

We also looked at a position-based correlation of gene expression with
chromatin state across genes within each strain.

```{r plot_within_strain, fig.width = 9, fig.height = 9}

#plot the across-strain effects
window.mids <- sapply(gene.windows, max)
if(is.interactive){quartz(width = 9, height = 9)}
par(mfrow = c(3,3))
for(state in 1:num.states){
    state.effects <- sapply(within.strain.window.results, function(x) x[state,])
    min.effect <- min(state.effects["slope.lwr",which(is.finite(state.effects["slope.lwr",]))])
    max.effect <- max(state.effects["slope.upr",which(is.finite(state.effects["slope.upr",]))])
    plot.new()
    plot.window(xlim = c(-0.1, 1.1), ylim = c(-0.8, 0.8))
    points(window.mids, state.effects["slope.fit",], col = state.col[state], type = "l")
    plot.poly.xy(window.mids, state.effects["slope.lwr",],
    window.mids, state.effects["slope.upr",], col = state.col[state])
    abline(h = 0)
    axis(1);axis(2)
    mtext(side = 2, "Effect", line = 2.5)
    mtext(side = 3, paste("State", state), line = 2.5)
    abline(v = c(0,1), lty = 2, col = "darkgray")
}

```

## States Across Strains

How many states are there across the strains in the regions 
we are looking at?

```{r strain_states}
do.col <- c(1:4, 6:9) #use only DO founder strains
states.per.pos <- lapply(chrom.mats, function(x) if(length(x) > 1){apply(x[,do.col], 1, function(y) length(unique(y)))})
all.states.per.pos <- unlist(states.per.pos)
num.strain <- 8
state.counts <- sapply(1:num.strain, function(x) length(which(all.states.per.pos == x)))
par(mar = c(4,8,4,4))
barplot_with_num(state.counts, names = 1:num.strain, main = "Number of States Per Position",
    xlab = "Number of States")
mtext("Total", side = 2, line = 5)
```