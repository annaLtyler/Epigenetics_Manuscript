---
title: "Figures for Epigenetics Manuscript"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  pdf_document:
    toc: true
---

## Introduction

The purpose of this workflow to house all the code for generating 
figures for the manuscript. It reads in data generated by other
markdown files and builds figures programatically. The model for
which to plot results can be set in Data/support_files/param.txt.

To generate separate pngs for figures, set embed.figures to FALSE.

```{r set_param, echo = FALSE}
library(here)
param <- read.delim(here("Data", "support_files", "param.txt"), header = FALSE, 
    stringsAsFactors = FALSE, row.names = 1)
num.states = as.numeric(param["num_states",])
ordered.marks <- strsplit(param["ordered_marks",], ",")[[1]]

embed.figures = TRUE

data.dir <- here("Data", "ChromHMM", paste0(num.states, "_states_C"))
results.dir <- here("Results", "ChromHMM", paste0(num.states, "_states_C"))

#use.states <- c(1,2,3,6,7,8,10,11,13) #choose to display only a subset of states
use.states <- 1:num.states
#default.mar <- par()$mar

title.color = "gray40"
tss.line.color = "darkgray"
border.box.color = grid.color = "gray80"
zero.line.color = "gray40"
data.line.color = "gray40"
```


```{r source_code, echo = FALSE}
all.code.dir <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.code.dir)){
	all.fun <- list.files(all.code.dir[i], full.names = TRUE, pattern = ".R")
	for(j in 1:length(all.fun)){source(all.fun[j])}
}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE, echo = FALSE}
needed.packages <- c("pheatmap", "RColorBrewer", "gridExtra", "grid")
load_libraries(needed.packages)
```


```{r read_info, echo = FALSE}
key.file <- here("Data", "support_files", "strain.color.table.txt") #generated by hand
col.table <- as.matrix(read.table(key.file, sep = "\t", comment.char = "%", 
    stringsAsFactors = FALSE))

#across-strain effects - used to order states by effect and generate state colors
all.state.effects <- readRDS(here("Results", "ChromHMM", "across.strain.models.RDS")) #generated by 1.3_Compare_ChromHMM_States.Rmd
state.effects <- all.state.effects[[which(names(all.state.effects) == num.states)]]

#order the use.state indices based on effects
state.idx <- use.states[order(state.effects[use.states,"slope.fit"], decreasing = TRUE)]
saveRDS(state.idx, file.path(results.dir, "state.idx.RDS"))
write.table(cbind(1:num.states, state.idx), file.path(results.dir, "state_order_key.txt"), 
    sep = "\t", quote = FALSE, row.names = FALSE, col.names = c("original.state", "new.index"))
#create colors based on effects

#pheatmap colors
#all.state.col <- colors.from.values(state.effects[,"slope.fit"], use.pheatmap.colors = TRUE)
#state.col <- all.state.col[state.idx]

#red-blue with gray in the middle
#color.ramp <- colorRampPalette(c("blue", "lightgray", "red"))
color.ramp <- colorRampPalette(c("red", "lightgray", "blue"))
all.state.col <- color.ramp(length(state.idx))
state.col <- all.state.col

#barplot(1:length(state.col), col = state.col)

#subset state effects to just the states we are using
state.effects <- state.effects[state.idx,]
rownames(state.effects) <- 1:nrow(state.effects) #rename states in order of effects
#another way of coloring states
#state.col <- read.table(here("Data", "support_files", "state_colors.txt"), 
#    comment.char = "%")[,1] #generated by hand
```

\pagebreak

## Figure 1 - Decompositions of transcriptome and epigenetic features

The first two principle components of each genomic feature across
nine inbred strains of mouse. In all panels each point represents
an individual mouse, and strain is indicated by color as shown in
the legend at the bottom of the figure. Each panel is labeled with
the data used to generate the PC plot. (A) Hepatocyte transcriptome - 
all transcripts sequenced in isolated hepatocites. (B) DNA methylation - 
the percent methylation at all CpG sites shared across all individuals. 
(C-F) Histone modifications - the peak heights of the indicated histone
modification for sites shared across all individuals.

```{r pc_data, echo = FALSE}
rna.seq.file <- here("Data", "RNASeq", "StrainsEffCts9_norm.RDS") #generated by 1.1_Expression.Rmd
rna.seq <- readRDS(rna.seq.file)

expr.pc <- plot.decomp(t(rna.seq), plot.results = FALSE)
expr.decomp <- expr.pc$u
rownames(expr.decomp) <- substr(colnames(rna.seq), 1, 2)
var.exp <- round(expr.pc$var.exp*100, 1)[1:ncol(expr.decomp)]
colnames(expr.decomp) <- paste0("PC", 1:ncol(expr.decomp), " (", var.exp, "%)")
#legend("bottomright", legend = col.table[,2], pch = 16, col = col.table[,3])

full.methylome.decomp.file <- here("Results", "RRBS", "Full.Methylome.Decomposition.RDS") #generated by 3.1.1_RRBS_Analysis.Rmd
methyl.decomp <- readRDS(full.methylome.decomp.file)

histone.decomp.file <- here("Results", "peakome", "Histone.Decomposition.by.Strain.RDS")
histone.decomp <- readRDS(histone.decomp.file)

#the samples in the histone modification data have variable names,
#so we need to get the colors a different way.
get_sample_col <- function(sample.ids){
    sample.idx <- lapply(col.table[,6], function(x) grep(x, sample.ids))
    sample.col <- lapply(1:length(sample.idx), function(x) rep(col.table[x,3], length(sample.idx[[x]])))
    sample.order <- unlist(sample.idx)
    sample.col <- unlist(sample.col)[sample.order]
    #barplot(rep(1, length(sample.col)), col = sample.col)
    return(sample.col)
}

sample.colors <- lapply(histone.decomp, function(x) get_sample_col(rownames(x)))
```


```{r pc_figure, fig.width = 4, fig.height = 7, echo = FALSE}
layout.mat <- matrix(c(1:7,7), ncol = 2, byrow = TRUE)
label.line = 2
axis.label.cex = 0.8
title.line = 0
title.cex = 1


if(!embed.figures){
    png(here("Documents", "3.Manuscript", "Figures", "Fig1_Decomposition.png"), 
    width = 4, height = 7, units = "in", res = 300)
}

layout(layout.mat, heights = c(rep(1,3), 0.3))
#layout.show(7)

par(mar = c(4,4,4,1))
strain.col <- col.table[match(rownames(expr.decomp), col.table[,4]),3]
plot(expr.decomp, pch = 16, col = strain.col, cex = 1.5, xlab = "", ylab = "")
mtext(colnames(expr.decomp)[1], side = 1, line = label.line, cex = axis.label.cex)
mtext(colnames(expr.decomp)[2], side = 2, line = label.line, cex = axis.label.cex)
mtext("Transcriptome", side = 3, line = title.line, cex = title.cex, font = 2, col = title.color)

strain.labels <- substr(rownames(methyl.decomp), 1, nchar(rownames(methyl.decomp))-2)
strain.col <- col.table[match(strain.labels, col.table[,6]),3]
plot(methyl.decomp, col = strain.col, pch = 16, cex = 1.5, xlab = "", ylab = "")
mtext(colnames(methyl.decomp)[1], side = 1, line = label.line, cex = axis.label.cex)
mtext(colnames(methyl.decomp)[2], side = 2, line = label.line, cex = axis.label.cex)
mtext("Methylome", side = 3, line = title.line, cex = title.cex, font = 2, col = title.color)

for(m in 1:length(histone.decomp)){
    strain.names <- substr(rownames(histone.decomp[[m]]), 1, nchar(rownames(histone.decomp[[m]]))-2)
    plot(histone.decomp[[m]], pch = 16, col = sample.colors[[m]], cex = 1.5,
    xlab = "", ylab = "")
    mtext(colnames(histone.decomp[[m]])[1], side = 1, line = label.line, cex = axis.label.cex)
    mtext(colnames(histone.decomp[[m]])[2], side = 2, line = label.line, cex = axis.label.cex)
    mtext(names(histone.decomp)[m], side = 3, line = title.line, cex = title.cex, font = 2, 
        col = title.color)
}

#add legend
par(mar = c(0,0,0,0))
plot.new()
plot.window(xlim = c(0,1), ylim = c(0,1))
legend.chunks <- list(1:5, 6:9)
y.pos <- c(0.75, 0.25)
x.min <- 0.05; x.max = 0.85
x.pos <- list(segment.region(x.min, x.max, length(legend.chunks[[1]]), "ends"), 
              segment.region(x.min, x.max, length(legend.chunks[[2]]), "center"))
#nudge A/J over a bit
x.pos[[1]][2] <- 0.3

for(i in 1:length(legend.chunks)){
    points(x.pos[[i]], rep(y.pos[[i]], length(x.pos[[i]])), 
        col = col.table[legend.chunks[[i]],3], 
        pch = 16, cex = 1.8)
    
    text(x = x.pos[[i]], y = rep(y.pos[[i]], length(x.pos[[i]])), pos = 4, 
        labels = col.table[legend.chunks[[i]],2], cex = 1.05)
}
draw.rectangle(0,1,0,1)

if(!embed.figures){
    dev.off()
}
```

\pagebreak

## Figure 2 - Chromatin state overview

Overview of chromatin state composition, genomic distribution,
and effect on expression. The left most panel shows the emission
probabilites for each histone modification in each chromatin state. 
Blue indicates the absence of the histone modification, and red 
indicates the presence of the modification. The panel labeled
genomic enrichment shows the distribution of each state around 
functional elements in the genome. Red indicates that the
state is more likely to be found near the annotated functional 
element than expected by chance. Blue indicates that the state
is less likely to be found near the annotated functional element
than expected by chance. Abbreviations are as follows: TFBS = 
transcription factor binding sites, cCRE = candidate cis-regulatory
element [@pmid32728249], TSS = transcription start site, 
TES = transcription end site. The panel labeled Expression Effects 
shows the effect of variation in the state on gene expression. 
Bars are colored based on the size and direction the state's effect on
expression. Darker bars show the effects on expression of chromatin 
state variation across strains. Tan bars show the effects on expression
of chromatin state variation across genes. The final column of the figure 
shows plausible annotations for each state based on combining the data in 
the previous three panels. The numbers in parentheses indicate the percent 
of the genome that was assigned to each state.

```{r overview_read_data, echo = FALSE}
#emissions
emissions.mat <- as.matrix(read.delim(file.path(data.dir, paste0("emissions_", num.states, ".txt")), 
    row.names = 1))
emission.order <- match(ordered.marks, colnames(emissions.mat))
ordered.emissions <- emissions.mat[state.idx,emission.order] #subset and rename to used states.
rownames(ordered.emissions) <- 1:nrow(ordered.emissions)

#percent coverage
percent.mat <- readRDS(file.path(results.dir, "State.Genome.Percent.RDS"))[state.idx,]
#barplot(t(percent.mat), beside = TRUE, col = col.table[,3])
state.percent <- round(rowMeans(percent.mat), 1)
zero.locale <- which(state.percent == 0)
if(length(zero.locale) > 0){
    state.percent[zero.locale] <- "<0.1"
}

#enrichments
enrichment.mat <- as.matrix(read.delim(here("Results", "Enrichments", 
    paste0(num.states, "_states_C_enrichments.txt")), row.names = 1))
enrichment.col <- c("Intergenic" = "Genome..", "CpG Island" = "CpGIsland.mm10.bed.gz", 
    "cCRE" = "Encode_cCRE.bed.gz", "TES" = "RefSeqTES.mm10.bed.gz", "TSS" = "RefSeqTSS.mm10.bed.gz", 
    "TFBS" = "TFbs.bed.gz", "Enhancers" = "enhancers.bed.gz", "Promoters" = "promoters.bed.gz")
col.idx <- match(enrichment.col, colnames(enrichment.mat))
sub.enrichment <- enrichment.mat[state.idx,col.idx]
rownames(sub.enrichment) <- 1:nrow(sub.enrichment)
col.order <- hclust(dist(t(sub.enrichment)))$order
#scale using ChromHMM scaling method
scaled.enrichment <- t(apply(sub.enrichment[,col.order], 1, function(x) (x-min(x))/max(x)))

#within-strain effects
within.strain.effects <- readRDS(here("Results", "ChromHMM", "within.strain.models.RDS")) #generated by 1.3_Compare_ChromHMM_States.Rmd
within.effects <- within.strain.effects[[which(names(within.strain.effects) == num.states)]]
within.mat <- t(sapply(within.effects, rowMeans))[state.idx,]
rownames(within.mat) <- 1:nrow(within.mat)

annotations <- as.matrix(read.delim(here("Data", "support_files", "annotation.table.txt"),
stringsAsFactors = FALSE))
```

```{r annotate_states, echo = FALSE}
#this function annotates the states based on the emission matrix.
annotate_state <- function(state, annotations, thresh = 0.3){
    has.mark <- which(state >= thresh)
    no.mark <- which(state < thresh)

    has.mark.idx <- Reduce("intersect", lapply(names(has.mark), function(x) which(annotations[,x] == "1")))
    no.mark.idx <- Reduce("intersect", lapply(names(no.mark), function(x) which(annotations[,x] == "0")))
    if(length(has.mark) > 0 && length(no.mark) > 0){
        state.idx <- intersect(has.mark.idx, no.mark.idx)
    }
    if(length(has.mark) == 0){
        state.idx <- no.mark.idx
    }
    if(length(no.mark) == 0){
        state.idx <- has.mark.idx
    }
    #pheatmap(all.states[state.idx,])
    return(annotations[state.idx,c("annotations", "descriptions")])
}

state.annotations <- t(apply(ordered.emissions, 1, function(x) annotate_state(x, annotations, 0.3)))
colnames(state.annotations) <- c("annotation", "description")
```

```{r overview_fig, fig.height = 4, fig.width = 6.5, echo = FALSE}

layout.mat <- matrix(c(0,1,2,3,4,0,5,6,0,0,7,8,9,10,11), nrow = 3, byrow = TRUE)

if(!embed.figures){
    png(here("Documents", "3.Manuscript", "Figures", "Fig2_Overview.png"), 
    width = 6.5, height = 4, units = "in", res = 300)
}
#quartz(width = 6.5, height = 4)
layout(layout.mat, widths = c(0.2, 0.3, 0.5, 0.7, 0.4), heights = c(0.1, 0.02, 1))
#layout.show(11)
#1-4. state titles
par(mar = c(0,0,0,0))
title.cex = 1.2; title.font = 2
plot.text("Emissions", cex = title.cex, col = title.color, font = title.font)
plot.text("Genomic Enrichment", cex = title.cex, col = title.color, font = title.font)
plot.text("Expression Effects", cex = title.cex, col = title.color, font = title.font)
plot.text("Annotation", cex = title.cex, col = title.color, font = title.font)

#5-6, scales
par(mar = c(0,0,0,0))
imageWithTextColorbar(ordered.emissions, global.color.scale = TRUE, global.min = 0,
global.max = 1, use.pheatmap.colors = TRUE, orientation = "h", cex = 1, n.ax.ticks = 3,
axis.line = 0)

par(mar = c(0,2,0,2))
enrichment.bounds  <- get_plot_bounds(min(scaled.enrichment), max(scaled.enrichment), 
    scale.factor = 10, return.even = TRUE, center = TRUE)
imageWithTextColorbar(scaled.enrichment, use.pheatmap.colors = TRUE, 
global.color.scale = TRUE, global.min = enrichment.bounds[1], 
global.max = enrichment.bounds[2], orientation = "h", cex = 1, 
n.ax.ticks = 3, axis.line = 0)

#7 state labels
par(mar = c(8,0,2,0))
plot.new()
plot.window(xlim = c(0,1), ylim = c(0,1))
text.y <- segment.region(0, 1, length(state.idx), "ends")
text(x = rep(0.95, length(state.idx)), y = text.y, adj = 1, cex = 1.3,
    labels = paste("State", rev(rownames(ordered.emissions))), col = rev(state.col), font = 2)

#8 emissions matrix
par(mar = c(8,0,2,1))
imageWithText(ordered.emissions, global.color.scale = TRUE, global.min = 0,
global.max = 1, use.pheatmap.colors = TRUE, show.text = FALSE, 
row.names = rep("", length(state.idx)), col.text.shift = -0.7, col.text.cex = 1.5)

#9 enrichment matrix
par(mar = c(8,0,2,0))
imageWithText(scaled.enrichment, 
    use.pheatmap.colors = TRUE, show.text = FALSE, col.names = names(enrichment.col)[col.order],
    row.names = rep("", length(state.idx)), col.text.shift = -0.7, col.text.cex = 1.5)

#10 effects
par(xpd = FALSE)
par(mar = c(8,1,2,1))
ylim  <- get_plot_bounds(min(within.mat[,"slope.lwr"]), max(within.mat[,"slope.upr"]), 
    scale.factor = 100, return.even = TRUE, center = TRUE)
ymin <- ylim[1]
ymax <- ylim[2]
full.range <- ymax - ymin
effect.grid <- round(segment.region(ymin, ymax, 6, "ends"), 2)

plot.new()
plot.window(ylim = c(1,length(state.idx)), xlim = c(ymin, ymax))
#add grid lines
abline(h = 1:length(state.idx), v = effect.grid, col = grid.color)
state.y <- length(use.states):1

segment.width = 2
symbol.cex = 0
within.lty = 1
across.lty = 1

for(state in 1:length(state.idx)){

    line.col <- state.col[state]

    points(y = state.y[state], x = state.effects[state,"slope.fit"],
    col = line.col, cex = symbol.cex, pch = 16)
    segments(y0 = state.y[state], x0 = state.effects[state,"slope.lwr"],
    x1 = state.effects[state, "slope.upr"], lwd = segment.width, 
    col = line.col, lty = across.lty) #full range
    segments(y0 = state.y[state]-0.2, y1 = state.y[state] + 0.2, 
    x0 = state.effects[state,"slope.upr"], lwd = segment.width, 
    col = line.col, lty = across.lty) #upper bound
    segments(y0 = state.y[state]-0.2, y1 = state.y[state] + 0.2, 
    x0 = state.effects[state,"slope.lwr"], lwd = segment.width, 
    col = line.col, lty = across.lty) #lower bound

    #line.col <- mix_colors(state.col[use.states][state], "gray", mixing.parameter = 0.85)
    line.col <- mix_colors("tan", "gray", mixing.parameter = 0.5)

    points(y = state.y[state], x = within.mat[state,"slope.fit"],
    col = line.col, cex = symbol.cex, pch = 17)
    segments(y0 = state.y[state], x0 = within.mat[state,"slope.lwr"],
    x1 = within.mat[state, "slope.upr"], lwd = segment.width, 
    col = line.col, lty = within.lty) #full range
    segments(y0 = state.y[state]-0.2, y1 = state.y[state] + 0.2, 
    x0 = within.mat[state,"slope.upr"], lwd = segment.width, 
    col = line.col, lty = within.lty) #upper bound
    segments(y0 = state.y[state]-0.2, y1 = state.y[state] + 0.2, 
    x0 = within.mat[state,"slope.lwr"], lwd = segment.width, 
    col = line.col, lty = within.lty) #lower bound

    }
abline(v = 0)
axis(1, at = effect.grid)
mtext("State Effect", side = 1, line = 3, col = title.color, cex = 1)

#11 Annotations
par(xpd = NA)
par(mar = c(8,0,2,0))
plot.new()
plot.window(xlim = c(0,1), ylim = c(0,1))
annotation.text <- paste0(state.annotations[length(state.idx):1,1], " (", rev(state.percent), "%)")
text(x = rep(-0.1, length(state.idx)), y = text.y, adj = 0, cex = 0.9, 
    labels = annotation.text, col = title.color, font = 2)
par(xpd = FALSE)

if(!embed.figures){
    dev.off()
}

```
\pagebreak

## Figure 3 - Epigenetic state abundance

Relative abundance of chromatin states and methylated DNA. A. Each panel shows
the abundance of a single chromatin state relative to gene TSS and TES. The 
$y$-axis in each panel is the proportion of genes containing the state. Each
panel has an independent $y$-axis to better show the shape of each curve.
The $x$-axis is the relative gene position. The TSS and TES are marked as vertical
gray dashed lines. B. The same data shown in panel A, but with all states overlayed
onto a single set of axes to show the relative abundance of the states. 
C. The density of CpG sites relative to the gene body. The $y$-axis shows the 
number of CpG sites per base pair. The density is highest near the TSS. 
CpG sites are less dense within the gene body and in the intergenic space. 
D. Percent methylation relative to the gene body. The $y$-axis shows the median 
percent methylation at CpG sites, and the $x$-axis shows relative gene position. 
CpG sites near the TSS are unmethylated relative to intragenic and intergenic
CpG sites.

```{r abundance_data, echo = FALSE}
state.abundance.file <- file.path(results.dir, "Chromatin.State.Position.Far.Genes.RDS") #generated in 1.4_Chromatin_States_and_Expression.Rmd
state.abundance <- readRDS(state.abundance.file)[state.idx]

methyl.dens.file <- here("Results", "RRBS", "Methylation_Density.RDS") #generated in 3.1.1_RRBS_Analysis.Rmd
avg.methyl.dist <- readRDS(methyl.dens.file)

strain.methyl.file <- here("Results", "RRBS", "Strain.RRBS.Percent.RDS") #generated in 3.1.1_RRBS_Analysis.Rmd
strain.methyl.mat <- readRDS(strain.methyl.file)
```

```{r abundance_plot, fig.height = 9, fig.width = 6.5, echo = FALSE}
chrom.layout <- 1:(length(state.idx)+1)
big.panel.len <- floor((length(state.idx)+1)/3)
big.panel.idx <- (length(state.idx)+2):(length(state.idx)+4)
other.layout <- rep(length(state.idx)+2, (length(state.idx)+1))

start.y <- 1

for(i in 1:3){
    end.y <- start.y + big.panel.len - 1
    panel.layout <- layout.with.inset(nrow = (length(state.idx)+1), ncol = 1, 
    inset.x.min = 1, inset.x.max = 1, inset.y.min = start.y, inset.y.max = end.y)
    other.layout[which(panel.layout == 2)] <- rev(big.panel.idx)[i]
    start.y <- end.y + 1
}
layout.mat <- cbind(chrom.layout, other.layout)

xmin = -0.5; xmax = 1.5

if(!embed.figures){
    png(here("Documents", "3.Manuscript", "Figures", "Fig3_Abundance.png"), 
    height = 9, width = 6.5, units = "in", res = 300)
}

panel.height <- 1/(length(state.idx)+1)
layout(layout.mat, widths = c(0.5, 1), heights = c(panel.height/2, rep(panel.height, length(use.states))))

# add TSS/TES labels for chromatin state plots
par(mar = c(0.5,3,0.5,2))
plot.new()
plot.window(xlim = c(xmin, xmax), ylim = c(0,1))
par(xpd = TRUE)
text(x = 0, y = 0, labels = "TSS", font = 2, col = title.color, cex = 1.5)
text(x = 1, y = 0, labels = "TES", font = 2, col = title.color, cex = 1.5)
par(xpd = FALSE)

#chromatin state abundance
for(s in 1:length(state.abundance)){
    state.avg <- state.abundance[[s]]$state.avg
    state.pos <- state.abundance[[s]]$position
    
    #trim
    idx <- intersect(which(state.pos >= xmin), which(state.pos <= xmax))
    state.avg <- state.avg[idx]
    state.pos <- state.pos[idx]

    max.abundance <- max(state.avg, na.rm = TRUE)
    min.abundance <- min(state.avg, na.rm = TRUE)
    abundance.range <- max.abundance - min.abundance

    ymin <- (min.abundance-(abundance.range*0.08))
    ymax <- (max.abundance + (abundance.range*0.08))

    plot(state.pos, state.avg, type = "l", ylim = c(ymin, ymax), 
        col = state.col[s], xlim = c(-0.5, 1.5), lwd = 4, axes = FALSE)

    #barplot_with_num(signif(state.avg*100, 1), las = 2)    

    draw.rectangle(-0.57, 1.57, ymin, ymax, border.col = border.box.color, lwd = 2)
    #axis(2)
    abline(v = c(0,1), col = tss.line.color, lty = 2, lwd = 3)
    mtext(side = 2, paste("State", s), cex = 0.8, line = 0.5, col = title.color, font = 2)
}

#chromatin state abundance all together
all.abund <- t(sapply(state.abundance, function(x) x$state.avg))[,idx]
ymax <- ceiling(max(all.abund, na.rm = TRUE)*10)/10

par(mar = c(2,4,2,2))
plot.new()
plot.window(xlim = c(-0.5, 1.5), ylim = c(0,ymax))
segments(x0 = c(0,1), x1 = c(0,1), y0 = c(0,0), y1 = c(ymax*0.95, ymax*0.95), 
    lty = 2, col = tss.line.color, lwd = 4)
for(s in 1:length(state.idx)){ #ordered for ease of visualization
    points(state.abundance[[s]]$position, y = state.abundance[[s]]$state.avg, 
    col = state.col[s], type = "l", lwd = 4)
}
axis(2, cex.axis = 1.5)
mtext("Proportion", side = 2, line = 3, cex = 1.5, col = title.color)
text(x = 0, y = ymax, labels = "TSS", font = 2, col = title.color, cex = 2)
text(x = 1, y = ymax, labels = "TES", font = 2, col = title.color, cex = 2)

#DNA methylation density
par(mar = c(2,4,1,2))
dist.pos <- as.numeric(colnames(avg.methyl.dist))
#dist.avg <- apply(avg.methyl.dist, 2, function(x) median(x, na.rm = TRUE))
freq.avg <- apply(avg.methyl.dist, 2, function(x) 1/median(x, na.rm = TRUE))
freq.se <- apply(avg.methyl.dist, 2, function(x) 1/sd(x, na.rm = TRUE)/sqrt(length(which(!is.na(x)))))
ytop <- freq.avg + freq.se
plot.new()
plot.window(xlim = c(xmin, xmax), ylim = c(0, (max(ytop)*1.05)))
plot.poly.xy(poly.top.x = dist.pos, poly.top.y = freq.avg+freq.se, 
    poly.bottom.x = dist.pos, poly.bottom.y = freq.avg-freq.se, 
    col = "lightblue", new.plot = FALSE, border = NA)
points(dist.pos, freq.avg, col = data.line.color, type = "l", lwd = 4)
segments(x0 = c(0,1), x1 = c(0,1), y0 = c(0,0), y1 = c(max(ytop)*0.95, max(ytop)*0.95), 
    lty = 2, col = tss.line.color, lwd = 3)
text(x = 0, y = max(ytop)*1.05, labels = "TSS", font = 2, col = title.color, cex = 2)
text(x = 1, y = max(ytop)*1.05, labels = "TES", font = 2, col = title.color, cex = 2)
axis(2, cex.axis = 1.5)
segments(x0 = min(dist.pos), x1 = max(dist.pos), y0 = 0)
mtext("CpG Density", side = 2, line = 3, cex = 1.5, col = title.color)

#DNA methylation percent
perc.pos <- as.numeric(colnames(strain.methyl.mat[[1]]))
methyl.mean.perc <- rowMeans(sapply(strain.methyl.mat, function(x) apply(x, 2, function(y) median(y, na.rm = TRUE))))
methyl.mean.se <- rowMeans(sapply(strain.methyl.mat, function(x) apply(x, 2, function(y) sd(y, na.rm = TRUE)/sqrt(length(which(!is.na(y)))))))

ytop <- methyl.mean.perc + methyl.mean.se
plot.new()
plot.window(xlim = c(xmin, xmax), ylim = c(0, (max(ytop)*1.05)))
plot.poly.xy(poly.top.x = perc.pos, poly.top.y = methyl.mean.perc+methyl.mean.se,
    poly.bottom.x = perc.pos, poly.bottom.y = methyl.mean.perc-methyl.mean.se, 
    col = "lightblue", new.plot = FALSE, border = NA)
points(perc.pos, methyl.mean.perc, col = data.line.color, type = "l", lwd = 4)
segments(x0 = c(0,1), x1 = c(0,1), y0 = c(0,0), y1 = c(max(ytop)*0.95, max(ytop)*0.95), 
    lty = 2, col = tss.line.color, lwd = 3)
text(x = 0, y = (max(ytop)*1.05), labels = "TSS", font = 2, col = title.color, cex = 2)
text(x = 1, y = (max(ytop)*1.05), labels = "TES", font = 2, col = title.color, cex = 2)
axis(2, cex.axis = 1.5)
segments(x0 = min(dist.pos), x1 = max(dist.pos), y0 = 0)
mtext("Percent Methylated", side = 2, line = 3, cex = 1.5, col = title.color)

if(!embed.figures){
    dev.off()
}
```

\pagebreak

## Figure 4 - Epigenetic Effects

Effects of chromatin states on gene expression. Each column shows 
the effect of each chromatin state on gene expression in a different 
experimental context. The first column shows the effect across genes in 
the inbred mice showing how chromatin states are used within a single 
tissue to increase the expression of some genes and decrease the expression 
of other genes. The second column shows the effect of chromatin state on 
gene expression across strains, showing how variation in chromatin state 
across strains leads to variation in expression of individual genes across 
strains. The third column shows the effect of imputed chromatin state on 
gene expression in a population of diversity outbred mice. These plots show 
the effect on local gene expression of variation in chromatin state across 
genetically diverse individuals. Each column of panels is plotted on a single 
scale for the $y$-axis so the magnitude of the effects in a single column can be 
compared directly to each other. Across a single row, the scale of the $y$-axis 
varies to highlight the similarity of the shape of each curve in each different 
setting. The final column shows the annotation of each state for comparison with
its effects on gene expression. All $y$-axes show the $\beta$ coefficient from 
the linear model shown in equation [REF]. All $x$-axes show the relative 
position along the gene body running from just upstream of the TSS to just 
downstream of the TES. Vertical gray dashed lines mark the TSS and TES in all 
panels.

```{r read_effect_data, echo = FALSE}
#within-strain coefficients
within.strain.window.state.file <- file.path(results.dir, "State.Window.Effects.Within.Strains.RDS") #generated in 1.4_Chromatin_States_and_Expression.Rmd
within.strain.window.results  <- lapply(readRDS(within.strain.window.state.file), function(x) x[state.idx,])

#across-strain coefficients
across.strain.window.state.file <- file.path(results.dir, "State.Window.Effects.Across.Strains.RDS") #generated in 1.4_Chromatin_States_and_Expression.Rmd
across.strain.window.results <- lapply(readRDS(across.strain.window.state.file), function(x) x[state.idx,])

#imputed coefficients
all.state.coef <- readRDS(file.path(results.dir, "Chromatin_State_DO_Coef.RDS"))[state.idx] #generated in 2.2_chromaprobs_analysis.Rmd

gene.windows <- readRDS(here("Data", "support_files", "gene_windows.RDS"))
```

```{r panel_layout, echo = FALSE}
label.row <- 0:4
tss.row <- c(0,5,6,7,0)
num.label.panels <- last.panel <- max(tss.row)
panel.col <- vector(mode = "list", length = 4)
for(i in 1:5){
    next.panel <- last.panel + 1
    one.col <- next.panel:((i*length(state.idx))+num.label.panels)
    panel.col[[i]] <- one.col
    last.panel <- max(one.col)
}

layout.mat <- rbind(label.row, tss.row, Reduce("cbind", panel.col))
```

```{r state_effects_figure, fig.width = 6.5, fig.height = 9, echo = FALSE}
#quartz(height = 9, width = 6.5)

if(!embed.figures){
    png(here("Documents", "3.Manuscript", "Figures", "Fig4_Effects.png"), 
    width = 6.5, height = 9, units = "in", res = 300)
}
xmin = -0.2; xmax = 1.2

panel.height <- 1/(length(state.idx)+2)
layout(layout.mat, heights = c(rep(panel.height/3, 2), rep(panel.height, length(state.idx))),
widths = c(0.2, rep(1, 4)))
#layout.show(max(layout.mat))
#plot column labels
par(mar = c(0,1,0,1))
plot.text("In Hepatocytes", font = 2, col = title.color, cex = 1.5)
plot.text("Across Inbred", font = 2, col = title.color, cex = 1.5)
plot.text("Across Outbred", font = 2, col = title.color, cex = 1.5)
plot.text("Annotation", font = 2, col = title.color, cex = 1.5)

#plot TSS/TES labels
par(mar = c(1,1,0,1))
par(xpd = NA)
for(i in 1:3){
    plot.new()
    plot.window(xlim = c(xmin, xmax), ylim = c(0,1))
    text(x = 0, y = 0, labels = "TSS", font = 2, col = title.color, cex = 1.2)
    text(x = 1, y = 0, labels = "TES", font = 2, col = title.color, cex = 1.2)
}
par(xpd = FALSE)

#plot state labels
par(mar = c(0,0,0,0))
for(i in 1:length(state.idx)){
    plot.text(paste("State", i), srt = 90, col = title.color, font = 2, cex = 1.3)
}

#plot within-strain effects
par(mar = c(0,0,0,0))
all.lower.y <- sapply(within.strain.window.results, function(x) x[,"slope.lwr"])
all.upper.y <- sapply(within.strain.window.results, function(x) x[,"slope.upr"])
#make one y axis for all plots, center it so 0 line lines up across
#the full row
ylim <- get_plot_bounds(min(all.lower.y), max(all.upper.y), scale.factor = 100, 
    return.even = TRUE, center = TRUE)
ymin <- ylim[1]
ymax = ylim[2]

window.mids <- sapply(gene.windows, max)
for(state in 1:length(state.idx)){
    state.effect <- sapply(within.strain.window.results, function(x) x[state,])
    min.effect <- min(state.effect["slope.lwr",which(is.finite(state.effect["slope.lwr",]))])
    max.effect <- max(state.effect["slope.upr",which(is.finite(state.effect["slope.upr",]))])

    #testing separate scales
    ylim <- get_plot_bounds(min.effect*1.1, max.effect*1.1, scale.factor = 100, 
    return.even = TRUE, center = TRUE)
    ymin <- ylim[1]
    ymax = ylim[2]

    plot.new()
    plot.window(xlim = c(xmin, xmax), ylim = c(ymin, ymax))
    points(window.mids, state.effect["slope.fit",], col = state.col[state], type = "l")
    plot.poly.xy(window.mids, state.effect["slope.lwr",],
    window.mids, state.effect["slope.upr",], col = state.col[state])
    segments(xmin, 0, xmax, col =zero.line.color, lwd = 2)
    abline(v = c(0,1), lty = 2, col = tss.line.color, lwd = 2)
    draw.rectangle(xmin, xmax, ymin, ymax, border.col = border.box.color, lwd = 2)
}

#plot across-strain effects
all.lower.y <- sapply(across.strain.window.results, function(x) x[,"slope.lwr"])
all.upper.y <- sapply(across.strain.window.results, function(x) x[,"slope.upr"])
#make one y axis for all plots, center it so 0 line lines up across
#the full row
ylim <- get_plot_bounds(min(all.lower.y), max(all.upper.y), scale.factor = 100, 
    return.even = TRUE, center = TRUE)
ymin <- ylim[1]
ymax = ylim[2]

for(state in 1:length(state.idx)){
    state.effect <- sapply(across.strain.window.results, function(x) x[state,])
    min.effect <- min(state.effect["slope.lwr",which(is.finite(state.effect["slope.lwr",]))])
    max.effect <- max(state.effect["slope.upr",which(is.finite(state.effect["slope.upr",]))])
    
    #testing separate scales
    ylim <- get_plot_bounds(min.effect*1.1, max.effect*1.1, scale.factor = 100, 
    return.even = TRUE, center = TRUE)
    ymin <- ylim[1]
    ymax = ylim[2]

    plot.new()
    plot.window(xlim = c(xmin, xmax), ylim = c(ymin, ymax))
    points(window.mids, state.effect["slope.fit",], col = state.col[state], type = "l")
    plot.poly.xy(window.mids, state.effect["slope.lwr",],
    window.mids, state.effect["slope.upr",], col = state.col[state])
    segments(xmin, 0, xmax, col = zero.line.color, lwd = 2)
    abline(v = c(0,1), lty = 2, col = tss.line.color, lwd = 2)
    draw.rectangle(xmin, xmax, ymin, ymax, border.col = border.box.color, lwd = 2)
}

# plot DO effects
idx <- lapply(all.state.coef, function(x) intersect(which(as.numeric(colnames(x)) >= xmin), which(as.numeric(colnames(x)) <= xmax)))
all.state.mean <- lapply(1:length(all.state.coef), function(x) colMeans(all.state.coef[[x]][,idx[[x]]], na.rm = TRUE))
all.state.se <- lapply(1:length(all.state.coef), function(x) apply(all.state.coef[[x]][,idx[[x]]], 2, function(y) sd(y, na.rm = TRUE)/sqrt(length(which(!is.na(y))))))
all.lower.y <- unlist(all.state.mean) - unlist(all.state.se)
all.upper.y <- unlist(all.state.mean) + unlist(all.state.se)
#make one y axis for all plots, center it so 0 line lines up across
#the full row
ylim <- get_plot_bounds(min(all.lower.y), max(all.upper.y), scale.factor = 100, 
    return.even = TRUE, center = TRUE)
ymin <- ylim[1]
ymax = ylim[2]

for(state in 1:length(state.idx)){
    #testing separate scales
    ylim <- get_plot_bounds(min(all.state.mean[[state]]-all.state.se[[state]]), 
        max(all.state.mean[[state]]+all.state.se[[state]]), scale.factor = 100, 
        return.even = TRUE, center = TRUE)
    ymin <- ylim[1]*1.1
    ymax = ylim[2]*1.1


    plot.new()
    plot.window(xlim = c(xmin, xmax), ylim = c(ymin, ymax))
    coef.pos <- as.numeric(names(all.state.mean[[state]]))
    #points(coef.pos, all.state.mean[[state]], col = state.col[state], type = "l")
    plot.poly.xy(coef.pos, all.state.mean[[state]]-all.state.se[[state]],
    coef.pos, all.state.mean[[state]]+all.state.se[[state]], col = state.col[state])
    segments(xmin, 0, xmax, col = zero.line.color, lwd = 2)
    abline(v = c(0,1), lty = 2, col = tss.line.color, lwd = 2)
    draw.rectangle(xmin, xmax, ymin, ymax, border.col = border.box.color, lwd = 2)
}  

# plot annotations
par(mar = c(0,0,0,0))
for(state in 1:length(state.idx)){
    #plot.text(rev(state.annotations)[state], x = 0, y = 0.5, adj = 0, 
    #cex = 1.4, col = rev(state.col[state]), font = 2)
    annotation <- state.annotations[,1][state]
    description <- add.carriage.returns(state.annotations[,2][state], 18)
    plot.text(annotation, x = 0.5, y = 0.85, adj = 0.5, cex = 1.3, 
    col = title.color, font = 2)
    plot.text(description, x = 0.5, y = 0.65, adj = c(0.5, 1), cex = 1.3, 
    col = title.color, font = 1, add = TRUE) 
    draw.rectangle(0, 1, 0, 1, border.col = border.box.color, lwd = 2)
}

if(!embed.figures){
    dev.off()
}

```

\pagebreak

## Figure 5 - DNA Methylation Effects

Effect of DNA methylation on gene expression (A) across gene expression
in hepatocytes and (B) across inbred strains. Dark gray line shows estimate
of the effect of percent DNA methylation on gene expression. The $x$-axis is
normalized position along the gene body running from the transcription start
site (TSS) to the transcription end site (TES), marked with vertical gray dashed
lines. The horizontal solid black line indicates an effect of 0. 
The shaded gray area shows 95\% confidence interval arond the model fit. 

```{r within_strain_methyl_fig, fig.height = 5, fig.width = 3, echo = FALSE}
methyl.across <- readRDS(here("Results", "RRBS", "Plotting_Across_Strain.RDS")) #generated in 3.1.1_RRBS_Analysis.Rmd
methyl.within <- readRDS(here("Results", "RRBS", "Plotting_Within_Strain.RDS")) #generated in 3.1.1_RRBS_Analysis.Rmd

upstream.limit <- -0.5
downstream.limit <- 1.5

rel.pos <- methyl.within[,1]
idx <- intersect(which(rel.pos >= upstream.limit), which(rel.pos <= downstream.limit))

if(!embed.figures){
    png(here("Documents", "3.Manuscript", "Figures", "Fig5_methylation_effect.png"), 
    height = 5, width = 4, units = "in", res = 300)
}
layout.mat <-  matrix(c(1:6), ncol = 1)
layout(layout.mat, heights = c(0.1, 0.1, 1, 0.1, 0.1, 1))

#titles for within-strain effects
par(mar = c(0,0,0,0), xpd = NA)
plot.text("Within-Strain Effect", y = 0, col = title.color, font = 2, cex = 1.5)

par(mar = c(0,2,0,2))
plot.new()
plot.window(xlim = c(upstream.limit, downstream.limit), ylim = c(0,1))
plot.text("TSS", x = 0, y = 0, col = title.color, font = 2, cex = 1.5, add = TRUE)
plot.text("TES", x = 1, y = 0, col = title.color, font = 2, cex = 1.5, add = TRUE)
par(xpd = TRUE)

ylim <- get_plot_bounds(min(methyl.within[,"lwr"]), max(methyl.within[,"upr"]), 
    scale.factor = 100, return.even = TRUE)
ymin <- ylim[1]
ymax <- ylim[2]

#within-strain effects
plot.new()
plot.window(xlim = c(upstream.limit, downstream.limit), ylim = ylim) 
plot.poly.xy(rel.pos[idx], methyl.within[idx,"lwr"], rel.pos[idx], methyl.within[idx,"upr"], 
    col = "gray80", border = "gray80")
points(rel.pos[idx], methyl.within[idx,"fit"], type = "l", col = data.line.color, lwd = 3)
segments(x0 = c(0,1), y0 = ymin, y1 = ymax, lwd = 4, col = tss.line.color, lty = 2)
segments(x0 = upstream.limit, x1 = downstream.limit, y0 = 0, col = zero.line.color, lty = 1, lwd = 2)
#mtext(side = 2, "Effect", cex = 2, line = 0.5)
draw.rectangle(upstream.limit, downstream.limit, ymin, ymax, border.col = border.box.color, lwd = 2)
mtext("Effect", side = 2, col = title.color, font = 2)

#titles for across-strain effects
par(mar = c(0,0,0,0), xpd = NA)
plot.text("Across-Strain Effect", y = 0, col = title.color, font = 2, cex = 1.5)

par(mar = c(0,2,0,2))
plot.new()
plot.window(xlim = c(upstream.limit, downstream.limit), ylim = c(0,1))
plot.text("TSS", x = 0, y = 0, col = title.color, font = 2, cex = 1.5, add = TRUE)
plot.text("TES", x = 1, y = 0, col = title.color, font = 2, cex = 1.5, add = TRUE)
par(xpd = TRUE)

ylim <- get_plot_bounds(min(methyl.across[idx,"lwr"]), max(methyl.across[idx,"upr"]), 
    scale.factor = 1000, return.even = TRUE, center = FALSE)
ymin <- ylim[1]
ymax <- ylim[2]

#within-strain effects
par(mar = c(1,2,0,2))
plot.new()
plot.window(xlim = c(upstream.limit, downstream.limit), ylim = ylim) 
plot.poly.xy(rel.pos[idx], methyl.across[idx,"lwr"], rel.pos[idx], methyl.across[idx,"upr"], 
    col = "gray80", border = "gray80")
points(rel.pos[idx], methyl.across[idx,"fit"], type = "l", col = data.line.color, lwd = 3)
segments(x0 = c(0,1), y0 = ymin, y1 = ymax, lwd = 4, col = tss.line.color, lty = 2)
segments(x0 = upstream.limit, x1 = downstream.limit, y0 = 0, col = zero.line.color, lty = 1, lwd = 2)
#mtext(side = 2, "Effect", cex = 2, line = 0.5)
draw.rectangle(upstream.limit, downstream.limit, ymin, ymax, border.col = border.box.color, lwd = 2)
mtext("Effect", side = 2, font = 2, col = title.color)

if(!embed.figures){
    dev.off()
}
```

\pagebreak

## Figure 6 - Example Genetic and Epigenetic States for One Gene

Example of epigenetic states and imuptation results for a single 
gene, \textit{Pkd2}. (A) The variance in DO gene expression 
explained at each position along the gene body by each of the 
imputed genomic features: SNPs - red X's, Chromatin State - blue 
plus signs, and Percent Methylation - green circles. The horizontal 
dashed line shows the variance explained by the haplotype. For 
reference, the arrow below this panel runs from the TSS of 
\textit{Pkd2} to the TES and shows the direction of transcription. 
(B) The chromatin states assigned to each 200 bp window in this 
gene for each inbred mouse strain. States are colored by their 
effect on gene expression in the inbred mice. Red indicates a 
positive effect on gene expression, and blue indicates a negative 
effect. Each row shows the chromatin states for a single inbred strain, 
which is indicated by the label on the left. (C) SNPs along the gene 
body for each inbred strain. The reference genotype is shown in gray. 
SNPs are colored by genotype as shown in the legend. (D) Percent DNA 
methylation for each inbred strain along the \textit{Pkd2} gene body. 
Percentages are binned into 0\% (blue) 50\% (yellow) and 100\% (red). 
(E) Haplotype effects for expression of \textit{Pkd2} in the DO. 
Haplotype effects are colored by from which each allele was derived. 
(F) \textit{Pkd2} expression levels across inbred mouse strains. For 
ease of comparison, all panels B through F are shown in the same order 
as the haplotype effects. 

```{r read_example_data, echo = FALSE}
gene.info <- readRDS(here("Data", "RNASeq", "RNASeq_gene_info.RData"))
strain.table <- as.matrix(read.delim(here("Data", "support_files", "strain.color.table.txt"),
comment.char = "!", header = FALSE))

expr.data <- readRDS(here("Data", "DOQTL", "DO_Expression.RDS")) 
expr <- expr.data$expr
covar <- expr.data$covar

chrom.mats <- readRDS(file.path(results.dir, 
    paste0("Chromatin_States_", num.states, "_full_gene_1000.RData")))

chrom.r2 <- readRDS(file.path(results.dir, "chQTL.R2.RDS"))
methyl.r2 <- readRDS(here("Results", "RRBS", "RRBS.R2.RDS"))
snp.r2 <- readRDS(here("Results", "SNPs", "SNP.R2.RDS"))
eqtl.r2 <- readRDS(file.path(results.dir, "eQTL.R2.RDS"))

#inbred.expr <- readRDS(here("Data", "RNASeq", "Strain_Scaled_C_Expression.RData")) #origin lost - need to find or redo
inbred.expr <- readRDS(here("Data", "RNASeq", "StrainsEffCts9_vst.RDS"))
inbred.strain <- substr(colnames(inbred.expr), 1, 2)

snp.alleles <- readRDS(here("Results", "SNPs", "SNP.by.Position.RDS")) #generated in 4.0_Impute_SNPs.Rmd
methyl.mats <- readRDS(here("Results", "RRBS", "Aligned.Methyl.Mats.RDS")) #generated in 3.1.1_RRBS_Analysis.Rmd

eqtl.stats <- readRDS(here("Data", "DOQTL", "eQTL_statistics.RDS")) #generated in 1.1_DO_eQTL.Rmd
```

```{r example_fun, echo = FALSE}
get_snp_scan <- function(gene.id){
    snp.idx <- which(names(snp.r2) == gene.id)
    if(length(snp.idx) == 0){
        return(NA)
    }else{
        return(snp.r2[[snp.idx]])
    }
}

get_chrom_mat <- function(gene.id){
    chrom.idx <- which(names(chrom.mats) == gene.id)
    return(chrom.mats[[chrom.idx]])
}

#rename states based on order of effects
#1 (most negative) to num.states (most positive)
rename_states <- function(chrom.mat, state.order){
    new.chrom.mat <- chrom.mat
    for(i in 1:length(state.order)){
        new.chrom.mat[which(chrom.mat == state.order[i])] <- i
    } 
    return(new.chrom.mat)
}

get_chrom_scan <- function(gene.id){
    chrom.idx <- which(names(chrom.r2) == gene.id) 
    if(length(chrom.idx) == 0){
    return(matrix(NA, ncol = 1))
    }
    return(chrom.r2[[chrom.idx]])
}

get_methyl_mat <- function(gene.id){
    gene.name <- gene.info[which(gene.info[,"ensembl_gene_id"] == gene.id)[1],"external_gene_name"]
    gene.locale <- which(names(methyl.mats) == gene.name)
    if(length(gene.locale) == 0){return(NULL)}
    gene.mat <- methyl.mats[[gene.locale]]
    return(gene.mat)
}

get_methyl_r2 <- function(gene.id){
    gene.locale <- which(names(methyl.r2) == gene.id)
    r2.scores <- methyl.r2[[gene.locale]]
}

#remove dba if we are using haplotypes to order the data
get_ordered_expr <- function(gene.id, remove.dba = TRUE){
    gene.idx <- which(rownames(inbred.expr) == gene.id)
    gene.expr <- scale(inbred.expr[gene.idx,])
    u_strain <- unique(inbred.strain)
    expr.by.strain <- lapply(u_strain, function(x) gene.expr[which(inbred.strain == x)])
    names(expr.by.strain) <- u_strain
    if(remove.dba){
        dba.locale <- which(u_strain == "DB")
        expr.by.strain <- expr.by.strain[-dba.locale]
    }
    expr.mean <- sapply(expr.by.strain, mean)
    mean.order <- order(expr.mean)
    return(expr.by.strain[mean.order])
}

get_snp_alleles <- function(gene.id){
    gene.idx <- which(names(snp.alleles) == gene.id)
    if(length(gene.idx) == 0){
        return(NA)
    }
    snp.array <- snp.alleles[[gene.idx]]
    #flatten to letters by position for each strain
    allele.calls <- apply(snp.array, 1, function(x) apply(x, 1, function(y) which(y > 0)[1]))
    #reduce complexity to show only where variants differ from reference (B6)
    has.diff <- which(apply(allele.calls, 2, function(x) length(unique(x))) > 1)
    if(length(has.diff) == 0){return(NULL)}
    trimmed.alleles <- allele.calls[,has.diff,drop=FALSE]
    for(p in 1:ncol(trimmed.alleles)){
        trimmed.alleles[which(trimmed.alleles[,p] == unlist(trimmed.alleles[2,p])),p] <- NA
    }
    return(trimmed.alleles)
}

get_haplotype_r2 <- function(gene.id){
    gene.idx <- which(rownames(eqtl.r2) == gene.id)
    return(eqtl.r2[gene.idx,1])
}

get_haplotype_coef <- function(gene.id){
    gene.idx <- which(names(eqtl.stats) == gene.id)
    return(eqtl.stats[[gene.idx]]$coef)
}

plot_together <- function(gene.id){
        
    gene.info.idx <- which(gene.info[,1] == gene.id)[1]
    if(is.na(gene.info.idx)){
        return(NULL)
    }

    gene.name <- gene.info[gene.info.idx,"external_gene_name"]
    gene.strand <- gene.info[gene.info.idx,"strand"]
    if(gene.strand == 1){
        tss.pos <- gene.info[gene.info.idx,"start_position"]
        tes.pos <- gene.info[gene.info.idx,"end_position"]
    }else{
        tss.pos <- gene.info[gene.info.idx,"end_position"]
        tes.pos <- gene.info[gene.info.idx,"start_position"]
    }

    hap.r2 <- get_haplotype_r2(gene.id)

    if(length(hap.r2) == 0){
    return(NULL)
    }

    hap.coef <- get_haplotype_coef(gene.id)

    gene.snp.r2 <- get_snp_scan(gene.id)
    gene.snp.alleles <- get_snp_alleles(gene.id)
    if(length(gene.snp.alleles) > 1){
        rownames(gene.snp.alleles) <- strain.table[order.strains(rownames(gene.snp.alleles), 
        strain.table[,1], strain.table),6]
    }

    gene.chrom.r2 <- get_chrom_scan(gene.id)
    gene.chrom.mat <- get_chrom_mat(gene.id)
    
    gene.methyl.mat1 <- get_methyl_mat(gene.id)
    if(length(gene.methyl.mat1) > 0){
        #quartz();pheatmap(gene.methyl.mat1, cluster_rows = FALSE, cluster_cols = FALSE)
        gene.methyl.mat2 <- t(apply(gene.methyl.mat1, 1, function(x) bin.vector(x, c(0, 50, 100))))
        #quartz();plot(gene.methyl.mat1, gene.methyl.mat2)
        #quartz();pheatmap(gene.methyl.mat2, cluster_rows = FALSE, cluster_cols = FALSE)
        gene.methyl.mat3 <- gene.methyl.mat2[,apply(gene.methyl.mat2, 2, function(x) all(!is.na(x))),drop=FALSE]
        #quartz();pheatmap(gene.methyl.mat3, cluster_rows = FALSE, cluster_cols = FALSE)
        gene.methyl.r2 <- get_methyl_r2(gene.id)
    }else{
        gene.methyl.mat3 <- gene.methyl.mat1
        gene.methyl.r2 <- NULL
        }
    
    gene.expr <- get_ordered_expr(gene.id)
    ordered.hap <- hap.coef[order(hap.coef[1:8])]

    if(length(gene.expr) > 1){
        chrom.strain.order <- rev(order.strains(names(ordered.hap), 
            colnames(gene.chrom.mat), strain.table))
        if(length(gene.snp.alleles) > 1){
            snp.strain.order <- rev(order.strains(names(ordered.hap), 
            rownames(gene.snp.alleles), strain.table))
            snp.strain.order <- snp.strain.order[which(!is.na(snp.strain.order))]
        }
        methyl.strain.order <- order.strains(names(ordered.hap), 
            rownames(gene.methyl.mat3), strain.table)
    }else{
        strain.order <- 1:ncol(gene.chrom.mat)
        snp.strain.order <- 1:nrow(gene.snp.alleles)
        methyl.strain.order <- 1:nrow(gene.methyl.mat3)
    }
    
    if(length(gene.snp.r2) > 0 && !is.na(gene.snp.r2)){
        snp.pos <- as.numeric(sapply(strsplit(names(gene.snp.r2), "_"), function(x) x[2]))
    }
    chrom.pos <- as.numeric(rownames(gene.chrom.r2))
    methyl.pos <- as.numeric(rownames(gene.methyl.r2))

    all.pos <- list(snp.pos, chrom.pos, methyl.pos)
    #limit to chromatin position
    global.max.pos <- max(chrom.pos)
    global.min.pos <- min(chrom.pos)

    global.max.r2 <- max(c(gene.chrom.r2[,1], gene.snp.r2, gene.methyl.r2, 
        hap.r2), na.rm = TRUE)

    if(!is.finite(global.max.r2)){
        return(NULL)
    }

    #layout.mat <- matrix(c(1:5, 0, 0, 6, 6, 0), ncol = 2, byrow = FALSE)
    layout.mat <- matrix(c(1,0,2,0,3,6,4,7,5,7), ncol = 2, byrow = TRUE)
    layout(layout.mat, heights = c(1,0.2, 1, 1, 1), widths = c(1,0.4))
    #layout.show(7)

    #panel 1 - R2 scores for all features
    par(mar = c(0,4,4,4))
    ylim <- get_plot_bounds(min.val = 0, max.val = hap.r2, scale.factor = 10)
    plot(x = snp.pos, gene.snp.r2, pch = "X", col = "#e41a1c", cex = 1.5,
        ylab = "", axes = FALSE,
    xlim = c(global.min.pos, global.max.pos), ylim = ylim)
    points(x = as.numeric(rownames(gene.chrom.r2)), gene.chrom.r2[,1], pch = "+", 
        col = "#377eb8", cex = 2)
    points(x = as.numeric(names(gene.methyl.r2)), gene.methyl.r2, pch = "O",
        col = "#4daf4a", cex = 1)
    abline(h = hap.r2, lty = 2)
    mtext("Variance Explained", side = 2, line = 2.5, col = title.color, font = 2, cex = 0.8)
    axis(2)

    #legend for panel 1
    par(xpd = NA)
    legend(x = global.max.pos, y = global.max.r2, pch = c("X", "+", "O"), 
        col = c("#e41a1c", "#377eb8", "#4daf4a"), legend = c("SNP", "Chrom", "Methyl"))
    par(xpd = TRUE)

    #panel 2 - direction of transcription
    par(mar = c(0,4,0,4))
    plot.new()
    plot.window(xlim = c(global.min.pos, global.max.pos), ylim = c(0,1))
    arrows(x0 = tss.pos, y0 = 0.5, x1 = tes.pos, col = zero.line.color, lwd = 2, length = 0.15)

    #panel 3 - chromatin state matrix
    par(mar = c(0.2,4,0.2,4))
    renamed.chrom <- rename_states(t(gene.chrom.mat[,chrom.strain.order]), state.order)
    #if we are using a subset of states, we need to color them appropriately
    plot.chrom.mat(renamed.chrom, num.states = num.states, 
        xlim = c(global.min.pos, global.max.pos), state.cols = all.state.col,
        ylab = "")
    mtext("Chromatin State", side = 2, line = 1.5, col = title.color, font = 2)

    par(mar = c(0,4,1,4))

    if(length(gene.snp.alleles) > 0 && ncol(gene.snp.alleles) > 1){
        snp.colors <- c("A" = "#5CC93B", "C" = "#0D00C4", "G" = "#F3B63F", "T" = "#BB261A")
        plot.snp.mat(gene.snp.alleles[snp.strain.order,], num.states = 4, 
        xlim = c(global.min.pos, global.max.pos), ylab = "", state.cols = snp.colors,
        state.labels = c("A", "C", "G", "T"), empty.cell.color = "gray90")
        mtext("SNPs", side = 2, line = 1.5, col = title.color, font = 2)
    }
    if(length(gene.snp.alleles) > 0 && ncol(gene.snp.alleles) == 1){
        barplot(gene.snp.alleles[snp.strain.order,], horiz = TRUE, 
        las = 2, main = paste(round(as.numeric(colnames(gene.snp.alleles))/1e6, 2), "Mb"))
        legend.labels = paste0(1:4, "=", c("A", "C", "G", "T"))
        legend("topleft", legend = legend.labels)
    }
    if(length(gene.snp.alleles) == 0){
        plot.text("No SNPs")
    }

    if(length(gene.methyl.mat3) > 0){
    #subset to same range as chromatin state matrix
    plot.methyl.mat(methyl.mat = gene.methyl.mat3[methyl.strain.order,,drop=FALSE], 
        xlim = c(global.min.pos, global.max.pos), ylab = "")
    mtext("% Methylation", side = 2, line = 1.5, col = title.color, font = 2)

    }else{
    plot.text("No Methylation Information")
    }

    par(mar = c(0,1,0,1))
    hap.cols <- col.table[match(names(hap.coef), col.table[,5]),3]
    hap.order <- order(hap.coef[1:8])
    barplot(hap.coef[hap.order], col = hap.cols[hap.order], horiz = TRUE, las = 2,
    names = rev(rownames(renamed.chrom)))
    mtext("Haplotype Effect", side = 1, line = 3, col = title.color, 
        font = 2, cex = 0.7)


    if(length(gene.expr) > 1){
        par(mar = c(3,0,7,1))
        expr.order <- order.strains(names(ordered.hap), 
            names(gene.expr), strain.table)
        ordered.expr <- gene.expr[expr.order] #order based on haplotype coef
        pt.cols <- strain.table[order.strains(names(ordered.expr), strain.table[,1], 
        strain.table),3]
        #barplot(rep(1:length(pt.cols)), col = pt.cols)
        ymin <- 0; ymax = length(expr.order)
        xmin <- min(unlist(ordered.expr)); xmax <- max(unlist(ordered.expr))
        x.range <- xmax - xmin
        text.x <- xmin - (x.range*0.05)
        y.coord <- segment.region(ymin, ymax, length(ordered.expr), "ends")
        par(xpd = NA)
        boxplot(ordered.expr, horizontal = TRUE, border = pt.cols, 
            col = "white", axes = FALSE, at = y.coord)
        for(st in 1:length(ordered.expr)){
            points(x = ordered.expr[[st]], y = rep(y.coord[st], length(ordered.expr[[st]])), 
            col = pt.cols[[st]], pch = 16)
            text(x = text.x, y = y.coord[st], adj = 1, labels = rev(rownames(renamed.chrom))[st])
        } 
        par(xpd = TRUE)
        axis(1)
        mtext("Inbred Expression (AU)", side = 1, line = 2, col = title.color, 
            font = 2, cex = 0.7)
        
    }else{
        plot.text("No Inbred Expression Data")
    }

    mtext(gene.name, side = 3, outer = TRUE, line = -2.5, col = title.color, font = 2)
}
```

```{r pick.gene, echo = FALSE}
gene.name <- "Pkd2"
#gene.name = "Irf5"
```

```{r plot_example, echo = FALSE, fig.height = 6, fig.width = 6.5}
gene.id <- gene.info[which(gene.info[,"external_gene_name"] == gene.name)[1],1]
if(!embed.figures){
    png(here("Documents", "3.Manuscript", "Figures", "Fig6_Example.png"),
    width = 6.5, height = 6, units = "in", res = 300)
}
plot_together(gene.id)
if(!embed.figures){
    dev.off()
}
```

\pagebreak

## Figure 7 - Expression Variance Explained in the DO

Chromatin state explains variation in gene expression in an outbred population. 
A. Distributions of gene expression variance explained by different genomic 
features: local haplotype, local imputed chromatin state, local SNP genotype,
and local imputed DNA methylation status. B. Direct comparisons of variance 
explained by local haplotype, and the three other genomic features: imputed
chromatin state, SNP genotype, and imputed DNA methylation status. Blue lines
show $y = x$. Each point is a single transcript.

```{r imputed_read_data, echo = FALSE}
#matched variance explained from each genomic feature
all.var.exp <- readRDS(here("Results", "SNPs", "All.Variance.Explained.RDS")) #generated in 4.1_Overlay_Imputed_R2.Rmd
colnames(all.var.exp) <- c("Haplotype", "Chromatin\nState", "SNP", "DNA\nMethylation")
```

```{r plot_imputed, echo = FALSE, fig.width = 10, fig.height = 2.5}
if(!embed.figures){
    png(here("Documents", "3.Manuscript", "Figures", "Fig7_Imputation.png"),
    width = 10, height = 2.5, units = "in", res = 300)
}
#quartz(width = 10, height = 2.5)
layout.mat <- matrix(c(1:4, 0, 5, 5, 5), nrow = 2, byrow = TRUE)

#quartz(width = 10, height = 2.5)
layout(layout.mat, heights = c(1, 0.15))
par(mar = c(2,4,1,1))

boxplot(all.var.exp, names = NA, cex.axis = 1.5)
mtext("Variance Explained", side = 2, col = title.color, font = 2, line = 2.5)

par(xpd = NA)
for(i in 1:ncol(all.var.exp)){
    if(i %% 2 == 0){
        text.adj <- c(0.5, 0);text.y = -0.2
    }else{
        text.adj <- c(0.5, 0.5);text.y = -0.22
    }
    text(x = i, y = text.y, labels = colnames(all.var.exp)[i], adj = text.adj,
    col = title.color, font = 2, cex = 1)
    if(i %% 2 == 1){
        segments(x0 = i, y0 = text.y+0.05, y1 = -0.05)
    }
}
par(xpd = TRUE)

axis.min <- 0
axis.max <- 1

comp.pairs <- cbind(rep(1, (ncol(all.var.exp)-1)), 2:ncol(all.var.exp))

for(i in 1:nrow(comp.pairs)){
    if(i > 1){par(mar = c(2,2,1,1))}
    idx1 <- comp.pairs[i,1]
    idx2 <- comp.pairs[i,2]
    plot.new()
    plot.window(xlim = c(axis.min, axis.max), ylim = c(axis.min, axis.max))
    segments(x0 = 0, x1 = 1, y0 = 0, y1 = 1, col = "lightblue", lwd = 3)
    points(all.var.exp[,idx1], all.var.exp[,idx2], pch = 16,col = "darkgray", cex = 0.7)
    axis(1, at = c(0, 0.5, 1), cex.axis = 1.5)
    axis(2, at = c(0, 0.5, 1), cex.axis = 1.5)
    text(x = 0.5, y = 1, labels = colnames(all.var.exp)[idx2], col = title.color, 
    font = 2, adj = c(0.5, 1), cex = 1.5)
    if(i == 1){
        par(xpd = NA)
        text(x = -0.3, y = 0.5, labels = "Variance Explained by Genomic Feature", 
        adj = c(0.5, 1), srt = 90)
        par(xpd = TRUE)
    }
}


#add axis label for all three dot plots
par(mar = c(0,4,0,1))
plot.new()
plot.window(xlim = c(0,1), ylim = c(0,1))
segments(x0 = 0, x1 = 1, y0 = 1, lwd = 2, col = zero.line.color)
text(x = 0.5, y = 0.5, labels = "Variance Explained by Founder Haplotype", 
    col = title.color, font = 2, cex = 1.5)

if(!embed.figures){
    dev.off()
}
```
