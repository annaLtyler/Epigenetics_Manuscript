
## Correlation with MDS
Also calculate the correlation between the multi-dimensionally scaled
state matrix and gene expression. This won't tell us which states
have good correlations with expression, but will tell us overall
how well the states capture expression.

The barplot below shows the median aboslute value of the correlation 
between the MDS matrix and expression. All numbers of states are very
similar, but the five-state model has a slight edge. 

```{r mds}
all.mds <- vector(mode = "list", length = length(state.num))
names(all.mds) <- basename(state.num)[state_order]
for(i in 1:length(state.num)){
	mds.file <- list.files(path = state.num[state_order[i]], pattern = "MDS_Expression_Cor", full.names = TRUE)
	if(length(mds.file) > 0){all.mds[[i]] <- readRDS(mds.file)}
}

all.mds.r <- lapply(all.mds, function(x) signif(unlist(x$all.r), 2))
all.mds.p <- lapply(all.mds, function(x) x$all.p)

mds.mat <- Reduce("cbind", all.mds.r)
mds.mat <- apply(mds.mat, 2, abs)
colnames(mds.mat) <- names(all.mds)
barplot(apply(mds.mat, 2, function(x) median(x, na.rm = TRUE)), las = 2)
```

We also looked gene by gene for which model had the best correlation.
The following barplot shows the number of times each model had the 
best correlation for the genes. The lowest number of states is clearly
the best most of the time.

```{r best_state}
best.state <- unlist(apply(mds.mat, 1, function(x) if(all(is.na(x))){NA}else{which.max(x)}))
best.table <- table(best.state)
names(best.table) <- names(all.mds)
par(mar = c(10, 4, 4, 4))
barplot(best.table, las = 2)
```

## DNA methylation density by methylation percent

We also looked individually at the density of sites that were 0, 50, or 100% methylated.
All are sparse in the gene body and dense at the TSS. There are no differences in patterns
across the different types, just in degree.

This also can't distinguish from sites that have variable methylation percentages
across strains, so it might not be a good measure. 

```{r sub_methyl_dens}
rounded.methyl <- lapply(methyl.mats, function(x) round(x/50)*50)


bins <- c(0, 50, 100)
for(i in 1:length(bins)){
  sub_methyl_idx <- lapply(rounded.methyl, function(x) unique(which(x == bins[i], arr.ind = TRUE)[,2]))
  sub_methyl_consec <- lapply(1:length(sub_methyl_idx), function(x) if(length(sub_methyl_idx[[x]]) > 1){consec.pairs(as.numeric(colnames(rounded.methyl[[x]])[sub_methyl_idx[[x]]]))}else{NA})
  sub_methyl_dist <- lapply(sub_methyl_consec, function(x) if(length(x) >  1){x[,2] - x[,1]}else{NA})
  
  for(j in 1:length(methyl_dist)){
    if(length(sub_methyl_idx[[j]]) > 1 && !is.null(colnames(norm_rrbs[[j]]))){
      consec.coord <- consec.pairs(as.numeric(colnames(norm_rrbs[[j]])[sub_methyl_idx[[j]]]))
      mean.coords <- rowMeans(consec.coord)
      names(sub_methyl_dist[[j]]) <- mean.coords
    }
  }

 avg_sub_methyl_dist <- plot.centered.vals(val.list = sub_methyl_dist, 
    seq.by = seq.by, min.representation = 10, ylim = c(0, 10000),
    plot.label = paste("Average Distance to Next Methylation Position"),
    ylab = "Distance to Next Methylation Position", return.means = FALSE)
}

if(is.interactive){quartz()}
methyl_dens_file <- here("Results", "RRBS", "Methylation_Density.RDS")
if(!file.exists(methyl_dens_file) || delete.previous){
  avg_methyl_dist <- plot.centered.vals(val.list = methyl_dist, 
    seq.by = seq.by, min.representation = 10, ylim = c(0, 3500),
    plot.label = paste("Average Distance to Next Methylation Position"),
    ylab = "Distance to Next Methylation Position", return.means = FALSE)
  abline(v = c(0,1))
  saveRDS(avg_methyl_dist, methyl_dens_file)
}else{
  avg_methyl_dist <- readRDS(methyl_dens_file)
  plot.centered.mat(avg_methyl_dist, ylim = c(0, 3500),
    plot.label = paste("Average Distance to Next Methylation Position"),
    ylab = "Distance to Next Methylation Position")
      abline(v = c(0,1))
}
```


## Permutations for RRBS

From 3.2_Impute_RRBS.Rmd

## Permute RRBS

We permuted the DNA methylation as we did for chromatin 
states. We permute the haplotype that is assigned to 
each DNA methylation vector, re-do the imputation, 
and recalculate the LOD scores and R2 values.


```{r perm_fun}
#This function and the perm data will be exported to the
#clusters
scan_one_rrbs <- function(perm.data, p){
    
  perm.order <- order.mat[p,]

  imp.geno <- rrbs_geno(gene.rrbs.array = perm.data$rrbs.mat, 
            haplotype.matrix = perm.data$hap.mat, 
            gene.chr = perm.data$chr, perm.order)
          
  if(is.na(imp.geno)){return(NA)}

  one.lod <- scan1(imp.geno, perm.data$gene.expr)
  #quartz();plot(as.numeric(rownames(all.rrbs.lod[[i]])), all.rrbs.lod[[i]][,1], type  = "h",xlab = "Genomic Position", ylab = "DNA Methylation LOD score")
  regression.models <- apply(imp.geno[[1]][common.genoprob.locale,1,], 2, 
      function(x) if(var(x) > 0){lm(perm.data$gene.expr[common.expr.locale,]~x)}else{NA})
  one.rrbs.r2 <- sapply(regression.models, function(x) if(length(x) > 1){summary(x)$adj.r.squared}else{NA})

  results <- list("one.lod" = one.lod, 
    "one.r2" = one.rrbs.r2)

  return(results)
}
```

```{r select_nperm}
nperm = 1000
```


```{r set_perm}
#select a set of permutations for which none of 
#the haplotypes remain in their original position.
#these are called derrangements
perm.mat <- derrangements(8)
#sample a random set of derraangements to use
#for all transcripts
perm.rows <- sample(1:nrow(perm.mat), nperm)
order.mat <- perm.mat[perm.rows,]
```



```{r perm_files}

perm.lod.rrbs.file <- here("Results", "RRBS", "Perm.RRBS.LOD.RDS")
perm.r2.rrbs.file <- here("Results", "RRBS", "Perm.RRBS.R2.RDS")

if(file.exists(perm.lod.rrbs.file)){
  perm.rrbs.lod <- readRDS(perm.lod.rrbs.file)
  perm.rrbs.r2 <- readRDS(perm.r2.rrbs.file)

  #figure out where we left off.
  not.na <- which(!is.na(perm.rrbs.lod[,1]))  
  left.off <- max(not.na)
  start.at <- left.off + 1
}else{
  start.at <- 1
  #if we are at the beginning, intialize all the objects for holding
  #results. 
  perm.rrbs.lod <- perm.rrbs.r2 <- matrix(NA, nrow = length(methyl.id), ncol = nperm)
  rownames(perm.rrbs.lod) <- rownames(perm.rrbs.r2) <- methyl.id
}

```


```{r set_cl, warning = FALSE}
save.every = 100
if(start.at < length(methyl.id)){
  #set up the clusters if we need to run perutations
  n.cores <- detectCores() - 1
  to.export <- c("scan1", "scan1coef", "scan_one_rrbs", "rrbs_geno", 
    "order.mat", "bin.vector", "abind", "common.genoprob.locale", 
    "common.expr.locale")

  #create and register multiple cores for parallele permutations
  cl <- makeCluster(n.cores)
  registerDoParallel(cl)
  #export everything we need to the cluster
  #this takes time upfront, but the parallelization
  #saves a huge amount of time overall
  clusterExport(cl, to.export) 
}
```


```{r perm_rrbs}

if(start.at < length(methyl.id)){
  sink(here("Results", "RRBS", "progress.txt"))
  for(tr in start.at:length(perm.rrbs.lod)){
      cat(paste0(tr, ":"))
      methyl.mat.locale <- which(names(methyl.mats) == ordered.transcript.info[tr,"external_gene_name"])

      #checks for methylation matrix
      if(length(methyl.mats[[methyl.mat.locale]]) <= 1){cat(" Cannot locate array\n");next()} #it exists
      if(ncol(methyl.mats[[methyl.mat.locale]]) > 2000){cat(" Array too large\n");next()} #is is of a reasonable size

      transcript.chr <- ordered.transcript.info[tr,"chromosome_name"]

      #checks for chromosome
      if(is.na(transcript.chr) || transcript.chr == "X" || transcript.chr == "MT"){cat(" Transcript not on autosome\n");next()}
      
      rrbs.mat <- methyl.mats[[methyl.mat.locale]][strain.order,,drop=FALSE]
      hap.mat <- gene.marker[[tr]]
      rrbs.array <- rrbs_geno(gene.rrbs.array = rrbs.mat, 
        haplotype.matrix = hap.mat, 
        gene.chr = ordered.transcript.info[i,"chromosome_name"])

      #check for rrbs.array
      if(is.na(rrbs.array)){cat(" No RRBS array\n"); next()}

      expr.locale <- which(colnames(expr) == methyl.id[tr])

      gene.expr.choice <- as.logical(length(expr.locale))
      
      #check for gene expr
      if(length(expr.locale) == 0){cat(" Cannot find expression\n");next()}
      gene.expr <- expr[,expr.locale,drop=FALSE]
      adj.expr <- adjust(gene.expr, covar)
      
      perm.data <- list("gene.expr" = gene.expr, 
        "rrbs.mat" = rrbs.mat, "hap.mat" = hap.mat,
        "chr" = ordered.transcript.info[tr,"chromosome_name"])

      #send the new gene ID to the clusters
      clusterExport(cl, "perm.data")

      #do the permutations in parallel
      perm.rrbs.results <- parLapply(cl, 1:nperm, 
          function(p) scan_one_rrbs(perm.data, 
          p = p))

      #check for data returned from permutations
      if(!all(sapply(perm.rrbs.results, length) > 1)){cat(" No data returned\n");next()}
      
      perm.tr.lod <- lapply(perm.rrbs.results, function(x) x$one.lod)
      perm.tr.r2 <- lapply(perm.rrbs.results, function(x) x$one.r2)

      #keep the maximum r2 and LOD values from each permutation.
      perm.rrbs.lod[tr,] <- t(sapply(perm.tr.lod, function(x) max(x[,1])))
      perm.rrbs.r2[tr,] <- t(sapply(perm.tr.r2, function(x) max(x, na.rm = TRUE)))

      if(tr %% save.every == 0){
          saveRDS(perm.rrbs.lod, perm.lod.rrbs.file)
          saveRDS(perm.rrbs.r2, perm.r2.rrbs.file)
      }
    cat(" Finished permutations\n")
  } #end looping over transcripts
  #save again at the very end
  saveRDS(perm.rrbs.lod, perm.lod.rrbs.file)
  saveRDS(perm.rrbs.r2, perm.r2.rrbs.file)

  sink()

  #close the clusters at the end and save the final objects
  stopCluster(cl)

} #end case for needing to do more permutations.
```

## Assess permutations

To assess the permutations, we look at the distribution
of empirical p values. If this distribution is uniform,
then it is the imputation itself that is explaining the
LOD scores we see. If the distribution is skewed toward
0, then the DNA methylation is adding something beyond
the imputation itself.

The plots below show the distributions of p values for both 
the R2 statistic and the LOD score statistic. Both are
skewed toward 0. The dot plot shows that the p values for 
these two statistics are highly correlated, but not identical.

```{r assess_lod_perm, fig.width = 8, fig.height = 8}
geno.lod <- readRDS(here("Results", "ChromHMM", "14_states_C", "eQTL.lod.RDS"))
low.lod <- which(geno.lod[,"Additive"] <= 6)
low.lod.idx <- match(rownames(geno.lod)[low.lod], names(all.rrbs.lod))

max.rrbs.lod <- sapply(all.rrbs.lod, function(x) if(length(x) > 1){max(x[,1], na.rm = TRUE)}else{NA})
lod.p <- sapply(1:length(all.rrbs.lod), 
  function(x) if(!all(is.na(perm.rrbs.lod[x,]))){emp.p(max.rrbs.lod[x], perm.rrbs.lod[x,])}else{NA})
names(lod.p) <- names(all.rrbs.lod)

max.rrbs.r2 <- sapply(all.rrbs.r2, function(x) if(!all(is.na(x))){max(x, na.rm = TRUE)}else{NA})
r2.p <- sapply(1:length(all.rrbs.r2), 
  function(x) if(!all(is.na(perm.rrbs.r2[x,]))){emp.p(max.rrbs.r2[x], perm.rrbs.r2[x,])}else{NA})
names(r2.p) <- names(all.rrbs.r2)

results.table <- cbind(max.rrbs.lod, lod.p, max.rrbs.r2, r2.p)
saveRDS(results.table, here("Results", "RRBS", "Perm_results.RDS"))

par(mfrow = c(2,2))
lod.p[low.lod.idx] <- NA
hist(lod.p, breaks = 100, main = "LOD score p",
  xlab = "p value")

r2.p[low.lod.idx] <- NA
hist(r2.p, breaks = 100, main = "R2 p",
  xlab = "p value")

plot(-log10(lod.p+1e-3), -log10(r2.p+1e-3), xlab = "-log10(LOD p)",
  ylab = "-log10(R2 p)", main = "LOD p vs. R2 p")
```

The following plots show each test statistic vs. its
p values. In general higher test statistics have lower
p values, but this is not strictly true. 


```{r stat_v_p, fig.width = 8, fig.height = 4}
par(mfrow = c(1,2))
plot(max.rrbs.lod, -log10(lod.p+1e-3), xlab = "LOD", ylab = "-log10(p)", 
  main = "LOD vs. LOD -log10(p)")

plot(max.rrbs.r2, -log10(r2.p+1e-3), xlab = "Variance Explained", 
  ylab = "-log10(p)", main = "R2 vs. R2-log10(p)")
```

```{r example, eval = FALSE}
examples <- which(lod.p == 0)
i <- examples[5]
gene.name = gene.info[which(gene.info[,"ensembl_gene_id"] == names(lod.p)[i]),"external_gene_name"][1]
xlim <- c(min(c(perm.rrbs.lod[i,], max.rrbs.lod[i])), max(c(perm.rrbs.lod[i,], max.rrbs.lod[i])))
hist_with_points(c(perm.rrbs.lod[i,], max.rrbs.lod[i]), 
  col = c(rep("gray", ncol(perm.rrbs.lod)), "red"), xlab = "LOD", main = gene.name)
abline(v = max.rrbs.lod[i], col = "red")
```

## Permutations for chromarobs

From 2.1_chromaprobs.Rmd

```{r select_nperm}
nperm = 1000
```

```{r perm_fun}
get_data_for_perm <- function(gene.id){

    info.locale <- which(transcript.info[,"ensembl_gene_id"] == gene.id)[1]
    gene.name <- transcript.info[info.locale,"external_gene_name"]
    if(is.na(gene.name)){return(NA)}

    expr.locale <- which(colnames(expr) == gene.id)
    chrom.locale <- which(names(chrom.mats) == gene.id)

    if(length(expr.locale) == 0 || length(chrom.locale) == 0){
        return(NA)
    }

    one.chrom <- chrom.states[[chrom.locale]]
    one.expr <- expr[,expr.locale,drop=FALSE]
    gene.idx <- which(names(transcript.haplotypes) == gene.id)
    haps <- transcript.haplotypes[[gene.idx]]
    gene.chr <- transcript.info[info.locale,"chromosome_name"]

    data.for.perm <- list("name" = gene.name, "chrom" = one.chrom, 
        "expr" = one.expr, "haps" = haps, "chr" = gene.chr)
    return(data.for.perm)
}

imp_chrom <- function(perm.data, perm.order){
 
  chrom.order <- match.order(colnames(perm.data$haps),
    rownames(perm.data$chrom), strain.key)

    ref.chroms <- perm.data$chrom
    if(!is.null(perm.order)){
        ref.chroms <- ref.chroms[perm.order,,]
        rownames(ref.chroms) <- colnames(perm.data$haps)
    }

    haps <- perm.data$haps
    chrom.array <- array(NA, dim = c(nrow(haps), ncol(ref.chroms), dim(ref.chroms)[3]))
    rownames(chrom.array) <- rownames(haps)
    colnames(chrom.array) <- paste0("State", colnames(ref.chroms))
    dimnames(chrom.array)[[3]] <- dimnames(ref.chroms)[[3]]
  
    for(p in 1:dim(ref.chroms)[3]){ #for each position
        chrom.mat <- ref.chroms[,,p]
        chrom.array[,,p] <- haps[,,1] %*% chrom.mat
        }

    #add attributes
    gene.chr <- perm.data$chr
    one.geno <- list(chrom.array)
    names(one.geno) <- gene.chr
    if(gene.chr == "X"){
      attr(one.geno, "is_x_chr") <- TRUE
    }else{
      attr(one.geno, "is_x_chr") <- FALSE
    }
    attr(one.geno, "crosstype") <- "do"
    attr(one.geno, "alleles") <- LETTERS[1:8]
    attr(one.geno, "alleleprobs") <- TRUE
    attr(one.geno, "class") <- c("calc_genoprob", "list")
 
    return(one.geno)
}


#This function and the perm data will be exported to the
#clusters
perm_one_transcript <- function(perm.data, p, 
  geno_type = c("chromatin", "genotype")){
  
  if(length(perm.data) == 1){return(NA)}
  
  perm.order <- order.mat[p,]

  imp.geno <- imp_chrom(perm.data, perm.order)

  if(is.na(imp.geno)){return(NA)}

  #check for variation
  test.var <- round(apply(imp.geno[[1]], 3, function(x) apply(x, 2, function(y) var(y))), 2)
  no.var <- length(which(apply(test.var, 1, function(x) length(unique(x))) > 1)) <= 1
    
  if(no.var){return(NA)}
       
  #calculate chromatin LOD scores
  chrom.lod.table <- scan1(imp.geno, perm.data$expr, addcovar = covar)
  colnames(chrom.lod.table) <- "Additive"

  #calculate chromatin state coefficients
  chrom.add.coef <- scan1coef(genoprobs = imp.geno, pheno = perm.data$expr, 
    addcovar = covar)
  chrom.coef.list <- list(chrom.add.coef[,1:num.states])
  names(chrom.coef.list) <- "Additive"

    #calculate chromatin R2
    #adjust expression for covariates first, so we don't include 
    #the covariates in the variance explained
    adj.expr <- adjust(perm.data$expr, covar)
    chrom.models.add <- apply(imp.geno[[1]], 3, function(x) lm(adj.expr~x))
    ch.add.r2 <- sapply(chrom.models.add, function(x) summary(x)$adj.r.squared)
    chrom.r2.results <- matrix(ch.add.r2, ncol = 1)
    colnames(chrom.r2.results) <- "Additive"

  results <- list("chrom.lod.table" = chrom.lod.table, 
    "chrom.coef.list" = chrom.coef.list, "chrom.r2.results" = chrom.r2.results)

  return(results)
}
```

```{r perm_files, eval = FALSE}
perm.lod.file <- file.path(results.dir, "Perm.LOD.RDS")
perm.r2.file <- file.path(results.dir, "Perm.R2.RDS")

if(file.exists(perm.lod.file)){
  perm.lod <- readRDS(perm.lod.file)
  perm.r2 <- readRDS(perm.r2.file)

  #figure out where we left off.
  not.na <- which(!is.na(perm.lod[,1]))  
  left.off <- max(not.na)
  start.at <- left.off + 1
}else{
  start.at <- 1
  #if we are at the beginning, intialize all the objects for holding
  #results. 
  perm.lod <- perm.r2 <- matrix(NA, nrow = length(common.transcripts), ncol = nperm)
  rownames(perm.lod) <- rownames(perm.r2) <- common.transcripts
}

```

```{r set_perm, eval = FALSE}
#select a set of permutations for which none of the chromatin
#states get assigned to their original haplotype.
#these are called derrangements
perm.mat <- derrangements(8)
#sample a random set of derraangements to use
#for all transcripts
perm.rows <- sample(1:nrow(perm.mat), nperm)
order.mat <- perm.mat[perm.rows,]

```

```{r set_cl, warning = FALSE, eval = FALSE}

if(start.at < length(common.transcripts)){
  #set up the clusters if we need to run perutations

  to.export <- c("scan1", "scan1coef", "covar", "perm_one_transcript",
    "num.states", "adjust", "order.mat", "imp_chrom", "match.order", "strain.key")

  #create and register multiple cores for parallele permutations
  cl <- makeCluster(n.cores)
  registerDoParallel(cl)
  #export everything we need to the cluster
  #this takes time upfront, but the parallelization
  #saves a huge amount of time overall
  clusterExport(cl, to.export) 
}
```


```{r do_perm, eval = FALSE}

lod.thresh = 6
to.perm <- which(geno.lod[,"Additive"] > lod.thresh)
do.perm <- rep(FALSE, length(common.transcripts))
do.perm[to.perm] <- TRUE

if(start.at < max(to.perm)){
  sink(file.path(results.dir, "progress.txt"))

  for(tr in start.at:length(common.transcripts)){
  #for(tr in 1:10){
    cat(paste0(tr, ":\n"))

    if(!do.perm[tr]){cat(" LOD score < 6\n");next()}

    #gene.name = "Pkd2"
    #gene.id <- transcript.info[which(transcript.info[,"external_gene_name"] == gene.name)[1],"ensembl_gene_id"]
    #tr = which(common.transcripts == gene.id)

    gene.id <- common.transcripts[tr]
    #gene.name <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == gene.id)[1],"external_gene_name"]

    perm.data <- get_data_for_perm(gene.id)

    if(is.na(perm.data)){cat(" No data returned for permutations\n");next()}
    if(dim(perm.data$chrom)[[3]] > 2000){cat(" Chromatin matrix too large\n"); next()}

    #send the new gene ID to the clusters
    clusterExport(cl, "perm.data")

    #do the permutations in parallel
    perm.chrom.results <- parLapply(cl, 1:nperm, 
        function(p) perm_one_transcript(perm.data, 
        p = p))

      #check for NAs
      if(!all(sapply(perm.chrom.results, length) > 1)){cat(" No data returned from permutations\n"); next()}

      perm.chrom.coef <- lapply(perm.chrom.results, function(x) x$chrom.coef.list)
      perm.chrom.lod <- lapply(perm.chrom.results, function(x) x$chrom.lod.table)
      perm.chrom.r2 <- lapply(perm.chrom.results, function(x) x$chrom.r2.results)

      #keep the maximum r2 and LOD values from each permutation.
      #also keep the permuted coefficients for each state
      perm.lod[tr,] <- t(sapply(perm.chrom.lod, function(x) max(x[,"Additive"])))
      perm.r2[tr,] <- t(sapply(perm.chrom.r2, function(x) max(x[,"Additive"])))

    if(tr %% save.every == 0){
      saveRDS(perm.lod, perm.lod.file)
      saveRDS(perm.r2, perm.r2.file)
    }
    cat(" Finished permutations\n")
  } #end looping through transcripts

  #close the clusters at the end and save the final objects
  stopCluster(cl)

  saveRDS(perm.lod, perm.lod.file)
  saveRDS(perm.r2, perm.r2.file)
  sink()
}
```

## Assess permutations

To assess the permutations, we look at the distribution
of empirical p values. If this distribution is uniform,
then it is the imputation itself that is explaining the
LOD scores we see. If the distribution is skewed toward
0, then the chromatin states are adding something beyond
the imputation itself.


```{r alpha}
alpha = 1/nperm
```

The plots below show the distributions of p values for both 
the R2 statistic and the LOD score statistic. Both are
skewed toward 0. The dot plot shows that the p values for 
these two statistics are highly correlated, but not identical.

```{r perm_plots, fig.width = 8, fig.height = 8, eval = FALSE}
max.chrom.r2 <- sapply(chrom.r2, function(x) if(length(x) > 1){max(x[,"Additive"], na.rm = TRUE)}else{NA})
max.chrom.lod <- sapply(chrom.lod, function(x) if(length(x) > 1){max(x[,"Additive"], na.rm = TRUE)}else{NA})
lod.p <- sapply(1:length(chrom.lod), 
  function(x) if(!all(is.na(perm.lod[[x]]))){emp.p(max.chrom.lod[x], perm.lod[x,])}else{NA})
r2.p <- sapply(1:length(chrom.lod), 
  function(x) if(!all(is.na(perm.r2[[x]]))){emp.p(max.chrom.r2[x], perm.r2[x,])}else{NA})
results.table <- cbind(max.chrom.lod, lod.p, max.chrom.r2, r2.p)

saveRDS(results.table, file.path(results.dir, "Perm_Results.RDS"))

par(mfrow = c(2,2))
hist(lod.p, breaks = 100, main = "LOD score p values",
  xlab = "p value")
hist(r2.p, breaks = 100, main = "R2 p values",
  xlab = "p value")
plot(-log10(lod.p+1e-3), -log10(r2.p+1e-3), main = "LOD vs. R2",
  xlab = "-log10(LOD p values)", ylab = "-log10(R2 p values")
```


The following plots show each test statistic vs. its
p values. In general higher test statistics have lower
p values, but this is not strictly true. 


```{r, fig.width = 8, fig.height = 4, eval = FALSE}
par(mfrow = c(1,2))
plot(max.chrom.lod, -log10(lod.p+1e-3), xlab = "LOD", ylab = "-log10(p)", 
  main = "LOD vs. LOD -log10(p)")

plot(max.chrom.r2, -log10(r2.p+1e-3), xlab = "Variance Explained", 
  ylab = "-log10(p)", main = "R2 vs. R2-log10(p)")

#sig.col <- colors.from.values(-log10(lod.p+1e-3), grad.dir = "high",
#  col.scale = "blue", light.dark = "f")
#plot.order <- rev(order(sig.col))
#plot(max.chrom.lod[plot.order], max.chrom.r2[plot.order], 
#  ylab = "Variance Explained", xlab = "LOD",
#  col = sig.col[plot.order], pch = 16, 
#  main = "LOD vs. R2\nDarker ",
# )
```


```{r example, eval = FALSE}
sig.chrom <- which(lod.p <= alpha)
library(gprofiler2)
enrich <- gost(common.transcripts[sig.chrom], organism = "mmusculus")
plot.enrichment(enrich, max.term.size = 2000, num.terms = 30)

example.gene <- sig.chrom[6]
gene.name <- transcript.info[which(transcript.info[,"ensembl_gene_id"] == rownames(geno.lod)[example.gene])[1], "external_gene_name"]
hap.lod <- geno.lod[example.gene,"Additive"]
obs.lod <- max(chrom.lod[[example.gene]][,"Additive"])
null.lod <- perm.lod[example.gene,]
xmin <- min(c(null.lod, obs.lod, hap.lod))
xmax <- max(c(null.lod, obs.lod, hap.lod))
hist(perm.lod[example.gene,], breaks = 50, xlim = c(xmin, xmax), main = gene.name,
  xlab = "LOD")
abline(v = c(obs.lod, hap.lod), col = c("red", "blue"))
legend("topleft", legend = c("observed", "haplotype"), col = c("red", "blue"), lty = 1)

```


## Permutations for SNPs

We permuted the SNPs as we did for chromatin state.
We permute the haplotype that is assigned to each SNP 
vector, re-do the imputation, and recalculate the LOD
scores and R2 values.

```{r perm_fun}
#This function and the perm data will be exported to the
#clusters
scan_one_snp <- function(perm.data, p){

    perm.order <- order.mat[p,]
  
    snp.array <- snp_geno(gene.snp.array = perm.data$snp.mat, 
        haplotype.matrix = perm.data$haps, 
        gene.chr = perm.data$chr, perm.order = perm.order)

    if(is.na(snp.array)){return(NA)}

    one.lod <- scan1(snp.array, perm.data$expr)
    regression.models  <- apply(snp.array[[1]], 3, function(x) lm(perm.data$expr[common.expr.locale,]~x[common.genoprob.locale,]))
    one.r2 <- sapply(regression.models, function(x) if(length(x) > 1){summary(x)$adj.r.squared}else{NA})
              
    results <- list("one.lod" = one.lod, 
        "one.r2" = one.r2)

  return(results)
}
```

```{r select_nperm}
nperm = 1000
```


```{r set_perm}
#select a set of permutations for which none of 
#the haplotypes remain in their original position.
#these are called derrangements
perm.mat <- derrangements(8)
#sample a random set of derraangements to use
#for all transcripts
perm.rows <- sample(1:nrow(perm.mat), nperm)
order.mat <- perm.mat[perm.rows,]
```



```{r perm_files}

perm.lod.snp.file <- here("Results", "SNPs", "Perm.SNP.LOD.RDS")
perm.r2.snp.file <- here("Results", "SNPs", "Perm.SNP.R2.RDS")

if(file.exists(perm.lod.snp.file)){
  perm.snp.lod <- readRDS(perm.lod.snp.file)
  perm.snp.r2 <- readRDS(perm.r2.snp.file)

  #figure out where we left off.
  not.na <- which(!is.na(perm.snp.lod[,1]))  
  left.off <- max(not.na)
  start.at <- left.off + 1
}else{
  start.at <- 1
  #if we are at the beginning, intialize all the objects for holding
  #results. 
  perm.snp.lod <- perm.snp.r2 <- matrix(NA, nrow = length(all.snp.lod), ncol = nperm)
  rownames(perm.snp.lod) <- rownames(perm.snp.r2) <- names(all.snp.lod)
}

```


```{r set_cl, warning = FALSE}
save.every = 100
if(start.at < length(all.snp.lod)){
  #set up the clusters if we need to run perutations
  n.cores <- detectCores() - 1
  to.export <- c("scan1", "scan1coef", "scan_one_snp", "order.mat",
    "snp_geno", "abind", "common.expr.locale", "common.genoprob.locale")

  #create and register multiple cores for parallele permutations
  cl <- makeCluster(n.cores)
  registerDoParallel(cl)
  #export everything we need to the cluster
  #this takes time upfront, but the parallelization
  #saves a huge amount of time overall
  clusterExport(cl, to.export) 
}

```


```{r perm_snps}

geno.lod.file <- here("Results", "ChromHMM", "14_states_C", "eQTL.lod.RDS")
geno.lod <- readRDS(geno.lod.file)

lod.thresh = 6
to.perm <- which(geno.lod[,"Additive"] > lod.thresh)
do.perm <- rep(FALSE, length(common.transcripts))
do.perm[to.perm] <- TRUE

if(start.at < length(all.snp.lod)){
  sink(here("Results", "SNPs", "progress.txt"))
  for(tr in start.at:length(perm.snp.lod)){
    cat(paste0(tr, ":"))

    if(!do.perm[tr]){cat(" LOD score < 6\n");next()}

    if(length(snp.mats[[tr]]) == 1){cat(" No SNP matrix\n");next()}
    if(nrow(snp.mats[[tr]]) > 2000){cat(" SNP matrix too large\n");next()}

    gene.expr <- expr[,which(colnames(expr) == common.transcripts[tr]),drop=FALSE]
    adj.expr <- adjust(gene.expr, covar)

    if(nrow(snp.mats[[tr]]) < 2){cat(" Not enough SNPs to test\n");next()}

    perm.data <- list("snp.mat" = snp.mats[[tr]],
        "haps" = gene.marker[[tr]], 
        "chr" = transcript.info.table[tr,"chromosome_name"],
        "expr" = adj.expr)


    #send the new gene ID to the clusters
    clusterExport(cl, "perm.data")

    #do the permutations in parallel
    perm.snp.results <- parLapply(cl, 1:nperm, 
        function(p) scan_one_snp(perm.data, 
        p = p))

    #check for NAs
    if(!all(sapply(perm.snp.results, length) > 1)){cat(" No data returned from permutations\n"); next()}

    perm.tr.lod <- lapply(perm.snp.results, function(x) x$one.lod)
    perm.tr.r2 <- lapply(perm.snp.results, function(x) x$one.r2)

    #keep the maximum r2 and LOD values from each permutation.
    perm.snp.lod[tr,] <- t(sapply(perm.tr.lod, function(x) max(x[,1])))
    perm.snp.r2[tr,] <- t(sapply(perm.tr.r2, function(x) max(x, na.rm = TRUE)))

    if(tr %% save.every == 0){
        saveRDS(perm.snp.lod, perm.lod.snp.file)
        saveRDS(perm.snp.r2, perm.r2.snp.file)
    }

    cat(" Finished permutations\n")

  } #end looping over transcripts
  #save again at the very end
  saveRDS(perm.snp.lod, perm.lod.snp.file)
  saveRDS(perm.snp.r2, perm.r2.snp.file)

  sink()

  #close the clusters at the end and save the final objects
  stopCluster(cl)

} #end case for needing to do more permutations.
```

## Assess permutations

To assess the permutations, we look at the distribution
of empirical p values. If this distribution is uniform,
then it is the imputation itself that is explaining the
LOD scores we see. If the distribution is skewed toward
0, then the DNA methylation is adding something beyond
the imputation itself.


The plots below show the distributions of p values for both 
the R2 statistic and the LOD score statistic. Both are
skewed toward 0. The dot plot shows that the p values for 
these two statistics are highly correlated, but not identical.

```{r assess_lod_perm, fig.width = 8, fig.height = 8}
geno.lod <- readRDS(here("Results", "ChromHMM", "14_states_C", "eQTL.lod.RDS"))
low.lod <- which(geno.lod[,"Additive"] <= 6)
low.lod.idx <- match(rownames(geno.lod)[low.lod], names(all.snp.lod))

max.snp.lod <- sapply(all.snp.lod, function(x) if(length(x) > 1){max(x[,1], na.rm = TRUE)}else{NA})
lod.p <- sapply(1:length(all.snp.lod), 
  function(x) if(!all(is.na(perm.snp.lod[x,]))){emp.p(max.snp.lod[x], perm.snp.lod[x,])}else{NA})
names(lod.p) <- names(all.snp.lod)

max.snp.r2 <- sapply(all.snp.r2, function(x) if(!all(is.na(x))){max(x, na.rm = TRUE)}else{NA})
r2.p <- sapply(1:length(all.snp.r2), 
  function(x) if(!all(is.na(perm.snp.r2[x,]))){emp.p(max.snp.r2[x], perm.snp.r2[x,])}else{NA})
names(r2.p) <- names(all.snp.r2)

results.table <- cbind(max.snp.lod, lod.p, max.snp.r2, r2.p)
saveRDS(results.table, here("Results", "SNPs", "Perm_Results.RDS"))

par(mfrow = c(2,2))
lod.p[low.lod.idx] <- NA
hist(lod.p, breaks = 100, main = "LOD score p",
  xlab = "p value")

r2.p[low.lod.idx] <- NA
hist(r2.p, breaks = 100, main = "R2 p",
  xlab = "p value")

plot(-log10(lod.p+1e-3), -log10(r2.p+1e-3), xlab = "-log10(LOD p)",
  ylab = "-log10(R2 p)", main = "LOD p vs. R2 p")
```

The following plots show each test statistic vs. its
p values. In general higher test statistics have lower
p values, but this is not strictly true. 


```{r stat_v_p, fig.width = 8, fig.height = 4}
par(mfrow = c(1,2))
plot(max.snp.lod, -log10(lod.p+1e-3), xlab = "LOD", ylab = "-log10(p)", 
  main = "LOD vs. LOD -log10(p)")

plot(max.snp.r2, -log10(r2.p+1e-3), xlab = "Variance Explained", 
  ylab = "-log10(p)", main = "R2 vs. R2-log10(p)")
```

```{r example, eval = FALSE}
examples <- which(lod.p == 0)
i <- examples[1]
gene.name = gene.info[which(gene.info[,"ensembl_gene_id"] == names(lod.p)[i]),"external_gene_name"][1]
xlim <- c(min(c(perm.snp.lod[i,], max.snp.lod[i])), max(c(perm.snp.lod[i,], max.snp.lod[i])))
hist_with_points(c(perm.snp.lod[i,], max.snp.lod[i]), 
  col = c(rep("gray", ncol(perm.snp.lod)), "red"), xlab = "LOD", main = gene.name)
abline(v = max.snp.lod[i], col = "red")
```
