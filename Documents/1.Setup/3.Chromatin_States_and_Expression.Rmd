---
title: "Analyzing ChromHMM Results"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction

The purpose of this workflow is to combine chromatin state data from 
a single chromHMM model and gene expression. This workflow takes a 
gene-based approach. It calculates the chromatin state composition of 
each gene and calculates correlations between the state composition and
gene expression.

It performs the following specific tasks:

**Gene Expression**

1. Generate information file for RNA-Seq data.
    * produces file RNASeq\_gene\_info.RData
2. Average expression across individuals in a given strain.
    * produces file Strain\_Mean\_C\_Expression.RData
2. Filter out genes with low variance across strains.
    * no file is produced. Low-variance genes are replace with NA's.

**DO eQTL**

1. Extracts cis eQTL coefficients and writes to cis.coef.RData.

**Chromatin**

1. Create matrices of chromatin states for each transcript.
    * produces file with the pattern 
    Chromatin\_States\_num.states\_gene.type\_bp.buffer.RData
2. Create matrices of chromatin state proportions for each transcript.
    * produces a file with the pattern 
    Chromatin\_State\_num.states\_Prop\_gene.type\_bp.buffer.RData
3. Dimension reduces the proportion matrices using multi-dimensional scaling.
    * produces a file with the pattern 
    Chromatin\_State\_num.states\_MDS\_gene.type\_bp.buffer.RData
4. Exploration of states
    * Heatmap of state proportions across strains.

**Chromatin and Expression**

1. Correlate proportion of each chromatin state in each gene with gene expression.
    * produces file with the pattern
    State\_num.states\_Prop_\Expression\_Cor\_gene.type\_bp.buffer.RData
    *This file contains pearson correlation r values and p values.
2. Correlate MDS dimension-reduced chromatin proportion matrix with gene expression
    * produces file with the pattern
    State\_num.states\_MDS\_Expression\_Cor\_gene.type\_bp.buffer.RData
3. Explore examples
    Plots are generated for example genes showing where specific chromatin 
    states are correlated with gene expression across the strains.

```{r set_args}
args <- commandArgs(trailingOnly=T)
num.states <- as.numeric(args[1])
offline = as.logical(args[2]) #set to TRUE to avoid all functions that use the internet
                #some files may need to be generated ahead of time to use 
                #this setting
is.interactive = as.logical(args[3]) #keep this as FALSE when running render()
                    #use TRUE if running interactively. It plots
                    #one gene data in multiple windows                    
delete.previous = as.logical(args[4]) #whether to delete and regenerate files 
                    #from previous a run.
#num.states = 8; offline = FALSE; is.interactive = TRUE; deleted.previous = FALSE
```


```{r source_code}
library("here")
all.code.dir <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.code.dir)){
	all.fun <- list.files(all.code.dir[i], full.names = TRUE, pattern = ".R")
	for(j in 1:length(all.fun)){source(all.fun[j])}
}
```


```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
needed.packages <- c("biomaRt", "VennDiagram", "ape", "gprofiler2", 
"e1071", "DESeq2", "knitr", "pheatmap", "hexbin", "RColorBrewer", "MASS", 
"gridExtra", "grid", "ggplotify")
load_libraries(needed.packages)
```


## Setup
Set the number of states to be analyzed, and the mark, if relevant.

```{r state_num}
sig.val = 0.05
selected.mark <- NULL #set to null to use all marks
#selected.mark <- "H3K4me1"
#selected.mark <- "H3K4me3"
#selected.mark <- "H3K27ac"
#selected.mark <- "H3K27me3"
```

Set up additional parameters for looking at states around gene bodies.
These are changeable, but will not change after the 

```{r set_param}
start.feature = "start_position" #feature of gene to start from. start_position means TSS, and end_position means TES
end.feature = "end_position" #feature of gene to end at. start_position means TSS, and end_position means TES
upstream.buffer = 1000 #number of bp upstream to go from start.feature
downstream.buffer = 1000 #number of bp downstream to go from end.feature
T.or.C <- "C" #whether to analyze the control (C) or treatment (T) animals.
```

```{r setup_dir}
#data and results are a little bit mixed up, since results from one
#analysis can be data for another analysis. I try to keep processed
#data in data directories and final results in results directories.
form.states <- paste0(formatC(num.states, digits = 2, flag = 0), "_states", 
selected.mark, "_", T.or.C)
data.dir <- here("Data", "ChromHMM", form.states)
results.dir <- here("Results", "ChromHMM", form.states)
if(!file.exists(results.dir)){dir.create(results.dir)}
```


```{r results_files}
if(start.feature == "start_position" && end.feature == "start_position"){
    gene.text <- "TSS"
    }
if(start.feature == "start_position" && end.feature == "end_position"){
    gene.text <- "full_gene"
    }

buffer.text <- paste(unique(c(upstream.buffer, downstream.buffer)), collapse = "_")

state.enrichment.file <- here("Results", "ChromHMM", form.states, "enrichment.by.state.RData")
```

```{r clear_results}
#If evaluated, this chunk will clear out all results generated
#by this script to trigger recalculation of all results
if(delete.previous){
    delete.files <- list.files(here("Results", form.states, "1.ChromHMM", form.states), full.names = TRUE)
    if(length(delete.files) > 0){
        for(i in 1:length(delete.files)){
            unlink(delete.files[i])
        }
    }
}
```

Strain names between different analyses are inconsistent. We have a table for 
comparing different names as well as for defining strain colors. I made this
table by hand. Load it here:

```{r load_color_key}
key.file <- here("Data", "support_files", "strain.color.table.txt")
col.table <- as.matrix(read.table(key.file, sep = "\t", comment.char = "%", 
stringsAsFactors = FALSE))
```

Setup biomaRt mouse library:

```{r setup_biomart_library}
all.var <- ls()

lib.loaded <- as.logical(length(which(all.var == "mus")))
if(!lib.loaded){
    if(!offline){
        mus <- useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl") #most current library
        #mus <- useMart("ENSEMBL_MART_ENSEMBL", dataset = "mmusculus_gene_ensembl", 
        #host = "may2017.archive.ensembl.org") #stable archived library
    }
}
```

## Expression Data

The expression data were processed in the Expression workflow. That workflow
performed the following. 
1. Filtered for genes with at least 5 reads in at least 20\% of animals
2. Performed vst on expression data.
All animals are female, so we do not need to do a correction for sex.

### Expression distribution across samples

```{r load_expression, fig.width = 7, fig.height = 5}
rna.seq.file <- here("Data", "RNASeq", "StrainsEffCts9_vst.RDS")
rna.seq <- readRDS(rna.seq.file)
boxplot(rna.seq, las = 2)
```

```{r gene_info}
#Get information about all expressed genes from BiomaRt:
gene.info.file <- here("Data", "RNASeq", "RNASeq_gene_info.RData")
if(!file.exists(gene.info.file)){
    rnaseq.gene.info <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", 
    "chromosome_name", "start_position", "end_position", "transcription_start_site", 	"exon_chrom_start", "exon_chrom_end",
    "5_utr_start","5_utr_end","3_utr_start", "3_utr_end", "strand"), 
    filters = "ensembl_gene_id", values = rownames(rna.seq), mart = mus)
    saveRDS(rnaseq.gene.info, gene.info.file)
}else{
    rnaseq.gene.info <- readRDS(gene.info.file)
}
```

Average expression across individuals in each strain.

```{r strain_expr}
#file containing strain averages for each transcript. These
#do not change from run to run. Save in data
strain.expr.file <- here("Data", "RNASeq", paste0("Strain_Mean_", T.or.C, "_Expression.RData"))

if(!file.exists(strain.expr.file)){
    #get expression for the condition (control or treatment)
    strain.mean.expr <- lapply(rownames(rna.seq), function(x) 
    get.cond.expr(rnaseq.gene.info, rna.seq, x, T.or.C = T.or.C, return.mean = TRUE))
    names(strain.mean.expr) <- rownames(rna.seq)
    #save the results
    saveRDS(strain.mean.expr, strain.expr.file)
}else{
    strain.mean.expr <- readRDS(strain.expr.file)
}
```

### Expression median and variance

The following plots show distributions of expression medians and variances, as well as
median and variance plotted against each other. The vertical line in the variance 
histogram shows where we filtered genes for low variance across strains.

```{r mean.var, fig.width = 12, fig.height = 4}
var.lim <- 0.3
par(mfrow = c(1,3))
expr.med <- apply(rna.seq, 1, median)
expr.var <- apply(rna.seq, 1, var)
hist(expr.med, breaks = 100, main = "Median Expression")
hist(expr.var, breaks = 100, main = "Expression Variance")
abline(v = var.lim, col = "red")
plot(expr.med, expr.var)
```

### Expression Variation Filter

Because we are specifically interested in variance in expression across 
strains, we filtered the transcripts to include those that had a large amount
of variation across strains. We chose only those transcripts that had at least 
a difference of `r var.lim` between the highest-expressing strain, and the 
lowest-expressing strain.

```{r strain_expr_filter}
zero.expr <- rep(NA, 9)
names(zero.expr) <- names(strain.mean.expr[[1]])
strain.var <- sapply(strain.mean.expr, function(x) max(x) - min(x))
low.var <- which(strain.var < var.lim)
if(length(low.var) > 0){
    for(i in 1:length(low.var)){
        strain.mean.expr[[low.var[i]]] <- zero.expr
    }
}
```

## DO eQTL data
We want to compare histone effects on expression with genetic effects. To identify genetic
effects we use the DO478. Here we use an eQTL analysis run Bo Ji. These data were collected
from whole DO mouse liver. In this data object are included eQTL coefficients for all 
transcripts and all haplotypes. Only the chromosome on which the transcript is encoded is 
included. Therefore we only have access to cis eQTL coefficients in this object.

```{r do_QTL}
#A file containing the cis eQTL coefficients for each haplotype and each transcript
do.qtl.file <- here("Data", "DOQTL", "DO478_tpm_20360_cis_allele_coef.RData")
do.eqtl.loaded <- as.logical(length(which(all.var == "do.eqtl")))
if(!do.eqtl.loaded){
    do.eqtl <- readRDS(do.qtl.file)
    qtl.ids <- lapply(do.eqtl, function(x) x[[1]][1,1])
    is.missing <- unlist(lapply(qtl.ids, function(x) is.null(x)))
    qtl.ids[is.missing] <- "NA"
    qtl.id.v <- unlist(qtl.ids)
    names(do.eqtl) <- qtl.id.v
}

#the cis eQTL coefficients of each mapped gene
cis.coef.file <- here("Data", "DOQTL", "cis.coef.RData")
if(!file.exists(cis.coef.file)){
    all.cis.coef <- lapply(1:length(do.eqtl), function(x) get.cis.coef(do.eqtl, x))
    names(all.cis.coef) <- names(do.eqtl)
    saveRDS(all.cis.coef, cis.coef.file)
}else{
    all.cis.coef <- readRDS(cis.coef.file)
}
```

## ChromHMM
We analyzed the chromatin states based on states output by ChromHMM. 
See analysis 1.ChromHMM.Rmd. This analysis looks at the output from the model with
`r num.states` states.


```{r load_bed}
#Load the ChromHMM bed files for all strains:
bed.files <- list.files(data.dir, pattern = "dense.bed", full.names = TRUE)
strains <- substr(colnames(rna.seq), 1,2)
strain.names <- sort(unique(strains))
strain.bed.names <- sapply(strsplit(basename(bed.files), "_"), function(x) x[1])

#Naming conventions between data sets are inconsistent.
#make a key by hand for conversion
if(T.or.C == "C"){
    strain.key <- cbind(strain.bed.names, c(strain.names[8], strain.names[-8]))
}else{
    strain.match <- match(strain.bed.names, strains)
    strain.key <- cbind(strain.bed.names, strains[strain.match])
}

all.bed <- vector(mode = "list", length = nrow(strain.key))
names(all.bed) <- strain.key[,1]
for(i in 1:nrow(strain.key)){
    bed.locale <- grep(pattern = strain.bed.names[i], bed.files)[1]
    if(!is.na(bed.locale) > 0){
        all.bed[[i]] <- read.table(bed.files[bed.locale], sep = "\t", skip = 1, 
        stringsAsFactors = FALSE)
    }
}
```

## Chromatin states by gene
The first step in this analysis is to create matrices of chromatin states for each transcript.
In this step, we go through all transcripts in the RNA Seq data set. For each transcript, we
get the ChromHMM states around the gene body or transcription start site as defined by the 
parameters at the top of this file. The states across all strains are combined into a single 
matrix.

```{r get_chrom_states, warning = FALSE}
#This chunk takes about 3 hours to run depending 
#on the number of genes in the filtered expression 
#table.
#file containing chromatin states in and around each transcript
chrom.state.file <- file.path(results.dir, 
paste0("Chromatin_States_", num.states, "_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(chrom.state.file)){
    #get the states around each transcript across all strains
	chrom.mats <- lapply(rownames(rna.seq), function(x) get.chrom.state(bed.info = all.bed, 
    rnaseq.gene.info, rna.seq, x, start.feature, end.feature, upstream.buffer, 
    downstream.buffer))
	names(chrom.mats) <- rownames(rna.seq)
	saveRDS(chrom.mats, chrom.state.file)
}else{
    chrom.mats <- readRDS(chrom.state.file)
}

#file containing proportions of each chromatin state in and around each transcript
chrom.prop.file <- file.path(results.dir,
paste0("Chromatin_State_", num.states, "_Prop_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(chrom.prop.file)){
	chrom.state.props <- get.chrom.state.prop(chrom.mats, num.states = num.states, verbose = FALSE)
	names(chrom.state.props) <- rownames(rna.seq)
	saveRDS(chrom.state.props, chrom.prop.file)
}else{
    chrom.state.props <- readRDS(chrom.prop.file)
}

#file containing the one-dimensional reduction of each chromatin state matrix
chrom.mds.file <- file.path(results.dir,
paste0("Chromatin_State_", num.states, "_MDS_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(chrom.mds.file)){
    chrom.mds <- get.scaled.chrom.mats(chrom.mats, 1)
    saveRDS(chrom.mds, chrom.mds.file)
}else{
    chrom.mds <- readRDS(chrom.mds.file)
}
```

The following plot shows the distribution of state proportions across genes. 
Each row is a single gene. Each column is one state for one strain.

```{r states_across_genes, fig.width = 15, fig.height = 7}
all.state.len <- sapply(chrom.state.props, length)
enough.states <- which(all.state.len > 1)
all.state.props <- t(sapply(chrom.state.props[enough.states], as.vector))
states <- chrom.state.props[[1]]
colnames(all.state.props) <- paste(rep(colnames(states), each = nrow(states)), rep(rownames(states), ncol(states)), sep = "_")
state.prop.heat.file <- file.path(results.dir,
paste0("Chromatin_State_", num.states, "_pheatmap_", gene.text, "_", buffer.text, ".RData"))
if(!file.exists(state.prop.heat.file)){
    state.prop.pheat <- pheatmap(all.state.props, show_rownames = FALSE)
    saveRDS(state.prop.pheat, state.prop.heat.file)
}else{
        state.prop.pheat <- readRDS(state.prop.heat.file)
        state.prop.pheat
}
```

## Chromatin state and inbred expression
We then looked for a relationship between the variation in chromatin state across
strains and expression.

For each transcript, we correlated the mean inbred expression with the proportion of 
the chromatin state in the sampled region.

This gives us a matrix with transcripts in rows and chromatin states in columns.

```{r states_and_expression}
#file containing r and p values indicating correlation between state proportions and expression values
states.expression.file <- file.path(results.dir,
paste0("State_", num.states, "_Prop_Expression_Cor_", gene.text, "_", buffer.text, ".RData"))

if(!file.exists(states.expression.file)){
    cor.prop.results <- state.prop.expression(chrom.state.prop = chrom.state.props, 
    group.mean.expr = strain.mean.expr, strain.key = col.table, verbose = is.interactive)
    
    all.prop.p <- Reduce("rbind", lapply(cor.prop.results, function(x) x$p))
    rownames(all.prop.p) <- names(strain.mean.expr)
    all.prop.r <- Reduce("rbind", lapply(cor.prop.results, function(x) x$r))
    rownames(all.prop.r) <- names(strain.mean.expr)
    saveRDS(list("all.p" = all.prop.p, "all.r" = all.prop.r), states.expression.file)
}else{
    cor.prop.results <- readRDS(states.expression.file)
    all.prop.p <- cor.prop.results$all.p
    all.prop.r <- cor.prop.results$all.r
}

#do the same for the matrices scaled with mds
state.mds.expression.file <- file.path(results.dir,
paste0("State_", num.states, "_MDS_Expression_Cor_", gene.text, "_", buffer.text, ".RData"))

if(!file.exists(state.mds.expression.file)){
    cor.mds.results <- state.scaled.expression(scaled.chrom = chrom.mds, 
    group.mean.expr = strain.mean.expr, strain.key = col.table, 
    verbose = is.interactive)
    all.mds.p <- sapply(cor.mds.results, function(x) x[2])
    all.mds.r <- sapply(cor.mds.results, function(x) x[1])
    saveRDS(list("all.p" = all.mds.p, "all.r" = all.mds.r), state.mds.expression.file)
}else{
    cor.mds.results <- readRDS(state.mds.expression.file)
    all.mds.p <- cor.mds.results$all.p
    all.mds.r <- cor.mds.results$all.r
    }
```

### Correlation distributions by state

The plot below shows all values of Pearson's r for each state and each transcript.
For each gene we 
Points are colored based on the -log of the p value of the correlation. This gives
an idea of how many correlations were able to be calculated for each state (i.e. the 
state had some variation across strains), the range of correlations, and whether the 
significant correlations were predominantly positive or negative.

```{r state.effect}

plot.new()
plot.window(xlim = c(0,(ncol(all.prop.r)+1)), ylim = c(-1, 1))
for(i in 1:ncol(all.prop.r)){
    p.col <- colors.from.values(-log10(all.prop.p[,i]), use.pheatmap.colors = TRUE)
    not.na <- which(!is.na(all.prop.r[,i]))
    points(x = jitter(rep(i, nrow(all.prop.r))), y = all.prop.r[,i], col = p.col, 
    pch = 16, cex = 0.5)
    boxplot(all.prop.r[not.na,i], at = i, col = "lightgray", add = TRUE)
    }
axis(2);mtext(side = 2, "Correlation Coefficient", line = 2.5)
abline(h = 0)
par(xpd = TRUE)
text(x = 1:ncol(all.prop.r), y = -1.1, labels = paste0("State", 1:ncol(all.prop.r)), 
srt = 90, adj = 1)
par(xpd = FALSE)

sig.r <- all.prop.r
sig.r[which(all.prop.p > sig.val)] <- NA
sig.r.list <- lapply(1:ncol(sig.r), function(x) sig.r[,x])
```

## State Annotations

The heatmap below shows the emission probabilities for each state found by ChromHMM.
This shows us which marks each of the states in the barplot has.

```{r emissions, results = "asis"}
emissions.file <- file.path(data.dir, paste0("emissions_", num.states, ".png"))
cat("![](",emissions.file,")")
```

## Chromatin state examples {.tabset .tabset-fade .tabset-pills}

Below are figures showing examples of correlations between each state and 
gene expression.

```{r state_example_fun}
plot.state.example <- function(ex.state){
    if(ncol(all.prop.r) < ex.state){
        plot.text("This state not in data set")
    }else{
        mean.cor <- mean(all.prop.r[,ex.state], na.rm = TRUE)
        if(mean.cor < 0){dec <- FALSE}else{dec <- TRUE}
        ordered.cor <- sort(all.prop.r[,ex.state], decreasing = dec)

        gene.name <- NULL
        idx <- 1
        while(length(gene.name) == 0 || is.na(gene.name)){
            gene.id <- names(ordered.cor)[idx]
            gene.name <- rnaseq.gene.info[which(rnaseq.gene.info[,"ensembl_gene_id"] == gene.id)[1],"external_gene_name"]
            idx <- idx + 2
        }

    plot.one.gene(do.eqtl, rnaseq.gene.info, rna.seq, all.bed, col.table, gene.name, 
    T.or.C, start.feature, end.feature, upstream.buffer, downstream.buffer, 
    separate.windows = is.interactive, dim.rd = "state.prop", state = ex.state, 
    total.states = num.states)
    }
}
```

```{r state_examples, results = "asis", fig.width = 7, fig.height = 8}
for(i in 1:num.states){
    cat(paste("### State", i, "Example\n"))
    plot.state.example(i)
    cat("\n\n")
}
```

## Examples of Previously Studied Genes {.tabset .tabset-fade .tabset-pills}
The following figures are checks to make sure genes we noticed in previous analyses
are still correlated with chromatin state.

### Hsd3b1

```{r Hsd3b1, eval = TRUE, fig.width = 7, fig.height = 8}
plot.one.gene(do.eqtl, rnaseq.gene.info, rna.seq, all.bed, col.table, 
    gene.name = "Hsd3b1", T.or.C, start.feature, end.feature, upstream.buffer, 
    downstream.buffer, separate.windows = is.interactive, dim.rd = "mds", state = NULL, 
    total.states = num.states, show.state.numbers = FALSE)
```

### Igf1 

```{r igf1, fig.width = 7, fig.height = 8}
plot.one.gene(do.eqtl, rnaseq.gene.info, rna.seq, all.bed, col.table, "Igf1", 
    T.or.C, start.feature, end.feature, upstream.buffer = 3e4, downstream.buffer, 
    separate.windows = is.interactive, dim.rd = "mds", state = NULL, 
    total.states = num.states, show.state.numbers = FALSE)
```

